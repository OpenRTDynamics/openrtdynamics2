
//
// Code generated by OpenRTDynamics 2 using the Linux real-time target.
//
// https://wiki.linuxfoundation.org/realtime/start
//

#include <sched.h>

#include <time.h>
#include <sys/time.h>

#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>

#include <sys/mman.h>
#include <pthread.h>
#include <sys/sysinfo.h>
#include <signal.h>


#include <stdio.h>
#include <math.h>

// namespace for simulation {
  // global variables

  class simulation {
    public:


    // state update
    double block_2_mem;


    // state update


    //
    // cached output values
    //

    double __ORTD_CONTROL_delta_time____block_3;
    double output__block_2;

    // API-function resetStates
    void resetStates() { // created by cpp_define_function

      block_2_mem = 2.0;
    }
    // output signals of  resetStates
    struct Outputs_resetStates{
      ;

    };
    // input signals of resetStates
    struct Inputs_resetStates{
      ;

    };
    // wrapper function for resetStates
    Outputs_resetStates resetStates__(Inputs_resetStates inputs) {
      Outputs_resetStates outputs;

      resetStates();

      return outputs;
    }
    // API-function updateStates
    void updateStates(double input1) { // created by cpp_define_function
      double s2;


      // restoring the signals __ORTD_CONTROL_delta_time__, output from the states 
      double &__ORTD_CONTROL_delta_time__ = __ORTD_CONTROL_delta_time____block_3;
      double &output = output__block_2;


      // calculating the block outputs in the following order s2
      // that depend on input1
      // dependencies that require a state update are  

      s2 = output + input1;

      block_2_mem = s2;

      // calculating the block outputs in the following order 
      // that depend on 
      // dependencies that require a state update are  


    }
    // output signals of  updateStates
    struct Outputs_updateStates{
      ;

    };
    // input signals of updateStates
    struct Inputs_updateStates{
      double input1;

    };
    // wrapper function for updateStates
    Outputs_updateStates updateStates__(Inputs_updateStates inputs) {
      Outputs_updateStates outputs;

      updateStates(inputs.input1);

      return outputs;
    }
    // API-function calcResults_1 to compute: __ORTD_CONTROL_delta_time__, output
    void calcResults_1(double &__ORTD_CONTROL_delta_time__, double &output) { // created by cpp_define_function


      // calculating the block outputs in the following order __ORTD_CONTROL_delta_time__, output
      // that depend on 
      // dependencies that require a state update are s2 

      __ORTD_CONTROL_delta_time__ = 0.1;
      output = block_2_mem;

      // saving the signals __ORTD_CONTROL_delta_time__, output into the states 
      __ORTD_CONTROL_delta_time____block_3 = __ORTD_CONTROL_delta_time__;
      output__block_2 = output;
    }
    // output signals of  calcResults_1
    struct Outputs_calcResults_1{
      double __ORTD_CONTROL_delta_time__;
      double output;

    };
    // input signals of calcResults_1
    struct Inputs_calcResults_1{
      ;

    };
    // wrapper function for calcResults_1
    Outputs_calcResults_1 calcResults_1__(Inputs_calcResults_1 inputs) {
      Outputs_calcResults_1 outputs;

      calcResults_1(outputs.__ORTD_CONTROL_delta_time__, outputs.output);

      return outputs;
    }
    // all system inputs and outputs combined
    struct Inputs{
      double input1;

    };
    struct Outputs{
      double __ORTD_CONTROL_delta_time__;
      double output;

    };
    // main step function 
    void step(Outputs & outputs, Inputs const & inputs, int calculate_outputs, bool update_states, bool reset_states) {
      if (reset_states) {
        resetStates();

      }
      if (calculate_outputs==1) {
        calcResults_1(outputs.__ORTD_CONTROL_delta_time__, outputs.output);

      }
      if (update_states) {
        updateStates(inputs.input1);

      }

    }
  };

// end of namespace for simulation




#define ORTD_RT_REALTIMETASK 1
#define ORTD_RT_NORMALTASK 2

#define MAX_SAFE_STACK (8*1024) /* The maximum stack size which is guaranteed safe to access without faulting */
#define NSEC_PER_SEC    (1000000000) // The number of nsecs per sec.
#define USEC_PER_SEC	(1000000)


static inline void tsnorm(struct timespec *ts)
{
    while (ts->tv_nsec >= NSEC_PER_SEC) {
        ts->tv_nsec -= NSEC_PER_SEC;
        ts->tv_sec++;
    }
}

static inline double calc_diff(struct timespec t1, struct timespec t2)
{
    long diff;
    diff = USEC_PER_SEC * ((int) t1.tv_sec - (int) t2.tv_sec);
    diff += ((int) t1.tv_nsec - (int) t2.tv_nsec) / 1000;
    return (1e-6*diff);
}

void ortd_rt_stack_prefault(void) {

    unsigned char dummy[MAX_SAFE_STACK];

    memset(dummy, 0, MAX_SAFE_STACK);
    return;
}

long int ortd_mu_time()
{
    struct timeval mytime;
    struct timezone myzone;

    gettimeofday(&mytime, &myzone);
    return (1000000*mytime.tv_sec+mytime.tv_usec);
}

int ortd_rt_change_priority(unsigned int flags, int priority)
{
    if (flags & ORTD_RT_REALTIMETASK) {

        /* Lock memory */
        if(mlockall(MCL_CURRENT|MCL_FUTURE) == -1) {
            perror("mlockall failed");
            return(-2);
        }

        ortd_rt_stack_prefault();

        /* Declare ourself as a real-time task */

        struct sched_param param;

        param.sched_priority = priority;
        if(sched_setscheduler(0, SCHED_FIFO, &param) == -1) {
            perror("sched_setscheduler failed");
            return(-1);
        }


        fprintf(stderr, "initialized a real-time thread\n");

        return 0;

    } else {

        ortd_rt_stack_prefault();

        struct sched_param param;

        param.sched_priority = priority;
        if(sched_setscheduler(0, SCHED_OTHER, &param) == -1) {
            perror("sched_setscheduler failed");
            return -1;
        }

        fprintf(stderr, "initialized a non real-time thread\n");

        return 0;
    }
}

void ortd_thread_exit_handler(int sig)
{
    pthread_exit(0);
}

void ortd_thread_install_signal_handler() {

    struct sigaction actions;
    memset(&actions, 0, sizeof(actions));
    sigemptyset(&actions.sa_mask);
    actions.sa_flags = 0;
    actions.sa_handler = ortd_thread_exit_handler;
    int rc = sigaction(SIGUSR1,&actions,NULL);

}


//
// exit on signal
//

// global var
static volatile int end = 0;

void endme(int n)
{
    fprintf(stderr, "Received signal to terminate\n");
    end = 1;    
}



int main () {
    simulation system_instance;
    simulation::Inputs inputs;
    simulation::Outputs outputs;

    
    // set const inputs
    inputs.input1 = 1.0;

    
    // reset system
    system_instance.step( outputs, inputs, false, false, true );
    
    // set signal handlers
    signal(SIGINT, endme);
    signal(SIGKILL, endme);

    //
    // set scheduling priority and enter real-time
    //
    // in case of ORTD_RT_REALTIMETASK: 1-99 as described in 'man sched_setscheduler'
    // in case of ORTD_RT_NORMALTASK this is the nice-value (higher value means less priority)
    //

    int flags    = ORTD_RT_REALTIMETASK;
    int priority = 0; 

    if ( ortd_rt_change_priority(flags, priority) < 0 ) {

        fprintf(stderr, "WARNING: Cannot set FIFO real-time scheduling priority\n");

        if ( ortd_rt_change_priority(ORTD_RT_NORMALTASK, priority) < 0 ) {
            exit(1);
        }

    }

    // variables for execution time t and the interval
    struct timespec t, interval;

    // measure current time
    clock_gettime(CLOCK_MONOTONIC,&t);

    // enter loop
    while (!end) {
        
        // calculate outputs
        system_instance.step( outputs, inputs, true, false, false );
        
        // update states
        system_instance.step( outputs, inputs, false, true, false );
    
        // print outputs
        printf("%f %f\n", outputs.__ORTD_CONTROL_delta_time__, outputs.output);


        double T_pause = outputs.__ORTD_CONTROL_delta_time__;

        // calculate the time instant for the next execution
        interval.tv_sec =  0L;
        interval.tv_nsec = (long)1e9* (T_pause);
        tsnorm(&interval);

        t.tv_sec+=interval.tv_sec;
        t.tv_nsec+=interval.tv_nsec;
        tsnorm(&t);

        // sleep
        clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, &t, NULL);        
    } 
    
    return 0;
}
        
        