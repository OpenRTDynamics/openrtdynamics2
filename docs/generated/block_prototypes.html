<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>openrtdynamics2.block_prototypes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openrtdynamics2.block_prototypes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .libdyn import Simulation
from . import datatypes as dt

from .system_context import get_simulation_context
from . import block_interface as bi
from .signal_interface import *
from . import code_generation_helper as cgh

# TODO: rename to atomic_blocks

#
# Subsystem prototypes
#

class GenericSubsystem(bi.BlockPrototype):
    &#34;&#34;&#34;
        Include a sub-system by passing a manifest

        - sim - the simulation this block is embedded into

        parameters required only in case the subsystem is already defined (e.g. loaded from a library):

        - manifest           - the manifest of the subsystem to include (optional, might be handed over by init())
        - inputSignals       - the inputs to the subsystem 
        - N_outputs          - prepare a number of nOutputs (optional in case a manifest is given)
        - embedded_subsystem - the system to embed (optional in case a manifest to an already compiled subsystem is given, NOT IMPLEMENTED)

        Note: the number of outputs must be defined either by N_outputs or by a manifest

    &#34;&#34;&#34;
    def __init__(self, sim : Simulation = None, manifest=None, inputSignals=None, N_outputs = None, embedded_subsystem=None ):

        self.manifest = manifest
        self.inputSignals = inputSignals
        self.sim = sim
        self.Noutputs = N_outputs
        self._embedded_subsystem = embedded_subsystem

        if manifest is not None:
            if N_outputs is None:
                self.Noutputs = self.manifest.number_of_default_ouputs
            else:
                raise BaseException(&#34;N_outputs and a manifest specified at the same time&#34;)

        # output signals that were created by sth. ourside of this prototype
        # and that need to be connected to the actual outputs when init() is called.
        self.anonymous_output_signals = None

        # optional (in case this block is in charge of putting the code for the subsystem)
        self.compileResult = None

        # init super class
        bi.BlockPrototype.__init__(self, self.sim, N_outputs = self.Noutputs)

        # Note: the inputSignals are not defined when subsystems are pre-defined in the code
        # but are automatically placed and connected by the compiler during compilation

        # check if it is already possible to init this prototype
        # (in case all requred information is available)
        if inputSignals is not None and manifest is not None:
            self.init()

        # configure datatype inheritance for the outputs signals
        for i in range(0, len( embedded_subsystem.primary_outputs )):

            output_signal_of_embedding_block = self.outputs[i]
            output_signal_of_subsystem = embedded_subsystem.primary_outputs[i]

            output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

    @property
    def embedded_subsystem(self):
        &#34;&#34;&#34;
            Return the system that is embedded (in case it was provided, returns None otherwise)
        &#34;&#34;&#34;

        return self._embedded_subsystem

    def set_anonymous_output_signal_to_connect(self, anonymous_output_signals):
        &#34;&#34;&#34;
            store a list of anonymous signals to connect to the outputs of the subsystems
            after running the post_compile_callback
        &#34;&#34;&#34;
        # List of raw signals 
        self.anonymous_output_signals = anonymous_output_signals

    def compile_callback_all_subsystems_compiled(self):

        embedded_system = self._embedded_subsystem
        #
        # continue init as now all subsystems are compiled and the compile results and the manifest of
        # the system to compile is available.
        #
        self.init(embedded_system.compilationResult.manifest, embedded_system.compilationResult, embedded_system.compilationResult.inputSignals)

    # post_compile_callback (called after the subsystem to embedd was compiled)
    def init(self, manifest, compileResult, inputSignals):
        &#34;&#34;&#34;
            This is a second phase initialization of this subsystem block 
            (to be called by compile_callback_all_subsystems_compiled())

            This function shall be called when the subsystem to embedd is compiled
            after the instance of &#39;GenericSubsystem&#39; is created. This way, it is possible
            to add blocks embeddeding sub-systems without haveing these subsystems to be
            already compiled.

            Optionally, the system this block belongs to can be set.

            manifest       - the system manifest of the subsystem to embedd
            compileResults - the compile results of the subsystem to embedd
            inputSignals   - input signals to the subsystem to embedd (links comming from an upper-level subsystem)

        &#34;&#34;&#34;        

        #
        #    set the manifest of the subsystem
        #
        if self.manifest is not None:
            raise BaseException(&#34;cannot call this function as the subsystem&#39;s manifest was already defined in the constructor.&#34;)

        self.manifest = manifest

        #
        #    Set the compilation result of the embedded system (if available)
        #
        self.compileResult = compileResult

        #
        #    connect the inputs (coming from the upper-level system)
        #

        if self.inputSignals is not None:
            raise BaseException(&#34;The subsystem&#39;s inputSignals were already specified in the constructor.&#34;)

        self.inputSignals = inputSignals



        def collectDependingSignals(signals, manifestFunctionInputs):
            # collect all depending input signals (that are needed to calculate the output) in a list
            # MOVE TO A FUNCTION. MAYBE MOVE TO MANIFEST.PY
            dependingInputs = []
            for i in range( len(manifestFunctionInputs[&#39;names&#39;]) ):

                dependingInput_name = manifestFunctionInputs[&#39;names&#39;][i]
                dependingInput_type = manifestFunctionInputs[&#39;types&#39;][i]
                dependingInput_cpptype = manifestFunctionInputs[&#39;cpptypes&#39;][i]

                # TODO: CHECK FOR FAILING LOOKUP
                signal = signals[ dependingInput_name ]

                # check datatype
                if not signal.getDatatype().cppDataType == dependingInput_cpptype:
                    raise BaseException(&#39;datatype does not match the one specified in the manifest. (&#39; + (dependingInput_cpptype) + &#39; is required in the manifest)&#39; )

                # append signal
                dependingInputs.append( signal ) 

            return dependingInputs



        # verify the number of outputs of the embedded system
        number_of_outputs_as_described_by_manifest = self.manifest.number_of_default_ouputs

        if not number_of_outputs_as_described_by_manifest == self.Noutputs:
            BaseException(&#34;missmatch in the number of outputs&#34;)

        # get the output datatypes of the embedded system
        self.outputTypes = self.manifest.io_outputs[&#39;calculate_output&#39;][&#39;types&#39;]  


        if self.compileResult is None:
            # collect all depending input signals (that are needed to calculate the output) in a list
            self.inputsToCalculateOutputs = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;calculate_output&#39;] )

            # collect all inputs required to perform the state update
            self.inputsToUpdateStates = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;state_update&#39;] )

        else:
            # use the available compile results to get the I/O signals
            # in this case, self.inputSignals shall be a list of signals. The order
            # shall match the signal order in self.compileResults.inputSignals

            self.inputsToCalculateOutputs = self.compileResult.simulationInputSignalsToCalculateOutputs
            self.inputsToUpdateStates = self.compileResult.simulationInputSignalsToUpdateStates

            

        # combine all inputs to a list
        self.allInputs = list()

        self.allInputs.extend( self.inputsToCalculateOutputs )
        self.allInputs.extend( self.inputsToUpdateStates )

        #
        # now initialize the propotype
        #

        # define the inputs
        self.update_input_config( self.allInputs )

        # connect the outputs signals
        if self.anonymous_output_signals is not None:

            print(&#34; -- Nesting block: connecting anonymous signals -- &#34;)

            Ns = len(self.outputSignals)

            if not Ns == len(  self.anonymous_output_signals ):
                raise BaseException(&#34; missmatch in the number of output signals&#34;)

            for i in range(0,Ns):
                
                s_ananon = self.anonymous_output_signals[i]
                s_source = self.outputSignals[i]

                print(&#34;connecting the output &#34; + s_ananon.toStr() + &#34; of the embedding block&#34;)
                s_ananon.setequal( s_source )



        # for code generation
        self.instanceVarname = self.getUniqueVarnamePrefix() + &#39;_subsystem_&#39; + self.manifest.API_name


    def config_request_define_output_types(self, inputTypes):

        # the datatypes are fixed in the manifest 
        return self.outputTypes        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):

        # NOTE: This is a simplified veriant so far.. no dependence on the given &#39;outputSignal&#39;
        #       (Every output depends on every signal in self.inputsToCalculateOutputs)

        # TODO: 6.10.19 implement this in a more granular way.
        # also use self.compileResults to get those information

        return self.inputsToCalculateOutputs

    def config_request_define_state_update_input_dependencies(self, outputSignal):
 
        # return a list of input signals that are required to update the states
        return self.inputsToUpdateStates



    def codegen_addToNamespace(self, language):
        lines = &#39;&#39;

        # putting code for subsystems is performed using execution commands

        return lines

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            lines = &#39;// instance of &#39; + self.manifest.API_name + &#39;\n&#39;
            lines += self.manifest.API_name + &#39; &#39; + self.instanceVarname + &#39;;\n&#39;

            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:
            return self.instanceVarname + &#39;.&#39; + self.manifest.getAPIFunctionName(&#39;reset&#39;) +  &#39;();\n&#39;


    def generate_code_init(self, language):
        pass


    def generate_code_destruct(self, language):
        pass


    # helper fn to build code
    def generate_code_call_OutputFunction(self, instanceVarname, manifest, language):
        return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;calculate_output&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.outputs + self.inputsToCalculateOutputs) + &#39;);\n&#39;

    # helper fn to build code
    def generate_code_call_UpdateFunction(self, instanceVarname, manifest, language):
        return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;state_update&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.inputsToUpdateStates) + &#39;);\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = &#39;&#39;
            
            #
            # TODO: 2.5.2020: concept: how to compute only the nescessary signals?
            #

            for s in self.outputs:
                lines += cgh.define_variable_line( s ) 

                if s not in signals:
                    lines += &#39;// NOTE: unused output signal&#39; + s.name + &#39;\n&#39;
                else:
                    lines += &#39;&#39;                

            lines += self.generate_code_call_OutputFunction(self.instanceVarname, self.manifest, language)

        return lines

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            # input to this call are the signals in self.inputsToUpdateStates
            return self.generate_code_call_UpdateFunction(self.instanceVarname, self.manifest, language)

def generic_subsystem( manifest, inputSignals : List[SignalUserTemplate] ):
    return wrap_signal_list( GenericSubsystem(get_simulation_context(), manifest, unwrap_hash(inputSignals) ).outputSignals )



















class SingleSubsystemEmbedder(bi.BlockPrototype):
    &#34;&#34;&#34;
        Prototype for a block that includes one sub-system
          (this is class to be derived, e.g. by XX, XX)

        - control_inputs                        - inputs used to control the execution (e.g. the condition for if)
        - subsystem_prototype                   - the prototypes the subsystem (of type GenericSubsystem)
        - reference_outputs                     - output signals of the reference subsystem from which the output datatypes are inherited
        - number_of_control_outputs             - the number of outputs of the subsystem used to control execution

        - helper function for code generation -

        - XX

                         
                        +--------------------------------------------------+
                        | SingleSubsystemEmbedder                          |
                        |                       +-------------+            |
        normal input 1  |                       |             |            |  normal output 1
                     +-------------------------&gt;+             +---------------&gt;
                        |                       |   embeded   |            |
        normal input 2  |                       |             |            |  normal output 2
                     +-------------------------&gt;+             +---------------&gt;
                        |                       |  subsystem  |            |
                        |        control status |             | control    |
                        |            +---------&gt;+             +-----+      |
                        |            |          |             | output     |
                        |            |          +-------------+     |      |
                        |            |                              |      |
                        |     +------+------+                       |      |
        control input   |     |  execution  |                       |      |
                     +-------&gt;+  control of +&lt;----------------------+      |
                        |     |  subsystem  |                              |
                        |     +-------------+                              |
                        |                                                  |
                        +--------------------------------------------------+

        Picture drawn by http://asciiflow.com/



        lists of output signals
        -----------------------

        self.outputs                                           - all outputs of the embeding block
        self._subsystem_prototype.outputs                      - all outputs of the subsystem that are initialily present
        self._subsystem_prototype.compileResult.outputSignals  - all outputs of the subsystem that are present after compilation
        signals (parameter for generate_code_output_list)      - outputs out of self.outputs that need to be computed

    &#34;&#34;&#34;
    def __init__(self, sim : Simulation, control_inputs : List [Signal], subsystem_prototype : GenericSubsystem, number_of_control_outputs : int = 0 ):

        # the prototypes of the subsystem
        self._subsystem_prototype = subsystem_prototype
        
        # analyze the default subsystem (the first) to get the output datatypes to use
        reference_subsystem = self._subsystem_prototype

        # the number of outputs besides the subsystems outputs
        self._number_of_control_outputs = number_of_control_outputs

        self._total_number_of_subsystem_outputs = len(reference_subsystem.outputs)
        self._number_of_normal_outputs = len(self._subsystem_prototype.outputs) - number_of_control_outputs

        if self._number_of_normal_outputs &lt; 0:
            raise BaseException(&#34;The number of control outputs is higher than the toal number of outputs provided by the subsystem.&#34;)

        self._number_of_outputs_of_all_nested_systems = len(reference_subsystem.outputs)



        # now call the constructor for block prototypes and make input and output signals available
        bi.BlockPrototype.__init__(self, sim=sim, inputSignals=None, N_outputs = self._number_of_normal_outputs )



        # control inputs that are used to control how the subsystems are handled
        self._control_inputs = control_inputs 


        # a list of all inputs including self._list_of_all_subsystem_inputs and self._control_inputs
        # will be filled in on compile_callback_all_subsystems_compiled()
        self._list_of_all_inputs = None


        # output sigal mapping: map each output of SingleSubsystemEmbedder to an output of the subsystem
        self._output_signal_mapping = {} # (TODO: extend/add to MultiSubsystemEmbedder)

        # inherit output datatypes of this block from the embeded subsystem
        for i in range(0, self._number_of_normal_outputs ):

            # fill in mapping table
            self._output_signal_mapping[ self.outputs[i] ] = self._subsystem_prototype.outputs[i]

            output_signal_of_embedding_block = self.outputs[i]
            output_signal_of_subsystem = self._subsystem_prototype.outputs[i] # reference_outputs[i]
            output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

            #output_signal_of_embedding_block.set_data_link( output_signal_of_subsystem )

        # build a list of control signals (TODO: add to MultiSubsystemEmbedder)
        self._control_signals_from_embeded_system = []
        
        # iterate over the control outputs of the embedded subsystem
        for i in range(self._number_of_normal_outputs, self._number_of_normal_outputs + self._number_of_control_outputs ):
            self._control_signals_from_embeded_system.append( self._subsystem_prototype.outputs[i] )


    @property
    def additional_outputs(self):
        return self.outputs[ self._number_of_normal_outputs: ]

    @property
    def normal_outouts(self):
        return self.outputs[ 0:self._number_of_normal_outputs ]


    def compile_callback_all_subsystems_compiled(self):

        # Get all input signals required by the subsystem
        set_of_all_inputs = set()
        set_of_all_inputs.update( self._subsystem_prototype.inputs )

        # add the control inputs
        set_of_all_inputs.update( self._control_inputs )

        self._list_of_all_inputs = list(set_of_all_inputs)

    def compile_callback_all_datatypes_defined(self):
        pass


    def config_request_define_feedforward_input_dependencies(self, outputSignal):

        # NOTE: This is a simplified veriant so far..
        #       Every output depends on every signal

        return self._list_of_all_inputs
        

    def config_request_define_state_update_input_dependencies(self, outputSignal):
 
        # NOTE: This is a simplified veriant so far..
        #       The update depends on every signal

        return self._list_of_all_inputs


    def helper_get_output_signal_mapping_to_subsystem(self, signals_to_calculate):

        mapped_subsystem_output_signals = []
        for s in signals_to_calculate:
            mapped_subsystem_output_signals.append( self._output_signal_mapping[s] )

        return mapped_subsystem_output_signals
    
    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:

            lines = &#39;&#39;
            lines += self._subsystem_prototype.generate_code_defStates(language)

            return lines


    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:


            lines = &#39;// reset state of subsystem embeded by &#39; + self.name + &#39;\n&#39;
            lines += self._subsystem_prototype.generate_code_reset(language)

            return lines










class TruggeredSubsystem(SingleSubsystemEmbedder):
    &#34;&#34;&#34;
        Include a triggered sub-system

        Optional:

            prevent_output_computation = True: 
                The subsystems outputs are only computed when triggered. Please note that the outputs
                of the subsystem are uninitialized until the subsystem is triggered for the first time.

    &#34;&#34;&#34;


    def __init__(self, sim : Simulation, control_input : Signal, subsystem_prototype : GenericSubsystem,  prevent_output_computation = False ):
        
        self._control_input = control_input
        self.prevent_output_computation = prevent_output_computation

        SingleSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[control_input], 
                                        subsystem_prototype=subsystem_prototype, 
                                        number_of_control_outputs=0 )



    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            
            # code_compute_output = self._subsystem_prototype.generate_code_output_list(language, self._subsystem_prototype.outputs)




            code_compute_output = cgh.embed_subsystem(language, system_prototype=self._subsystem_prototype, ouput_signals_name=cgh.signal_list_to_name_list(signals), calculate_outputs = True, update_states = False )


            if self.prevent_output_computation:

                # the subsystems outputs are only computed when triggered
                lines += cgh.generate_if_else(language, 
                    condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input, 1 ) ], 
                    action_list=[ code_compute_output ])

                # TODO: copy output signals and only the ones requested

            else:
                # the subsystems outputs are always computed
                lines += code_compute_output


        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            code_compute_state_update = self._subsystem_prototype.generate_code_update(language)

            # the subsystems update is on only performed when triggered
            lines += cgh.generate_if_else(language, 
                condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
                action_list=[ code_compute_state_update ])

        return lines






class LoopUntilSubsystem(SingleSubsystemEmbedder):
    &#34;&#34;&#34;
        Embed a loop sub-system

    &#34;&#34;&#34;

    def __init__(self, sim : Simulation, max_iteriations : int, 
                    subsystem_prototype : GenericSubsystem, 
                    until_signal : Signal = None, yield_signal : Signal = None ):
        
        self.max_iter = max_iteriations
        self._until_signal = until_signal
        self._yield_signal = yield_signal

        number_of_control_outputs = 0
        if self._until_signal is not None:
            number_of_control_outputs += 1

        if self._yield_signal is not None:
            number_of_control_outputs += 1


        SingleSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[],   # TODO: add N_iter signal here 
                                        subsystem_prototype=subsystem_prototype, 
                                        number_of_control_outputs=number_of_control_outputs )


    # def config_request_define_state_update_input_dependencies(self, outputSignal):
 
    #     return [self._until_signal]

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            # output signal mapping lookup
            ouput_signals_of_subsystem = self.helper_get_output_signal_mapping_to_subsystem(signals_to_calculate=signals)


            ouput_signals_names = cgh.signal_list_to_name_list(signals)
            ouput_signal_names_of_subsystem = cgh.signal_list_to_name_list(ouput_signals_of_subsystem)
            

            loop_break_condition = []

            control_output_index = 0

            if self._until_signal is not None:
                # define tmp-var for self._until_signal instead of a block output
                lines += cgh.defineVariables( [self._until_signal] )

                # add list of signals to assign
                ouput_signals_names.append( self._until_signal.name )
                ouput_signal_names_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index].name )
            
                # add break condition
                loop_break_condition.append( self._until_signal.name )

                control_output_index += 1


            if self._yield_signal is not None:
                # define tmp-var for self._yield_signal instead of a block output
                lines += cgh.defineVariables( [self._yield_signal] )

                # add list of signals to assign
                ouput_signals_names.append( self._yield_signal.name )
                ouput_signal_names_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index].name )

                # add break condition
                loop_break_condition.append( self._yield_signal.name )

                control_output_index += 1


            calc_outputs = cgh.embed_subsystem2(language, 
                        system_prototype=self._subsystem_prototype, 
                        ouput_signals_name=ouput_signals_names, 
                        ouput_signal_names_of_subsystem=ouput_signal_names_of_subsystem,
                        calculate_outputs = True, update_states = False )

            update_states = cgh.embed_subsystem2(language, 
                        system_prototype=self._subsystem_prototype, 
                        calculate_outputs = False, update_states = True )

            code = &#39;&#39;
            code +=  calc_outputs 
            code += update_states

            if self._yield_signal is not None:
                code += cgh.generate_loop_break(language, condition=self._yield_signal.name)

            if self._until_signal is not None:
                code_reset_subsystem = self._subsystem_prototype.generate_code_reset(language)
                code += cgh.generate_loop_break(language, condition=self._until_signal.name, code_before_break=code_reset_subsystem)

            lines += cgh.generate_loop( language, max_iterations=str(self.max_iter), code_to_exec=code  )

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            if self._until_signal is not None:
                pass    
                #lines += self._subsystem_prototype.generate_code_reset(language)


        return lines























class MultiSubsystemEmbedder(bi.BlockPrototype):
    &#34;&#34;&#34;
        Prototype for a block that includes multiple sub-systems whose outputs are joint in a switching manner
          (this is class to be derived, e.g. by StatemachineSwichSubsystems, SwichSubsystems)

        - control_inputs                        - inputs used to control the switching strategy
        - subsystem_prototypes                  - a list of the prototypes of all subsystems (of type GenericSubsystem)
        - switch_reference_outputs              - output signals of the reference subsystem from which the output datatypes are inherited
        - number_of_control_outputs             - the number of outputs of the subsystems used to control the execution

        - helper function for code generation -

        - self.generate_switch(), generate_reset()
    &#34;&#34;&#34;
    def __init__(self, sim : Simulation, control_inputs : List [Signal], subsystem_prototypes : List [GenericSubsystem], switch_reference_outputs : List [Signal], number_of_control_outputs : int = 0 ):

        # a list of the prototypes of all subsystems
        self._subsystem_prototypes = subsystem_prototypes
        
        # analyze the default subsystem (the first) to get the output datatypes to use
        reference_subsystem = self._subsystem_prototypes[0]

        # the number of outputs besides the subsystems outputs
        self._number_of_control_outputs = number_of_control_outputs

        self._total_number_of_subsystem_outputs = len(reference_subsystem.outputs)
        self._number_of_switched_outputs = len(switch_reference_outputs)

        if self._number_of_switched_outputs + number_of_control_outputs != self._total_number_of_subsystem_outputs:
            raise BaseException(&#34;given number of total subsystem outputs does not match&#34;)

        self._number_of_outputs_of_all_nested_systems = len(reference_subsystem.outputs)

        # assertion
        for subsystem_prototype in self._subsystem_prototypes:
            if not len(subsystem_prototype.outputs) == self._total_number_of_subsystem_outputs:
                raise BaseException(&#34;all subsystems must have the same number of outputs&#34;)


        # now call the constructor for block prototypes and make input and output signals available
        bi.BlockPrototype.__init__(self, sim=sim, inputSignals=None, N_outputs = self._total_number_of_subsystem_outputs )



        # control inputs that are used to control how the subsystems are handled
        self._control_inputs = control_inputs 

        # a list of all inputs used by all subsystems
        self._list_of_all_subsystem_inputs = None

        # a list of all inputs including self._list_of_all_subsystem_inputs and self._control_inputs
        # will be filled in on compile_callback_all_subsystems_compiled()
        self._list_of_all_inputs = None

        # inherit output datatypes of the reference subsystem
        for i in range(0, self._number_of_switched_outputs ):

            output_signal_of_embedding_block = self.outputs[i]
            output_signal_of_subsystem = switch_reference_outputs[i]
            output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

        # NOTE: datatypes for control outputs are untouched

    @property
    def additional_outputs(self):
        return self.outputs[ self._number_of_switched_outputs: ]

    @property
    def subsystem_switch_outouts(self):
        return self.outputs[ 0:self._number_of_switched_outputs ]


    def compile_callback_all_subsystems_compiled(self):

        # Get all input signals required by the subsystems and avoid duplicates. 
        # Go through each subsystem in self._subsystem_prototypes and collect all input signals
        # in a set.
        set_of_all_inputs = set()

        for subsystem_prototype in self._subsystem_prototypes:
            set_of_all_inputs.update( subsystem_prototype.inputs )

        self._list_of_all_subsystem_inputs = list( set_of_all_inputs )

        # add additional inputs
        set_of_all_inputs.update( self._control_inputs )

        self._list_of_all_inputs = list(set_of_all_inputs)
            


    def compile_callback_all_datatypes_defined(self):
        pass



    def config_request_define_feedforward_input_dependencies(self, outputSignal):

        # NOTE: This is a simplified veriant so far..
        #       Every output depends on every signal

        return self._list_of_all_inputs
        

    def config_request_define_state_update_input_dependencies(self, outputSignal):
 
        # NOTE: This is a simplified veriant so far..
        #       The update depends on every signal

        return self._list_of_all_inputs



    # for code_gen
    def generate_switch( self, language, switch_control_signal_name, switch_ouput_signals_name=None, calculate_outputs = True, update_states = False, additional_outputs_names=None ):
        &#34;&#34;&#34;
            code generation helper to embed multiple subsystems and a switch for the outputs
        &#34;&#34;&#34;

        lines = &#39;&#39;

        action_list = []
        condition_list = []

        subsystem_counter = 0
        for system_prototype in self._subsystem_prototypes:

            if calculate_outputs:
                # combine all output names to one list: normal subsystem outputs and control outputs
                ouput_signals_name = []
                ouput_signals_name.extend( switch_ouput_signals_name )
                ouput_signals_name.extend( additional_outputs_names )

                # call each subsystem embedder to generate its code
                code_calculate_outputs = cgh.embed_subsystem( language, system_prototype, ouput_signals_name=ouput_signals_name)
            else:
                code_calculate_outputs = &#39;&#39; # no operation


            if update_states:
                # call each subsystem embedder to generate its update code
                code_update_states = cgh.embed_subsystem( language, system_prototype, calculate_outputs=False, update_states=True)
            else:
                code_update_states = &#39;&#39; # no operation

            action_list.append( code_calculate_outputs + code_update_states )

            # generate conditions when to execute the respective subsystem 
            condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

            subsystem_counter += 1

        # combine conditions and their repective actions
        lines += cgh.generate_if_else(language, condition_list, action_list)

        return lines


    
    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:

            # implement state definition for each subsystem
            lines = &#39;&#39;
            for system_prototype in self._subsystem_prototypes:
                lines += system_prototype.generate_code_defStates(language)

            return lines

    def generate_reset(self, language, system_index):
        &#34;&#34;&#34;
            helper fn for code generation
        &#34;&#34;&#34;

        system_to_reset = self._subsystem_prototypes[ system_index ]

        lines = system_to_reset.generate_code_reset(language)

        return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            # reset all subsystems
            lines = &#39;// reset state of all subsystems in multisubsystem &#39; + self.name + &#39;\n&#39;
            for system_prototype in self._subsystem_prototypes:
                lines += system_prototype.generate_code_reset(language)

            return lines



class SwichSubsystems(MultiSubsystemEmbedder):
    &#34;&#34;&#34;
        A system that includes multiple subsystems and a control input to switch in-between
        The outputs of the currently acrive subsystem are forwarded.
    &#34;&#34;&#34;

    def __init__(self, sim : Simulation, control_input : Signal, subsystem_prototypes : List [GenericSubsystem], reference_outputs : List [Signal] ):
        
        self._control_input = control_input

        MultiSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[control_input], 
                                        subsystem_prototypes=subsystem_prototypes, 
                                        switch_reference_outputs=reference_outputs,
                                        number_of_control_outputs=0 )


    def generate_code_defStates(self, language):
        lines = MultiSubsystemEmbedder.generate_code_defStates(self, language)
        lines += &#39;&#39; # add something
        
        return lines


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            
            # the method self.generate_switch is provided by MultiSubsystemEmbedder 
            lines += self.generate_switch( language=language, 
                                            switch_control_signal_name=self._control_input.name,
                                            switch_ouput_signals_name= cgh.signal_list_to_name_list(signals),
                                             calculate_outputs = True, update_states = False )

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            lines += self.generate_switch( language=language, 
                                                    switch_control_signal_name=self._control_input.name,
                                                     calculate_outputs = False, update_states = True )

        return lines







class StatemachineSwichSubsystems(MultiSubsystemEmbedder):
    &#34;&#34;&#34;

    &#34;&#34;&#34;

    def __init__(self, sim : Simulation, subsystem_prototypes : List [GenericSubsystem], reference_outputs : List [Signal] ):
        
        MultiSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[], 
                                        subsystem_prototypes=subsystem_prototypes, 
                                        switch_reference_outputs=reference_outputs,
                                        number_of_control_outputs = 1 )

        # how to add more outputs?
        self.state_output.setDatatype( dt.DataTypeInt32(1) )

        # this output signals must be compted in any way
        # also in case it is not used by other blocks
        sim.add_signal_mandatory_to_compute( self.state_output )


    @property
    def state_output(self):
        return self.additional_outputs[0]


    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            lines = self._state_memory + &#39; = 0;\n&#39; # add something

            lines += MultiSubsystemEmbedder.generate_code_reset(self, language)

            return lines


    def generate_code_defStates(self, language):
        lines = MultiSubsystemEmbedder.generate_code_defStates(self, language)

        self._state_memory = self.getUniqueVarnamePrefix() + &#39;state&#39;
        lines += &#39;int &#39; + self._state_memory + &#39; {0};&#39;
        
        return lines


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            # do not compute all swich outputs, just the ones requested by &#39;signals&#39; 
            outputs_to_compute = []
            for s in signals:
                if s in self.subsystem_switch_outouts:
                    outputs_to_compute.append( s )


            # lines += cgh.defineVariables( signals ) + &#39;\n&#39;
            lines += self.generate_switch( language=language, 
                                            switch_control_signal_name=  self._state_memory ,
                                            switch_ouput_signals_name=cgh.signal_list_to_name_list(outputs_to_compute),
                                            additional_outputs_names=[self.state_output.name] )

            # lines += self.state_output.name + &#39; = &#39; + self._state_memory_delayed + &#39;;\n&#39;

        return lines


    # code_gen helper
    def generate_switch_to_reset_leaving_subsystem( self, language, switch_control_signal_name ):

        lines = &#39;&#39;

        action_list = []
        condition_list = []

        subsystem_counter = 0
        for system_prototype in self._subsystem_prototypes:

            code_reset_states = MultiSubsystemEmbedder.generate_reset( self, language, system_index=subsystem_counter ) 

            action_list.append(  code_reset_states )

            # generate conditions when to execute the respective subsystem 
            condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

            subsystem_counter += 1

        # combine conditions and their repective actions
        lines += cgh.generate_if_else(language, condition_list, action_list)

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            lines += self.generate_switch( language=language, 
                                                    switch_control_signal_name=self._state_memory,
                                                    calculate_outputs=False, 
                                                    update_states=True )


            # get the signal issued by the currently active subsystem that describes state chanhe requests
            state_control_signal_from_subsystems = self.state_output

            # reset current subsystem in case a state transition is requested
            lines_reset_subsystem = self.generate_switch_to_reset_leaving_subsystem(language, self._state_memory )
            lines += cgh.generate_if_else(language, condition_list=[ state_control_signal_from_subsystems.name + &#39; &gt;= 0 &#39; ], action_list=[lines_reset_subsystem])

            # transition to the new state
            lines += self._state_memory + &#39; = (&#39; + state_control_signal_from_subsystems.name + &#39; &gt;= 0 ) ? (&#39;+ state_control_signal_from_subsystems.name + &#39;) : (&#39; + self._state_memory + &#39;);\n&#39;
            
        return lines













#
# Sources
#

class Const(bi.StaticSource_To1):
    def __init__(self, sim : Simulation, constant, datatype ):

        self.constant = constant

        # call super
        bi.StaticSource_To1.__init__(self, sim, datatype)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str( self.constant ) + &#39;;\n&#39;

def const(constant, datatype ):
    return wrap_signal( Const(get_simulation_context(), constant, datatype).outputs[0] )




#
# Multiply by constant
#

class Gain(bi.StaticFn_1To1):
    def __init__(self, sim : Simulation, u : Signal, factor : float ):

        self._factor = factor

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._factor) + &#39; * &#39; + self.inputs[0].name +  &#39;;\n&#39;

def gain(u : SignalUserTemplate, gain : float ):
    return wrap_signal( Gain(get_simulation_context(), u.unwrap, gain).outputs[0] )


#
# Cast to given datatype
#

class ConvertDatatype(bi.StaticFn_1To1):
    def __init__(self, sim : Simulation, u : Signal, target_type : dt.DataType ):

        self._target_type = target_type

        bi.StaticFn_1To1.__init__(self, sim, u)

    def config_request_define_output_types(self, inputTypes):
        return [ self._target_type ]  

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            # TODO: only = is used and the c++ compiler decides how to convert...
            return signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;

def convert(u : SignalUserTemplate, target_type : dt.DataType ):
    return wrap_signal( ConvertDatatype(get_simulation_context(), u.unwrap, target_type).outputs[0] )



#
# Basic operators
#

class Add(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, inputSignals : List[Signal], factors : List[float] ):

        # feasibility checks
        if len(inputSignals) != len(factors):
            raise(&#34;len(inp_list) must be equal to len(factors)&#34;)

        self.factors = factors
        bi.StaticFn_NTo1.__init__(self, sim, inputSignals)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            strs = []
            i = 0
            for s in self.inputSignals:
                strs.append(  str(self.factors[i]) + &#39; * &#39; + s.name )
                i = i + 1

            sumline = &#39; + &#39;.join( strs )
            lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

            return lines


def add(inputSignals : List[SignalUserTemplate], factors : List[float]):
    return wrap_signal( Add(get_simulation_context(), unwrap_list( inputSignals ), factors).outputs[0] )


class Operator1(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, inputSignals : List[Signal], operator : str ):

        self.operator = operator
        bi.StaticFn_NTo1.__init__(self, sim, inputSignals)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            strs = []
            i = 0
            for s in self.inputSignals:
                strs.append(  str(  s.name ) )
                i = i + 1

            sumline = (&#39; &#39; + self.operator + &#39; &#39;).join( strs )
            lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

            return lines


def operator1(inputSignals : List[SignalUserTemplate], operator : str ):
    return wrap_signal( Operator1(get_simulation_context(), unwrap_list( inputSignals ), operator).outputs[0] )


#
# logic operators
#

def logic_and(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        logical and

        u1 &amp;&amp; u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list([u1,u2]), operator=&#39; &amp;&amp; &#39;).outputs[0] )

def logic_or(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        logical or
    
        u1 || u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; || &#39;).outputs[0] )


def logic_xor(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        exclusive logical or (xor)
    
        u1 ^ u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; ^ &#39;).outputs[0] )


def bitwise_and(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        bitwise and

        u1 &amp; u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list([u1,u2]), operator=&#39; &amp; &#39;).outputs[0] )

def bitwise_or(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        bitwise or
    
        u1 | u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; | &#39;).outputs[0] )


def bitwise_shift_left(u : SignalUserTemplate, shift : SignalUserTemplate):
    &#34;&#34;&#34;
        logical shift left
    
        u &lt;&lt; shift
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u,shift] ), operator=&#39; &lt;&lt; &#39;).outputs[0] )


def bitwise_shift_right(u : SignalUserTemplate, shift : SignalUserTemplate):
    &#34;&#34;&#34;
        logical shift left
    
        u &gt;&gt; shift
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u,shift] ), operator=&#39; &gt;&gt; &#39;).outputs[0] )






















class ComparisionOperator(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, left : Signal, right : Signal, operator : str ):

        self.operator = operator

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [left, right])

    def config_request_define_output_types(self, inputTypes):

        # return a proposal for an output type. 
        return [ dt.DataTypeBoolean(1) ]

    # def generate_code_output(self, language, signal : Signal):
    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = signals[0].name + &#39; = &#39; + self.inputSignals[0].name + &#39; &#39; + self.operator + &#39; &#39; + self.inputSignals[1].name + &#39;;\n&#39;
            return lines


def comparison(left : SignalUserTemplate, right : SignalUserTemplate, operator : str ):
    return wrap_signal( ComparisionOperator(get_simulation_context(), left.unwrap, right.unwrap, operator).outputs[0] )














class SwitchNto1(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, state : Signal, inputs : List [Signal] ):

        self.inputs = inputs
        self.state = state

        inputSignals = [state]
        inputSignals.extend(inputs)

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals )

    def config_request_define_output_types(self, inputTypes):

        # check weather the trigger input is int32
        if inputTypes[0] is not None:
            if dt.DataTypeInt32(1).isEqualTo( inputTypes[0] ) == 0:
                raise BaseException(&#39;state input must be of type Int32&#39;)  

        # determine a guess for the output datatype
        # check if all given datatypes are equal
        autoDatatype = autoDatatype_Nto1(self.outputs[0].getDatatype(), inputTypes[1:-1] )

        return [ autoDatatype ]

    #def generate_code_output(self, language, signal : Signal):
    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = &#39;\n// switch &#39; + str(len(self.inputs)) + &#39; inputs --&gt; &#39; + self.state.name + &#39;\n&#39;
            i = 1
            for ip in self.inputs:
                if i == 1:
                    lines += &#39;if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;
                else:
                    lines += &#39;else if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;

                lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + ip.name + &#39;;\n&#39;
                lines += &#39;} &#39;

                i += 1

            lines += &#39;else {\n&#39;
            lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            lines += &#39;}\n&#39;
            
            return lines


def switchNto1( state : SignalUserTemplate, inputs : SignalUserTemplate ):
    return wrap_signal( SwitchNto1(get_simulation_context(), state.unwrap, unwrap_list(inputs) ).outputs[0] )




























class ConditionalOverwrite(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, signal : Signal, condition : Signal, new_value ):

        self.new_value = new_value

        if isinstance( self.new_value, Signal ): 
            bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [signal, condition, new_value])
        else:
            bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [signal, condition])

    def config_request_define_output_types(self, inputTypes):

        # just inherit the input type
        if isinstance( self.new_value, Signal ): 
            return [ dt.common_numeric_type( inputTypes ) ]

        else:
            return [ inputTypes[0] ]


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:

            if isinstance( self.new_value, Signal ): 
                action_overwrite = self.outputs[0].name + &#39; = &#39; + self.inputSignals[2].name + &#39;;&#39;

            else:                
                action_overwrite = self.outputs[0].name + &#39; = &#39; + str( self.new_value ) + &#39;;&#39;

            action_keep = self.outputs[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;&#39;

            lines = cgh.generate_if_else( language, condition_list=[ self.inputSignals[1].name ], action_list=[ action_overwrite, action_keep ] )
            return lines


def conditional_overwrite(signal : SignalUserTemplate, condition : SignalUserTemplate, new_value ):

    if isinstance(new_value, SignalUserTemplate):
        new_value = new_value.unwrap

    return wrap_signal( ConditionalOverwrite(get_simulation_context(), signal.unwrap, condition.unwrap, new_value).outputs[0] )





















#
# Static functions that map 1 --&gt; 1
#

class StaticFnByName_1To1(bi.StaticFn_1To1):
    def __init__(self, sim : Simulation, u : Signal, functionName : str ):

        self._functionName = functionName

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._functionName) + &#39;(&#39; + self.inputs[0].name +  &#39;);\n&#39;



def sqrt(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;sqrt&#39;).outputs[0] )

def sin(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;sin&#39;).outputs[0] )

def cos(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;cos&#39;).outputs[0] )

def tan(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;tan&#39;).outputs[0] )

def atan(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;atan&#39;).outputs[0] )

def asin(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;asin&#39;).outputs[0] )

def acos(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;acos&#39;).outputs[0] )

def abs(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;abs&#39;).outputs[0] )




class Operator0(bi.StaticFn_1To1):
    def __init__(self, sim : Simulation, u : Signal, operator_str : str ):

        self._operator_str = operator_str

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._operator_str) + self.inputs[0].name +  &#39;;\n&#39;


def logic_not(u : SignalUserTemplate ):
    &#34;&#34;&#34;
        logic negation
    &#34;&#34;&#34;
    return wrap_signal( Operator0(get_simulation_context(), u.unwrap, &#39;!&#39;).outputs[0] )

def bitwise_not(u : SignalUserTemplate ):
    return wrap_signal( Operator0(get_simulation_context(), u.unwrap, &#39;~&#39;).outputs[0] )





#
# static functinos that map 2 --&gt; 1
#

class StaticFnByName_2To1(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, left : Signal, right : Signal, function_name : str ):

        self._function_name = function_name

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [left, right])

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = signals[0].name + &#39; = &#39; + self._function_name + &#39;(&#39; + self.inputSignals[0].name +  &#39;, &#39; + self.inputSignals[1].name + &#39;)&#39; + &#39;;\n&#39;
            return lines


def atan2(y : SignalUserTemplate, x : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_2To1(get_simulation_context(), y.unwrap, x.unwrap, &#39;atan2&#39;).outputs[0] )

def pow(base : SignalUserTemplate, power : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_2To1(get_simulation_context(), base.unwrap, power.unwrap, &#39;pow&#39;).outputs[0] )

def fmod(x : SignalUserTemplate, y : SignalUserTemplate ):
    &#34;&#34;&#34;
        modulo function for floating point values

        This function returns the remainder of dividing x/y.
    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_2To1(get_simulation_context(), x.unwrap, y.unwrap, &#39;fmod&#39;).outputs[0] )









class GenericCppStatic(bi.BlockPrototype):
    def __init__(self, sim : Simulation, input_signals : List[Signal], input_names : List [str], input_types, output_names : List[str], output_types, cpp_source_code : str ):

        Ninputs = len(input_names)

        if not Ninputs == len(input_types):
            raise BaseException(&#39;not Ninputs == len(input_types)&#39;)

        if not Ninputs == len(input_signals):
            raise BaseException(&#39;not Ninputs == len)(input_signals)&#39;)

        if not len(output_names) == len(output_types):
            raise BaseException(&#39;not len(output_names) == len(output_types)&#39;)

        self._input_signals = input_signals
        self._input_names = input_names
        self._input_types = input_types
        self._output_names = output_names
        self._output_types = output_types
        self._cpp_source_code = cpp_source_code

        bi.BlockPrototype.__init__(self, sim, input_signals, len(output_names), output_types  )

        self._static_function_name = &#39;fn_static_&#39; + str(self.id)

    def config_request_define_output_types(self, inputTypes):

        for i in range(0, len(inputTypes)):
            if inputTypes[i] is not None and not inputTypes[i].isEqualTo( self._input_types[i] ):
                raise BaseException(&#39;GenericCppStatic: datatype missmatch for input # &#39; + str(i) )

        # return a proposal for an output type. 
        return self._output_types

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # the output depends on all inputs
        return self.inputs 

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return None  # no states

    def codegen_addToNamespace(self, language):

        if language == &#39;c++&#39;:
            ilines = &#39;&#39;

            info_comment_1 = &#39;// begin of user defined function\n&#39;
            info_comment_2 = &#39;\n// end of user defined function\n&#39;

            ilines += cgh.cpp_define_function_from_types(self._static_function_name, self._input_types, self._input_names, self._output_types, self._output_names, info_comment_1 + self._cpp_source_code + info_comment_2 )

            return ilines

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:

            ilines = &#39;&#39;

            # create tmp output variables
            tmp_output_variable_names = []
            for i in range(0, len(self._output_names)):
                tmp_variable_name = self._static_function_name + &#39;_&#39; + self._output_names[i]
                tmp_output_variable_names.append( tmp_variable_name )
                ilines += self._output_types[i].cpp_define_variable(variable_name=tmp_variable_name) + &#39;;\n&#39;

            # function call
            ilines += cgh.call_function_from_varnames( self._static_function_name, cgh.signal_list_to_name_list(self.inputs), tmp_output_variable_names)

            # copy outputs from tmp variables
            for i in range(0, len(self._output_names)):

                # only copy the needed outputs as indicated by &#39;signals&#39;
                if self.outputs[i] in signals:
                    ilines += self.outputs[i].name + &#39; = &#39; + tmp_output_variable_names[i] + &#39;;\n&#39;

            return &#39;{ // calling the static function &#39; + self._static_function_name + &#39;\n&#39; + cgh.indent(ilines) + &#39;}\n&#39;

def generic_cpp_static(input_signals : List[SignalUserTemplate], input_names : List [str], input_types, output_types, output_names, cpp_source_code : str ):
    return wrap_signal_list( GenericCppStatic(get_simulation_context(), unwrap_list(input_signals), input_names, input_types, output_names, output_types, cpp_source_code  ).outputs )









#
# Blocks that have an internal memory
#



class Delay(bi.BlockPrototype):
    def __init__(self, sim : Simulation, u : Signal, initial_state = None ):

        self._initial_state = initial_state
        bi.BlockPrototype.__init__(self, sim, [ u ], 1)

    def config_request_define_output_types(self, inputTypes):

        # just inherit the input type 
        output_type = inputTypes[0]

        return [ output_type ]        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # no (direct feedtrough) dependence on any input - only state dependent
        return [  ]

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return self.inputs  # all inputs

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            return self.outputs[0].datatype.cpp_define_variable( self.getUniqueVarnamePrefix() + &#39;_mem&#39; )  + &#39;;\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39;;\n&#39;

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            lines = self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            if self._initial_state is None:
                # get the zero element for the given datatype
                initial_state_str = str(self.outputs[0].datatype.cpp_zero_element)
            else:
                initial_state_str = str(self._initial_state)

            return self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;


def delay__(u : SignalUserTemplate, initial_state = None):
    return wrap_signal( Delay(get_simulation_context(), u.unwrap, initial_state ).outputs[0] )






class Flipflop(bi.BlockPrototype):
    def __init__(self, sim : Simulation, activate_trigger : Signal, disable_trigger : Signal, initial_state = False, nodelay = False ):

        self._nodelay = nodelay
        self._activate_trigger = activate_trigger
        self._disable_trigger  = disable_trigger
        self._initial_state    = initial_state

        bi.BlockPrototype.__init__(self, sim, [ activate_trigger, disable_trigger ], 1)

    def config_request_define_output_types(self, inputTypes):

        return [ dt.DataTypeBoolean(1) ]        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        if self._nodelay:
            # (direct feedtrough) dependence on all inputs
            return self.inputs
        else:
            # no direct feedthrough
            return []

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return self.inputs  # all inputs

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            return self.outputs[0].datatype.cpp_define_variable( self.getUniqueVarnamePrefix() + &#39;_state&#39; )  + &#39;;\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            
            state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;

            lines = signals[0].name + &#39; = &#39; + state_varname + &#39;;\n&#39;
            if self._nodelay:
                lines += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + signals[0].name + &#39;;\n&#39;
                lines += signals[0].name + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + signals[0].name + &#39;;\n&#39;

            return lines

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;
            lines = state_varname + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + state_varname + &#39;;\n&#39;
            lines += state_varname + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + state_varname + &#39;;\n&#39;
            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            if self._initial_state:
                # get the zero element for the given datatype
                initial_state_str = &#39;true&#39;
            else:
                initial_state_str = &#39;false&#39;

            return self.getUniqueVarnamePrefix() + &#39;_state&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;


def flipflop(activate_trigger : Signal, disable_trigger : Signal, initial_state = False, nodelay = False):
    &#34;&#34;&#34;
        TODO..
    &#34;&#34;&#34;
    
    return wrap_signal( Flipflop(get_simulation_context(), activate_trigger.unwrap, disable_trigger.unwrap, initial_state = initial_state, nodelay=nodelay ).outputs[0] )









#
# memory / array to store / read values
#

class Memory(bi.BlockPrototype):
    def __init__(self, sim : Simulation, datatype, constant_array, write_index : Signal = None, value : Signal = None ):

        self._constant_array = constant_array
        self._length         = len(constant_array)
        self._array_datatype = dt.DataTypeArray( self._length, datatype )

        if write_index is None:
            self._static = True
        elif value is not None:
            self._static = False
        else:
            raise BaseException(&#39;Memory: write_index was defined but no value to write&#39;)

        # call super
        if self._static:
            bi.BlockPrototype.__init__(self, sim, inputSignals = [], N_outputs = 1, output_datatype_list = [self._array_datatype]  )
        else:
            bi.BlockPrototype.__init__(self, sim, inputSignals = [write_index, value], N_outputs = 1, output_datatype_list = [self._array_datatype]  )

        # indicate that the output of this port is passed by reference in c++
        self.outputs[0].set_is_referencing_memory(True)

        self.outputs[0].properties_internal[&#39;memory_length&#39;] = self._length

    # TODO: not sure if this is ever beeing called as the output datatypes are already specified in the constructor
    def config_request_define_output_types(self, inputTypes):
        # define the output type 
        return [ self._array_datatype ]

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # the output depends on nothing
        return []
            
    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states

        if self._static:
            return []  # no states
        else:
            return [self.inputs[0], self.inputs[1]]

    #
    # code gen
    #

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:

            # encode the given data and initialize a C array
            csv_array = &#39;,&#39;.join([str(x) for x in self._constant_array])
            return self._array_datatype.cpp_define_variable(  self.getUniqueVarnamePrefix() + &#39;_array&#39; ) + &#39; {&#39; + csv_array + &#39;};\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            # place a reference
            return cgh.defineVariable( signals[0], make_a_reference=True ) + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_array&#39; + &#39;;\n&#39;

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            if self._static:
                return &#39;&#39;

            code = &#39;&#39; +  self.inputs[0].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

            code += self.getUniqueVarnamePrefix() + &#39;_array[tmp] = &#39; + self.inputs[1].name + &#39;;\n&#39;

            return cgh.brackets(code)

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:
            # TODO
            return &#39;// WARNIG: reset of memory not implemented\n&#39;




def memory(datatype, constant_array, write_index : SignalUserTemplate = None, value : SignalUserTemplate = None):
    &#34;&#34;&#34;
        Define an array

        Allocates static memory for an array of elements given a datatype.
        During each sampling instant, one element can be (over)written. 

        datatype       - the datatype of the array elements
        constant_array - list of constants that contain the data to initialize the array
        write_index    - the array index of the element to replace by value (optional)
        value          - the value to write into the array at write_index (optional)

        returns a reference to the memory segment which is accessible by memory_read()

        Limitations: currently the memory is not reset on subsystem reset. This will change.
    &#34;&#34;&#34;

    if write_index is not None and value is not None:
        return wrap_signal( Memory(get_simulation_context(), datatype, constant_array, write_index.unwrap, value.unwrap).outputs[0] )
    elif write_index is None and value is None:
        return wrap_signal( Memory(get_simulation_context(), datatype, constant_array).outputs[0] )
    else:
        raise BaseException(&#39;memory: write_index and value were not properly defined&#39;)




class MemoryRead(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, memory : Signal, index : Signal ):

        if &#39;memory_length&#39; not in memory.properties_internal:
            raise BaseException(&#39;No property memory_length in input signal. Please create the input signal using memory()&#39;)

        self._length = memory.properties_internal[&#39;memory_length&#39;]

        # print(&#39; ############# reading a memory of length&#39;, self._length)

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [memory, index] )

    def config_request_define_output_types(self, inputTypes):
        # returt the datatype of the array elements
        return [ self.inputs[0].getDatatype().datatype_of_elements ]  

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:

            code = &#39;&#39; +  self.inputs[1].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[1].name + &#39;;\n&#39;
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

            code += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;[tmp];\n&#39;
            
            return cgh.brackets(code)

def memory_read( memory : SignalUserTemplate, index : SignalUserTemplate ):
    &#34;&#34;&#34;
        Read an element from an array defined by memory()

        index - the index indicating the element to read.

        Returns the value of the element
    &#34;&#34;&#34;
    return wrap_signal( MemoryRead(get_simulation_context(), memory.unwrap, index.unwrap ).outputs[0] )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="openrtdynamics2.block_prototypes.abs"><code class="name flex">
<span>def <span class="ident">abs</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abs(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;abs&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.acos"><code class="name flex">
<span>def <span class="ident">acos</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acos(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;acos&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>inputSignals: List[<a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], factors: List[float])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(inputSignals : List[SignalUserTemplate], factors : List[float]):
    return wrap_signal( Add(get_simulation_context(), unwrap_list( inputSignals ), factors).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.asin"><code class="name flex">
<span>def <span class="ident">asin</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asin(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;asin&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.atan"><code class="name flex">
<span>def <span class="ident">atan</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atan(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;atan&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.atan2"><code class="name flex">
<span>def <span class="ident">atan2</span></span>(<span>y: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, x: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atan2(y : SignalUserTemplate, x : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_2To1(get_simulation_context(), y.unwrap, x.unwrap, &#39;atan2&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.bitwise_and"><code class="name flex">
<span>def <span class="ident">bitwise_and</span></span>(<span>u1: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>bitwise and</p>
<p>u1 &amp; u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_and(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        bitwise and

        u1 &amp; u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list([u1,u2]), operator=&#39; &amp; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.bitwise_not"><code class="name flex">
<span>def <span class="ident">bitwise_not</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_not(u : SignalUserTemplate ):
    return wrap_signal( Operator0(get_simulation_context(), u.unwrap, &#39;~&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.bitwise_or"><code class="name flex">
<span>def <span class="ident">bitwise_or</span></span>(<span>u1: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>bitwise or</p>
<p>u1 | u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_or(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        bitwise or
    
        u1 | u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; | &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.bitwise_shift_left"><code class="name flex">
<span>def <span class="ident">bitwise_shift_left</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, shift: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical shift left</p>
<p>u &lt;&lt; shift</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_shift_left(u : SignalUserTemplate, shift : SignalUserTemplate):
    &#34;&#34;&#34;
        logical shift left
    
        u &lt;&lt; shift
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u,shift] ), operator=&#39; &lt;&lt; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.bitwise_shift_right"><code class="name flex">
<span>def <span class="ident">bitwise_shift_right</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, shift: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical shift left</p>
<p>u &gt;&gt; shift</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_shift_right(u : SignalUserTemplate, shift : SignalUserTemplate):
    &#34;&#34;&#34;
        logical shift left
    
        u &gt;&gt; shift
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u,shift] ), operator=&#39; &gt;&gt; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.comparison"><code class="name flex">
<span>def <span class="ident">comparison</span></span>(<span>left: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, right: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, operator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison(left : SignalUserTemplate, right : SignalUserTemplate, operator : str ):
    return wrap_signal( ComparisionOperator(get_simulation_context(), left.unwrap, right.unwrap, operator).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.conditional_overwrite"><code class="name flex">
<span>def <span class="ident">conditional_overwrite</span></span>(<span>signal: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, condition: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, new_value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conditional_overwrite(signal : SignalUserTemplate, condition : SignalUserTemplate, new_value ):

    if isinstance(new_value, SignalUserTemplate):
        new_value = new_value.unwrap

    return wrap_signal( ConditionalOverwrite(get_simulation_context(), signal.unwrap, condition.unwrap, new_value).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.const"><code class="name flex">
<span>def <span class="ident">const</span></span>(<span>constant, datatype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def const(constant, datatype ):
    return wrap_signal( Const(get_simulation_context(), constant, datatype).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, target_type: <a title="openrtdynamics2.datatypes.DataType" href="datatypes.html#openrtdynamics2.datatypes.DataType">DataType</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(u : SignalUserTemplate, target_type : dt.DataType ):
    return wrap_signal( ConvertDatatype(get_simulation_context(), u.unwrap, target_type).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.cos"><code class="name flex">
<span>def <span class="ident">cos</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cos(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;cos&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.delay__"><code class="name flex">
<span>def <span class="ident">delay__</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay__(u : SignalUserTemplate, initial_state = None):
    return wrap_signal( Delay(get_simulation_context(), u.unwrap, initial_state ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.flipflop"><code class="name flex">
<span>def <span class="ident">flipflop</span></span>(<span>activate_trigger: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, disable_trigger: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, initial_state=False, nodelay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>TODO..</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flipflop(activate_trigger : Signal, disable_trigger : Signal, initial_state = False, nodelay = False):
    &#34;&#34;&#34;
        TODO..
    &#34;&#34;&#34;
    
    return wrap_signal( Flipflop(get_simulation_context(), activate_trigger.unwrap, disable_trigger.unwrap, initial_state = initial_state, nodelay=nodelay ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.fmod"><code class="name flex">
<span>def <span class="ident">fmod</span></span>(<span>x: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, y: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>modulo function for floating point values</p>
<p>This function returns the remainder of dividing x/y.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fmod(x : SignalUserTemplate, y : SignalUserTemplate ):
    &#34;&#34;&#34;
        modulo function for floating point values

        This function returns the remainder of dividing x/y.
    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_2To1(get_simulation_context(), x.unwrap, y.unwrap, &#39;fmod&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.gain"><code class="name flex">
<span>def <span class="ident">gain</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, gain: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gain(u : SignalUserTemplate, gain : float ):
    return wrap_signal( Gain(get_simulation_context(), u.unwrap, gain).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.generic_cpp_static"><code class="name flex">
<span>def <span class="ident">generic_cpp_static</span></span>(<span>input_signals: List[<a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], input_names: List[str], input_types, output_types, output_names, cpp_source_code: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_cpp_static(input_signals : List[SignalUserTemplate], input_names : List [str], input_types, output_types, output_names, cpp_source_code : str ):
    return wrap_signal_list( GenericCppStatic(get_simulation_context(), unwrap_list(input_signals), input_names, input_types, output_names, output_types, cpp_source_code  ).outputs )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.generic_subsystem"><code class="name flex">
<span>def <span class="ident">generic_subsystem</span></span>(<span>manifest, inputSignals: List[<a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_subsystem( manifest, inputSignals : List[SignalUserTemplate] ):
    return wrap_signal_list( GenericSubsystem(get_simulation_context(), manifest, unwrap_hash(inputSignals) ).outputSignals )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.logic_and"><code class="name flex">
<span>def <span class="ident">logic_and</span></span>(<span>u1: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical and</p>
<p>u1 &amp;&amp; u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_and(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        logical and

        u1 &amp;&amp; u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list([u1,u2]), operator=&#39; &amp;&amp; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.logic_not"><code class="name flex">
<span>def <span class="ident">logic_not</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logic negation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_not(u : SignalUserTemplate ):
    &#34;&#34;&#34;
        logic negation
    &#34;&#34;&#34;
    return wrap_signal( Operator0(get_simulation_context(), u.unwrap, &#39;!&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.logic_or"><code class="name flex">
<span>def <span class="ident">logic_or</span></span>(<span>u1: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical or</p>
<p>u1 || u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_or(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        logical or
    
        u1 || u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; || &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.logic_xor"><code class="name flex">
<span>def <span class="ident">logic_xor</span></span>(<span>u1: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>exclusive logical or (xor)</p>
<p>u1 ^ u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_xor(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        exclusive logical or (xor)
    
        u1 ^ u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(get_simulation_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; ^ &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.memory"><code class="name flex">
<span>def <span class="ident">memory</span></span>(<span>datatype, constant_array, write_index: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a> = None, value: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Define an array</p>
<p>Allocates static memory for an array of elements given a datatype.
During each sampling instant, one element can be (over)written. </p>
<p>datatype
- the datatype of the array elements
constant_array - list of constants that contain the data to initialize the array
write_index
- the array index of the element to replace by value (optional)
value
- the value to write into the array at write_index (optional)</p>
<p>returns a reference to the memory segment which is accessible by memory_read()</p>
<p>Limitations: currently the memory is not reset on subsystem reset. This will change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory(datatype, constant_array, write_index : SignalUserTemplate = None, value : SignalUserTemplate = None):
    &#34;&#34;&#34;
        Define an array

        Allocates static memory for an array of elements given a datatype.
        During each sampling instant, one element can be (over)written. 

        datatype       - the datatype of the array elements
        constant_array - list of constants that contain the data to initialize the array
        write_index    - the array index of the element to replace by value (optional)
        value          - the value to write into the array at write_index (optional)

        returns a reference to the memory segment which is accessible by memory_read()

        Limitations: currently the memory is not reset on subsystem reset. This will change.
    &#34;&#34;&#34;

    if write_index is not None and value is not None:
        return wrap_signal( Memory(get_simulation_context(), datatype, constant_array, write_index.unwrap, value.unwrap).outputs[0] )
    elif write_index is None and value is None:
        return wrap_signal( Memory(get_simulation_context(), datatype, constant_array).outputs[0] )
    else:
        raise BaseException(&#39;memory: write_index and value were not properly defined&#39;)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.memory_read"><code class="name flex">
<span>def <span class="ident">memory_read</span></span>(<span>memory: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, index: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Read an element from an array defined by memory()</p>
<p>index - the index indicating the element to read.</p>
<p>Returns the value of the element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_read( memory : SignalUserTemplate, index : SignalUserTemplate ):
    &#34;&#34;&#34;
        Read an element from an array defined by memory()

        index - the index indicating the element to read.

        Returns the value of the element
    &#34;&#34;&#34;
    return wrap_signal( MemoryRead(get_simulation_context(), memory.unwrap, index.unwrap ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.operator1"><code class="name flex">
<span>def <span class="ident">operator1</span></span>(<span>inputSignals: List[<a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], operator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operator1(inputSignals : List[SignalUserTemplate], operator : str ):
    return wrap_signal( Operator1(get_simulation_context(), unwrap_list( inputSignals ), operator).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.pow"><code class="name flex">
<span>def <span class="ident">pow</span></span>(<span>base: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, power: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pow(base : SignalUserTemplate, power : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_2To1(get_simulation_context(), base.unwrap, power.unwrap, &#39;pow&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.sin"><code class="name flex">
<span>def <span class="ident">sin</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sin(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;sin&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.sqrt"><code class="name flex">
<span>def <span class="ident">sqrt</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sqrt(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;sqrt&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.switchNto1"><code class="name flex">
<span>def <span class="ident">switchNto1</span></span>(<span>state: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, inputs: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switchNto1( state : SignalUserTemplate, inputs : SignalUserTemplate ):
    return wrap_signal( SwitchNto1(get_simulation_context(), state.unwrap, unwrap_list(inputs) ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.tan"><code class="name flex">
<span>def <span class="ident">tan</span></span>(<span>u: <a title="openrtdynamics2.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tan(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(get_simulation_context(), u.unwrap, &#39;tan&#39;).outputs[0] )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="openrtdynamics2.block_prototypes.Add"><code class="flex name class">
<span>class <span class="ident">Add</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, inputSignals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>], factors: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Add(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, inputSignals : List[Signal], factors : List[float] ):

        # feasibility checks
        if len(inputSignals) != len(factors):
            raise(&#34;len(inp_list) must be equal to len(factors)&#34;)

        self.factors = factors
        bi.StaticFn_NTo1.__init__(self, sim, inputSignals)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            strs = []
            i = 0
            for s in self.inputSignals:
                strs.append(  str(self.factors[i]) + &#39; * &#39; + s.name )
                i = i + 1

            sumline = &#39; + &#39;.join( strs )
            lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.Add.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        strs = []
        i = 0
        for s in self.inputSignals:
            strs.append(  str(self.factors[i]) + &#39; * &#39; + s.name )
            i = i + 1

        sumline = &#39; + &#39;.join( strs )
        lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.ComparisionOperator"><code class="flex name class">
<span>class <span class="ident">ComparisionOperator</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, left: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, right: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, operator: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ComparisionOperator(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, left : Signal, right : Signal, operator : str ):

        self.operator = operator

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [left, right])

    def config_request_define_output_types(self, inputTypes):

        # return a proposal for an output type. 
        return [ dt.DataTypeBoolean(1) ]

    # def generate_code_output(self, language, signal : Signal):
    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = signals[0].name + &#39; = &#39; + self.inputSignals[0].name + &#39; &#39; + self.operator + &#39; &#39; + self.inputSignals[1].name + &#39;;\n&#39;
            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.ComparisionOperator.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # return a proposal for an output type. 
    return [ dt.DataTypeBoolean(1) ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.ComparisionOperator.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        lines = signals[0].name + &#39; = &#39; + self.inputSignals[0].name + &#39; &#39; + self.operator + &#39; &#39; + self.inputSignals[1].name + &#39;;\n&#39;
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.ConditionalOverwrite"><code class="flex name class">
<span>class <span class="ident">ConditionalOverwrite</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, signal: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, condition: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, new_value)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConditionalOverwrite(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, signal : Signal, condition : Signal, new_value ):

        self.new_value = new_value

        if isinstance( self.new_value, Signal ): 
            bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [signal, condition, new_value])
        else:
            bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [signal, condition])

    def config_request_define_output_types(self, inputTypes):

        # just inherit the input type
        if isinstance( self.new_value, Signal ): 
            return [ dt.common_numeric_type( inputTypes ) ]

        else:
            return [ inputTypes[0] ]


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:

            if isinstance( self.new_value, Signal ): 
                action_overwrite = self.outputs[0].name + &#39; = &#39; + self.inputSignals[2].name + &#39;;&#39;

            else:                
                action_overwrite = self.outputs[0].name + &#39; = &#39; + str( self.new_value ) + &#39;;&#39;

            action_keep = self.outputs[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;&#39;

            lines = cgh.generate_if_else( language, condition_list=[ self.inputSignals[1].name ], action_list=[ action_overwrite, action_keep ] )
            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.ConditionalOverwrite.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # just inherit the input type
    if isinstance( self.new_value, Signal ): 
        return [ dt.common_numeric_type( inputTypes ) ]

    else:
        return [ inputTypes[0] ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.ConditionalOverwrite.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:

        if isinstance( self.new_value, Signal ): 
            action_overwrite = self.outputs[0].name + &#39; = &#39; + self.inputSignals[2].name + &#39;;&#39;

        else:                
            action_overwrite = self.outputs[0].name + &#39; = &#39; + str( self.new_value ) + &#39;;&#39;

        action_keep = self.outputs[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;&#39;

        lines = cgh.generate_if_else( language, condition_list=[ self.inputSignals[1].name ], action_list=[ action_overwrite, action_keep ] )
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.Const"><code class="flex name class">
<span>class <span class="ident">Const</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, constant, datatype)</span>
</code></dt>
<dd>
<div class="desc"><p>This defines a static source</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Const(bi.StaticSource_To1):
    def __init__(self, sim : Simulation, constant, datatype ):

        self.constant = constant

        # call super
        bi.StaticSource_To1.__init__(self, sim, datatype)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str( self.constant ) + &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticSource_To1" href="block_interface.html#openrtdynamics2.block_interface.StaticSource_To1">StaticSource_To1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.Const.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + str( self.constant ) + &#39;;\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticSource_To1" href="block_interface.html#openrtdynamics2.block_interface.StaticSource_To1">StaticSource_To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticSource_To1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.ConvertDatatype"><code class="flex name class">
<span>class <span class="ident">ConvertDatatype</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, u: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, target_type: <a title="openrtdynamics2.datatypes.DataType" href="datatypes.html#openrtdynamics2.datatypes.DataType">DataType</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConvertDatatype(bi.StaticFn_1To1):
    def __init__(self, sim : Simulation, u : Signal, target_type : dt.DataType ):

        self._target_type = target_type

        bi.StaticFn_1To1.__init__(self, sim, u)

    def config_request_define_output_types(self, inputTypes):
        return [ self._target_type ]  

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            # TODO: only = is used and the c++ compiler decides how to convert...
            return signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_1To1">StaticFn_1To1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.ConvertDatatype.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):
    return [ self._target_type ]  </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.ConvertDatatype.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        # TODO: only = is used and the c++ compiler decides how to convert...
        return signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_1To1">StaticFn_1To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.Delay"><code class="flex name class">
<span>class <span class="ident">Delay</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, u: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Delay(bi.BlockPrototype):
    def __init__(self, sim : Simulation, u : Signal, initial_state = None ):

        self._initial_state = initial_state
        bi.BlockPrototype.__init__(self, sim, [ u ], 1)

    def config_request_define_output_types(self, inputTypes):

        # just inherit the input type 
        output_type = inputTypes[0]

        return [ output_type ]        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # no (direct feedtrough) dependence on any input - only state dependent
        return [  ]

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return self.inputs  # all inputs

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            return self.outputs[0].datatype.cpp_define_variable( self.getUniqueVarnamePrefix() + &#39;_mem&#39; )  + &#39;;\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39;;\n&#39;

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            lines = self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            if self._initial_state is None:
                # get the zero element for the given datatype
                initial_state_str = str(self.outputs[0].datatype.cpp_zero_element)
            else:
                initial_state_str = str(self._initial_state)

            return self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.Delay.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # just inherit the input type 
    output_type = inputTypes[0]

    return [ output_type ]        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Delay.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39;;\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Delay.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:

        if self._initial_state is None:
            # get the zero element for the given datatype
            initial_state_str = str(self.outputs[0].datatype.cpp_zero_element)
        else:
            initial_state_str = str(self._initial_state)

        return self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Delay.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):
    if language == &#39;c++&#39;:

        lines = self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.Flipflop"><code class="flex name class">
<span>class <span class="ident">Flipflop</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, activate_trigger: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, disable_trigger: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, initial_state=False, nodelay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Flipflop(bi.BlockPrototype):
    def __init__(self, sim : Simulation, activate_trigger : Signal, disable_trigger : Signal, initial_state = False, nodelay = False ):

        self._nodelay = nodelay
        self._activate_trigger = activate_trigger
        self._disable_trigger  = disable_trigger
        self._initial_state    = initial_state

        bi.BlockPrototype.__init__(self, sim, [ activate_trigger, disable_trigger ], 1)

    def config_request_define_output_types(self, inputTypes):

        return [ dt.DataTypeBoolean(1) ]        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        if self._nodelay:
            # (direct feedtrough) dependence on all inputs
            return self.inputs
        else:
            # no direct feedthrough
            return []

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return self.inputs  # all inputs

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            return self.outputs[0].datatype.cpp_define_variable( self.getUniqueVarnamePrefix() + &#39;_state&#39; )  + &#39;;\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            
            state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;

            lines = signals[0].name + &#39; = &#39; + state_varname + &#39;;\n&#39;
            if self._nodelay:
                lines += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + signals[0].name + &#39;;\n&#39;
                lines += signals[0].name + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + signals[0].name + &#39;;\n&#39;

            return lines

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;
            lines = state_varname + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + state_varname + &#39;;\n&#39;
            lines += state_varname + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + state_varname + &#39;;\n&#39;
            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            if self._initial_state:
                # get the zero element for the given datatype
                initial_state_str = &#39;true&#39;
            else:
                initial_state_str = &#39;false&#39;

            return self.getUniqueVarnamePrefix() + &#39;_state&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.Flipflop.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    return [ dt.DataTypeBoolean(1) ]        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Flipflop.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        
        state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;

        lines = signals[0].name + &#39; = &#39; + state_varname + &#39;;\n&#39;
        if self._nodelay:
            lines += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + signals[0].name + &#39;;\n&#39;
            lines += signals[0].name + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + signals[0].name + &#39;;\n&#39;

        return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Flipflop.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:

        if self._initial_state:
            # get the zero element for the given datatype
            initial_state_str = &#39;true&#39;
        else:
            initial_state_str = &#39;false&#39;

        return self.getUniqueVarnamePrefix() + &#39;_state&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Flipflop.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):
    if language == &#39;c++&#39;:

        state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;
        lines = state_varname + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + state_varname + &#39;;\n&#39;
        lines += state_varname + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + state_varname + &#39;;\n&#39;
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.Gain"><code class="flex name class">
<span>class <span class="ident">Gain</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, u: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, factor: float)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gain(bi.StaticFn_1To1):
    def __init__(self, sim : Simulation, u : Signal, factor : float ):

        self._factor = factor

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._factor) + &#39; * &#39; + self.inputs[0].name +  &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_1To1">StaticFn_1To1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.Gain.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + str(self._factor) + &#39; * &#39; + self.inputs[0].name +  &#39;;\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_1To1">StaticFn_1To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericCppStatic"><code class="flex name class">
<span>class <span class="ident">GenericCppStatic</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, input_signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>], input_names: List[str], input_types, output_names: List[str], output_types, cpp_source_code: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericCppStatic(bi.BlockPrototype):
    def __init__(self, sim : Simulation, input_signals : List[Signal], input_names : List [str], input_types, output_names : List[str], output_types, cpp_source_code : str ):

        Ninputs = len(input_names)

        if not Ninputs == len(input_types):
            raise BaseException(&#39;not Ninputs == len(input_types)&#39;)

        if not Ninputs == len(input_signals):
            raise BaseException(&#39;not Ninputs == len)(input_signals)&#39;)

        if not len(output_names) == len(output_types):
            raise BaseException(&#39;not len(output_names) == len(output_types)&#39;)

        self._input_signals = input_signals
        self._input_names = input_names
        self._input_types = input_types
        self._output_names = output_names
        self._output_types = output_types
        self._cpp_source_code = cpp_source_code

        bi.BlockPrototype.__init__(self, sim, input_signals, len(output_names), output_types  )

        self._static_function_name = &#39;fn_static_&#39; + str(self.id)

    def config_request_define_output_types(self, inputTypes):

        for i in range(0, len(inputTypes)):
            if inputTypes[i] is not None and not inputTypes[i].isEqualTo( self._input_types[i] ):
                raise BaseException(&#39;GenericCppStatic: datatype missmatch for input # &#39; + str(i) )

        # return a proposal for an output type. 
        return self._output_types

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # the output depends on all inputs
        return self.inputs 

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return None  # no states

    def codegen_addToNamespace(self, language):

        if language == &#39;c++&#39;:
            ilines = &#39;&#39;

            info_comment_1 = &#39;// begin of user defined function\n&#39;
            info_comment_2 = &#39;\n// end of user defined function\n&#39;

            ilines += cgh.cpp_define_function_from_types(self._static_function_name, self._input_types, self._input_names, self._output_types, self._output_names, info_comment_1 + self._cpp_source_code + info_comment_2 )

            return ilines

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:

            ilines = &#39;&#39;

            # create tmp output variables
            tmp_output_variable_names = []
            for i in range(0, len(self._output_names)):
                tmp_variable_name = self._static_function_name + &#39;_&#39; + self._output_names[i]
                tmp_output_variable_names.append( tmp_variable_name )
                ilines += self._output_types[i].cpp_define_variable(variable_name=tmp_variable_name) + &#39;;\n&#39;

            # function call
            ilines += cgh.call_function_from_varnames( self._static_function_name, cgh.signal_list_to_name_list(self.inputs), tmp_output_variable_names)

            # copy outputs from tmp variables
            for i in range(0, len(self._output_names)):

                # only copy the needed outputs as indicated by &#39;signals&#39;
                if self.outputs[i] in signals:
                    ilines += self.outputs[i].name + &#39; = &#39; + tmp_output_variable_names[i] + &#39;;\n&#39;

            return &#39;{ // calling the static function &#39; + self._static_function_name + &#39;\n&#39; + cgh.indent(ilines) + &#39;}\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.GenericCppStatic.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    for i in range(0, len(inputTypes)):
        if inputTypes[i] is not None and not inputTypes[i].isEqualTo( self._input_types[i] ):
            raise BaseException(&#39;GenericCppStatic: datatype missmatch for input # &#39; + str(i) )

    # return a proposal for an output type. 
    return self._output_types</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericCppStatic.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:

        ilines = &#39;&#39;

        # create tmp output variables
        tmp_output_variable_names = []
        for i in range(0, len(self._output_names)):
            tmp_variable_name = self._static_function_name + &#39;_&#39; + self._output_names[i]
            tmp_output_variable_names.append( tmp_variable_name )
            ilines += self._output_types[i].cpp_define_variable(variable_name=tmp_variable_name) + &#39;;\n&#39;

        # function call
        ilines += cgh.call_function_from_varnames( self._static_function_name, cgh.signal_list_to_name_list(self.inputs), tmp_output_variable_names)

        # copy outputs from tmp variables
        for i in range(0, len(self._output_names)):

            # only copy the needed outputs as indicated by &#39;signals&#39;
            if self.outputs[i] in signals:
                ilines += self.outputs[i].name + &#39; = &#39; + tmp_output_variable_names[i] + &#39;;\n&#39;

        return &#39;{ // calling the static function &#39; + self._static_function_name + &#39;\n&#39; + cgh.indent(ilines) + &#39;}\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem"><code class="flex name class">
<span>class <span class="ident">GenericSubsystem</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a> = None, manifest=None, inputSignals=None, N_outputs=None, embedded_subsystem=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Include a sub-system by passing a manifest</p>
<ul>
<li>sim - the simulation this block is embedded into</li>
</ul>
<p>parameters required only in case the subsystem is already defined (e.g. loaded from a library):</p>
<ul>
<li>manifest
- the manifest of the subsystem to include (optional, might be handed over by init())</li>
<li>inputSignals
- the inputs to the subsystem </li>
<li>N_outputs
- prepare a number of nOutputs (optional in case a manifest is given)</li>
<li>embedded_subsystem - the system to embed (optional in case a manifest to an already compiled subsystem is given, NOT IMPLEMENTED)</li>
</ul>
<p>Note: the number of outputs must be defined either by N_outputs or by a manifest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericSubsystem(bi.BlockPrototype):
    &#34;&#34;&#34;
        Include a sub-system by passing a manifest

        - sim - the simulation this block is embedded into

        parameters required only in case the subsystem is already defined (e.g. loaded from a library):

        - manifest           - the manifest of the subsystem to include (optional, might be handed over by init())
        - inputSignals       - the inputs to the subsystem 
        - N_outputs          - prepare a number of nOutputs (optional in case a manifest is given)
        - embedded_subsystem - the system to embed (optional in case a manifest to an already compiled subsystem is given, NOT IMPLEMENTED)

        Note: the number of outputs must be defined either by N_outputs or by a manifest

    &#34;&#34;&#34;
    def __init__(self, sim : Simulation = None, manifest=None, inputSignals=None, N_outputs = None, embedded_subsystem=None ):

        self.manifest = manifest
        self.inputSignals = inputSignals
        self.sim = sim
        self.Noutputs = N_outputs
        self._embedded_subsystem = embedded_subsystem

        if manifest is not None:
            if N_outputs is None:
                self.Noutputs = self.manifest.number_of_default_ouputs
            else:
                raise BaseException(&#34;N_outputs and a manifest specified at the same time&#34;)

        # output signals that were created by sth. ourside of this prototype
        # and that need to be connected to the actual outputs when init() is called.
        self.anonymous_output_signals = None

        # optional (in case this block is in charge of putting the code for the subsystem)
        self.compileResult = None

        # init super class
        bi.BlockPrototype.__init__(self, self.sim, N_outputs = self.Noutputs)

        # Note: the inputSignals are not defined when subsystems are pre-defined in the code
        # but are automatically placed and connected by the compiler during compilation

        # check if it is already possible to init this prototype
        # (in case all requred information is available)
        if inputSignals is not None and manifest is not None:
            self.init()

        # configure datatype inheritance for the outputs signals
        for i in range(0, len( embedded_subsystem.primary_outputs )):

            output_signal_of_embedding_block = self.outputs[i]
            output_signal_of_subsystem = embedded_subsystem.primary_outputs[i]

            output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

    @property
    def embedded_subsystem(self):
        &#34;&#34;&#34;
            Return the system that is embedded (in case it was provided, returns None otherwise)
        &#34;&#34;&#34;

        return self._embedded_subsystem

    def set_anonymous_output_signal_to_connect(self, anonymous_output_signals):
        &#34;&#34;&#34;
            store a list of anonymous signals to connect to the outputs of the subsystems
            after running the post_compile_callback
        &#34;&#34;&#34;
        # List of raw signals 
        self.anonymous_output_signals = anonymous_output_signals

    def compile_callback_all_subsystems_compiled(self):

        embedded_system = self._embedded_subsystem
        #
        # continue init as now all subsystems are compiled and the compile results and the manifest of
        # the system to compile is available.
        #
        self.init(embedded_system.compilationResult.manifest, embedded_system.compilationResult, embedded_system.compilationResult.inputSignals)

    # post_compile_callback (called after the subsystem to embedd was compiled)
    def init(self, manifest, compileResult, inputSignals):
        &#34;&#34;&#34;
            This is a second phase initialization of this subsystem block 
            (to be called by compile_callback_all_subsystems_compiled())

            This function shall be called when the subsystem to embedd is compiled
            after the instance of &#39;GenericSubsystem&#39; is created. This way, it is possible
            to add blocks embeddeding sub-systems without haveing these subsystems to be
            already compiled.

            Optionally, the system this block belongs to can be set.

            manifest       - the system manifest of the subsystem to embedd
            compileResults - the compile results of the subsystem to embedd
            inputSignals   - input signals to the subsystem to embedd (links comming from an upper-level subsystem)

        &#34;&#34;&#34;        

        #
        #    set the manifest of the subsystem
        #
        if self.manifest is not None:
            raise BaseException(&#34;cannot call this function as the subsystem&#39;s manifest was already defined in the constructor.&#34;)

        self.manifest = manifest

        #
        #    Set the compilation result of the embedded system (if available)
        #
        self.compileResult = compileResult

        #
        #    connect the inputs (coming from the upper-level system)
        #

        if self.inputSignals is not None:
            raise BaseException(&#34;The subsystem&#39;s inputSignals were already specified in the constructor.&#34;)

        self.inputSignals = inputSignals



        def collectDependingSignals(signals, manifestFunctionInputs):
            # collect all depending input signals (that are needed to calculate the output) in a list
            # MOVE TO A FUNCTION. MAYBE MOVE TO MANIFEST.PY
            dependingInputs = []
            for i in range( len(manifestFunctionInputs[&#39;names&#39;]) ):

                dependingInput_name = manifestFunctionInputs[&#39;names&#39;][i]
                dependingInput_type = manifestFunctionInputs[&#39;types&#39;][i]
                dependingInput_cpptype = manifestFunctionInputs[&#39;cpptypes&#39;][i]

                # TODO: CHECK FOR FAILING LOOKUP
                signal = signals[ dependingInput_name ]

                # check datatype
                if not signal.getDatatype().cppDataType == dependingInput_cpptype:
                    raise BaseException(&#39;datatype does not match the one specified in the manifest. (&#39; + (dependingInput_cpptype) + &#39; is required in the manifest)&#39; )

                # append signal
                dependingInputs.append( signal ) 

            return dependingInputs



        # verify the number of outputs of the embedded system
        number_of_outputs_as_described_by_manifest = self.manifest.number_of_default_ouputs

        if not number_of_outputs_as_described_by_manifest == self.Noutputs:
            BaseException(&#34;missmatch in the number of outputs&#34;)

        # get the output datatypes of the embedded system
        self.outputTypes = self.manifest.io_outputs[&#39;calculate_output&#39;][&#39;types&#39;]  


        if self.compileResult is None:
            # collect all depending input signals (that are needed to calculate the output) in a list
            self.inputsToCalculateOutputs = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;calculate_output&#39;] )

            # collect all inputs required to perform the state update
            self.inputsToUpdateStates = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;state_update&#39;] )

        else:
            # use the available compile results to get the I/O signals
            # in this case, self.inputSignals shall be a list of signals. The order
            # shall match the signal order in self.compileResults.inputSignals

            self.inputsToCalculateOutputs = self.compileResult.simulationInputSignalsToCalculateOutputs
            self.inputsToUpdateStates = self.compileResult.simulationInputSignalsToUpdateStates

            

        # combine all inputs to a list
        self.allInputs = list()

        self.allInputs.extend( self.inputsToCalculateOutputs )
        self.allInputs.extend( self.inputsToUpdateStates )

        #
        # now initialize the propotype
        #

        # define the inputs
        self.update_input_config( self.allInputs )

        # connect the outputs signals
        if self.anonymous_output_signals is not None:

            print(&#34; -- Nesting block: connecting anonymous signals -- &#34;)

            Ns = len(self.outputSignals)

            if not Ns == len(  self.anonymous_output_signals ):
                raise BaseException(&#34; missmatch in the number of output signals&#34;)

            for i in range(0,Ns):
                
                s_ananon = self.anonymous_output_signals[i]
                s_source = self.outputSignals[i]

                print(&#34;connecting the output &#34; + s_ananon.toStr() + &#34; of the embedding block&#34;)
                s_ananon.setequal( s_source )



        # for code generation
        self.instanceVarname = self.getUniqueVarnamePrefix() + &#39;_subsystem_&#39; + self.manifest.API_name


    def config_request_define_output_types(self, inputTypes):

        # the datatypes are fixed in the manifest 
        return self.outputTypes        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):

        # NOTE: This is a simplified veriant so far.. no dependence on the given &#39;outputSignal&#39;
        #       (Every output depends on every signal in self.inputsToCalculateOutputs)

        # TODO: 6.10.19 implement this in a more granular way.
        # also use self.compileResults to get those information

        return self.inputsToCalculateOutputs

    def config_request_define_state_update_input_dependencies(self, outputSignal):
 
        # return a list of input signals that are required to update the states
        return self.inputsToUpdateStates



    def codegen_addToNamespace(self, language):
        lines = &#39;&#39;

        # putting code for subsystems is performed using execution commands

        return lines

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            lines = &#39;// instance of &#39; + self.manifest.API_name + &#39;\n&#39;
            lines += self.manifest.API_name + &#39; &#39; + self.instanceVarname + &#39;;\n&#39;

            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:
            return self.instanceVarname + &#39;.&#39; + self.manifest.getAPIFunctionName(&#39;reset&#39;) +  &#39;();\n&#39;


    def generate_code_init(self, language):
        pass


    def generate_code_destruct(self, language):
        pass


    # helper fn to build code
    def generate_code_call_OutputFunction(self, instanceVarname, manifest, language):
        return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;calculate_output&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.outputs + self.inputsToCalculateOutputs) + &#39;);\n&#39;

    # helper fn to build code
    def generate_code_call_UpdateFunction(self, instanceVarname, manifest, language):
        return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;state_update&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.inputsToUpdateStates) + &#39;);\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = &#39;&#39;
            
            #
            # TODO: 2.5.2020: concept: how to compute only the nescessary signals?
            #

            for s in self.outputs:
                lines += cgh.define_variable_line( s ) 

                if s not in signals:
                    lines += &#39;// NOTE: unused output signal&#39; + s.name + &#39;\n&#39;
                else:
                    lines += &#39;&#39;                

            lines += self.generate_code_call_OutputFunction(self.instanceVarname, self.manifest, language)

        return lines

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            # input to this call are the signals in self.inputsToUpdateStates
            return self.generate_code_call_UpdateFunction(self.instanceVarname, self.manifest, language)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.embedded_subsystem"><code class="name">var <span class="ident">embedded_subsystem</span></code></dt>
<dd>
<div class="desc"><p>Return the system that is embedded (in case it was provided, returns None otherwise)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def embedded_subsystem(self):
    &#34;&#34;&#34;
        Return the system that is embedded (in case it was provided, returns None otherwise)
    &#34;&#34;&#34;

    return self._embedded_subsystem</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # the datatypes are fixed in the manifest 
    return self.outputTypes        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_call_OutputFunction"><code class="name flex">
<span>def <span class="ident">generate_code_call_OutputFunction</span></span>(<span>self, instanceVarname, manifest, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_call_OutputFunction(self, instanceVarname, manifest, language):
    return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;calculate_output&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.outputs + self.inputsToCalculateOutputs) + &#39;);\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_call_UpdateFunction"><code class="name flex">
<span>def <span class="ident">generate_code_call_UpdateFunction</span></span>(<span>self, instanceVarname, manifest, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_call_UpdateFunction(self, instanceVarname, manifest, language):
    return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;state_update&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.inputsToUpdateStates) + &#39;);\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        lines = &#39;&#39;
        
        #
        # TODO: 2.5.2020: concept: how to compute only the nescessary signals?
        #

        for s in self.outputs:
            lines += cgh.define_variable_line( s ) 

            if s not in signals:
                lines += &#39;// NOTE: unused output signal&#39; + s.name + &#39;\n&#39;
            else:
                lines += &#39;&#39;                

        lines += self.generate_code_call_OutputFunction(self.instanceVarname, self.manifest, language)

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:
        return self.instanceVarname + &#39;.&#39; + self.manifest.getAPIFunctionName(&#39;reset&#39;) +  &#39;();\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):
    if language == &#39;c++&#39;:

        # input to this call are the signals in self.inputsToUpdateStates
        return self.generate_code_call_UpdateFunction(self.instanceVarname, self.manifest, language)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self, manifest, compileResult, inputSignals)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a second phase initialization of this subsystem block
(to be called by compile_callback_all_subsystems_compiled())</p>
<p>This function shall be called when the subsystem to embedd is compiled
after the instance of 'GenericSubsystem' is created. This way, it is possible
to add blocks embeddeding sub-systems without haveing these subsystems to be
already compiled.</p>
<p>Optionally, the system this block belongs to can be set.</p>
<p>manifest
- the system manifest of the subsystem to embedd
compileResults - the compile results of the subsystem to embedd
inputSignals
- input signals to the subsystem to embedd (links comming from an upper-level subsystem)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self, manifest, compileResult, inputSignals):
    &#34;&#34;&#34;
        This is a second phase initialization of this subsystem block 
        (to be called by compile_callback_all_subsystems_compiled())

        This function shall be called when the subsystem to embedd is compiled
        after the instance of &#39;GenericSubsystem&#39; is created. This way, it is possible
        to add blocks embeddeding sub-systems without haveing these subsystems to be
        already compiled.

        Optionally, the system this block belongs to can be set.

        manifest       - the system manifest of the subsystem to embedd
        compileResults - the compile results of the subsystem to embedd
        inputSignals   - input signals to the subsystem to embedd (links comming from an upper-level subsystem)

    &#34;&#34;&#34;        

    #
    #    set the manifest of the subsystem
    #
    if self.manifest is not None:
        raise BaseException(&#34;cannot call this function as the subsystem&#39;s manifest was already defined in the constructor.&#34;)

    self.manifest = manifest

    #
    #    Set the compilation result of the embedded system (if available)
    #
    self.compileResult = compileResult

    #
    #    connect the inputs (coming from the upper-level system)
    #

    if self.inputSignals is not None:
        raise BaseException(&#34;The subsystem&#39;s inputSignals were already specified in the constructor.&#34;)

    self.inputSignals = inputSignals



    def collectDependingSignals(signals, manifestFunctionInputs):
        # collect all depending input signals (that are needed to calculate the output) in a list
        # MOVE TO A FUNCTION. MAYBE MOVE TO MANIFEST.PY
        dependingInputs = []
        for i in range( len(manifestFunctionInputs[&#39;names&#39;]) ):

            dependingInput_name = manifestFunctionInputs[&#39;names&#39;][i]
            dependingInput_type = manifestFunctionInputs[&#39;types&#39;][i]
            dependingInput_cpptype = manifestFunctionInputs[&#39;cpptypes&#39;][i]

            # TODO: CHECK FOR FAILING LOOKUP
            signal = signals[ dependingInput_name ]

            # check datatype
            if not signal.getDatatype().cppDataType == dependingInput_cpptype:
                raise BaseException(&#39;datatype does not match the one specified in the manifest. (&#39; + (dependingInput_cpptype) + &#39; is required in the manifest)&#39; )

            # append signal
            dependingInputs.append( signal ) 

        return dependingInputs



    # verify the number of outputs of the embedded system
    number_of_outputs_as_described_by_manifest = self.manifest.number_of_default_ouputs

    if not number_of_outputs_as_described_by_manifest == self.Noutputs:
        BaseException(&#34;missmatch in the number of outputs&#34;)

    # get the output datatypes of the embedded system
    self.outputTypes = self.manifest.io_outputs[&#39;calculate_output&#39;][&#39;types&#39;]  


    if self.compileResult is None:
        # collect all depending input signals (that are needed to calculate the output) in a list
        self.inputsToCalculateOutputs = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;calculate_output&#39;] )

        # collect all inputs required to perform the state update
        self.inputsToUpdateStates = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;state_update&#39;] )

    else:
        # use the available compile results to get the I/O signals
        # in this case, self.inputSignals shall be a list of signals. The order
        # shall match the signal order in self.compileResults.inputSignals

        self.inputsToCalculateOutputs = self.compileResult.simulationInputSignalsToCalculateOutputs
        self.inputsToUpdateStates = self.compileResult.simulationInputSignalsToUpdateStates

        

    # combine all inputs to a list
    self.allInputs = list()

    self.allInputs.extend( self.inputsToCalculateOutputs )
    self.allInputs.extend( self.inputsToUpdateStates )

    #
    # now initialize the propotype
    #

    # define the inputs
    self.update_input_config( self.allInputs )

    # connect the outputs signals
    if self.anonymous_output_signals is not None:

        print(&#34; -- Nesting block: connecting anonymous signals -- &#34;)

        Ns = len(self.outputSignals)

        if not Ns == len(  self.anonymous_output_signals ):
            raise BaseException(&#34; missmatch in the number of output signals&#34;)

        for i in range(0,Ns):
            
            s_ananon = self.anonymous_output_signals[i]
            s_source = self.outputSignals[i]

            print(&#34;connecting the output &#34; + s_ananon.toStr() + &#34; of the embedding block&#34;)
            s_ananon.setequal( s_source )



    # for code generation
    self.instanceVarname = self.getUniqueVarnamePrefix() + &#39;_subsystem_&#39; + self.manifest.API_name</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.GenericSubsystem.set_anonymous_output_signal_to_connect"><code class="name flex">
<span>def <span class="ident">set_anonymous_output_signal_to_connect</span></span>(<span>self, anonymous_output_signals)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of anonymous signals to connect to the outputs of the subsystems
after running the post_compile_callback</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_anonymous_output_signal_to_connect(self, anonymous_output_signals):
    &#34;&#34;&#34;
        store a list of anonymous signals to connect to the outputs of the subsystems
        after running the post_compile_callback
    &#34;&#34;&#34;
    # List of raw signals 
    self.anonymous_output_signals = anonymous_output_signals</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.LoopUntilSubsystem"><code class="flex name class">
<span>class <span class="ident">LoopUntilSubsystem</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, max_iteriations: int, subsystem_prototype: <a title="openrtdynamics2.block_prototypes.GenericSubsystem" href="#openrtdynamics2.block_prototypes.GenericSubsystem">GenericSubsystem</a>, until_signal: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a> = None, yield_signal: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Embed a loop sub-system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoopUntilSubsystem(SingleSubsystemEmbedder):
    &#34;&#34;&#34;
        Embed a loop sub-system

    &#34;&#34;&#34;

    def __init__(self, sim : Simulation, max_iteriations : int, 
                    subsystem_prototype : GenericSubsystem, 
                    until_signal : Signal = None, yield_signal : Signal = None ):
        
        self.max_iter = max_iteriations
        self._until_signal = until_signal
        self._yield_signal = yield_signal

        number_of_control_outputs = 0
        if self._until_signal is not None:
            number_of_control_outputs += 1

        if self._yield_signal is not None:
            number_of_control_outputs += 1


        SingleSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[],   # TODO: add N_iter signal here 
                                        subsystem_prototype=subsystem_prototype, 
                                        number_of_control_outputs=number_of_control_outputs )


    # def config_request_define_state_update_input_dependencies(self, outputSignal):
 
    #     return [self._until_signal]

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            # output signal mapping lookup
            ouput_signals_of_subsystem = self.helper_get_output_signal_mapping_to_subsystem(signals_to_calculate=signals)


            ouput_signals_names = cgh.signal_list_to_name_list(signals)
            ouput_signal_names_of_subsystem = cgh.signal_list_to_name_list(ouput_signals_of_subsystem)
            

            loop_break_condition = []

            control_output_index = 0

            if self._until_signal is not None:
                # define tmp-var for self._until_signal instead of a block output
                lines += cgh.defineVariables( [self._until_signal] )

                # add list of signals to assign
                ouput_signals_names.append( self._until_signal.name )
                ouput_signal_names_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index].name )
            
                # add break condition
                loop_break_condition.append( self._until_signal.name )

                control_output_index += 1


            if self._yield_signal is not None:
                # define tmp-var for self._yield_signal instead of a block output
                lines += cgh.defineVariables( [self._yield_signal] )

                # add list of signals to assign
                ouput_signals_names.append( self._yield_signal.name )
                ouput_signal_names_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index].name )

                # add break condition
                loop_break_condition.append( self._yield_signal.name )

                control_output_index += 1


            calc_outputs = cgh.embed_subsystem2(language, 
                        system_prototype=self._subsystem_prototype, 
                        ouput_signals_name=ouput_signals_names, 
                        ouput_signal_names_of_subsystem=ouput_signal_names_of_subsystem,
                        calculate_outputs = True, update_states = False )

            update_states = cgh.embed_subsystem2(language, 
                        system_prototype=self._subsystem_prototype, 
                        calculate_outputs = False, update_states = True )

            code = &#39;&#39;
            code +=  calc_outputs 
            code += update_states

            if self._yield_signal is not None:
                code += cgh.generate_loop_break(language, condition=self._yield_signal.name)

            if self._until_signal is not None:
                code_reset_subsystem = self._subsystem_prototype.generate_code_reset(language)
                code += cgh.generate_loop_break(language, condition=self._until_signal.name, code_before_break=code_reset_subsystem)

            lines += cgh.generate_loop( language, max_iterations=str(self.max_iter), code_to_exec=code  )

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            if self._until_signal is not None:
                pass    
                #lines += self._subsystem_prototype.generate_code_reset(language)


        return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.LoopUntilSubsystem.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        # output signal mapping lookup
        ouput_signals_of_subsystem = self.helper_get_output_signal_mapping_to_subsystem(signals_to_calculate=signals)


        ouput_signals_names = cgh.signal_list_to_name_list(signals)
        ouput_signal_names_of_subsystem = cgh.signal_list_to_name_list(ouput_signals_of_subsystem)
        

        loop_break_condition = []

        control_output_index = 0

        if self._until_signal is not None:
            # define tmp-var for self._until_signal instead of a block output
            lines += cgh.defineVariables( [self._until_signal] )

            # add list of signals to assign
            ouput_signals_names.append( self._until_signal.name )
            ouput_signal_names_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index].name )
        
            # add break condition
            loop_break_condition.append( self._until_signal.name )

            control_output_index += 1


        if self._yield_signal is not None:
            # define tmp-var for self._yield_signal instead of a block output
            lines += cgh.defineVariables( [self._yield_signal] )

            # add list of signals to assign
            ouput_signals_names.append( self._yield_signal.name )
            ouput_signal_names_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index].name )

            # add break condition
            loop_break_condition.append( self._yield_signal.name )

            control_output_index += 1


        calc_outputs = cgh.embed_subsystem2(language, 
                    system_prototype=self._subsystem_prototype, 
                    ouput_signals_name=ouput_signals_names, 
                    ouput_signal_names_of_subsystem=ouput_signal_names_of_subsystem,
                    calculate_outputs = True, update_states = False )

        update_states = cgh.embed_subsystem2(language, 
                    system_prototype=self._subsystem_prototype, 
                    calculate_outputs = False, update_states = True )

        code = &#39;&#39;
        code +=  calc_outputs 
        code += update_states

        if self._yield_signal is not None:
            code += cgh.generate_loop_break(language, condition=self._yield_signal.name)

        if self._until_signal is not None:
            code_reset_subsystem = self._subsystem_prototype.generate_code_reset(language)
            code += cgh.generate_loop_break(language, condition=self._until_signal.name, code_before_break=code_reset_subsystem)

        lines += cgh.generate_loop( language, max_iterations=str(self.max_iter), code_to_exec=code  )

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.LoopUntilSubsystem.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        if self._until_signal is not None:
            pass    
            #lines += self._subsystem_prototype.generate_code_reset(language)


    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.Memory"><code class="flex name class">
<span>class <span class="ident">Memory</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, datatype, constant_array, write_index: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a> = None, value: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Memory(bi.BlockPrototype):
    def __init__(self, sim : Simulation, datatype, constant_array, write_index : Signal = None, value : Signal = None ):

        self._constant_array = constant_array
        self._length         = len(constant_array)
        self._array_datatype = dt.DataTypeArray( self._length, datatype )

        if write_index is None:
            self._static = True
        elif value is not None:
            self._static = False
        else:
            raise BaseException(&#39;Memory: write_index was defined but no value to write&#39;)

        # call super
        if self._static:
            bi.BlockPrototype.__init__(self, sim, inputSignals = [], N_outputs = 1, output_datatype_list = [self._array_datatype]  )
        else:
            bi.BlockPrototype.__init__(self, sim, inputSignals = [write_index, value], N_outputs = 1, output_datatype_list = [self._array_datatype]  )

        # indicate that the output of this port is passed by reference in c++
        self.outputs[0].set_is_referencing_memory(True)

        self.outputs[0].properties_internal[&#39;memory_length&#39;] = self._length

    # TODO: not sure if this is ever beeing called as the output datatypes are already specified in the constructor
    def config_request_define_output_types(self, inputTypes):
        # define the output type 
        return [ self._array_datatype ]

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # the output depends on nothing
        return []
            
    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states

        if self._static:
            return []  # no states
        else:
            return [self.inputs[0], self.inputs[1]]

    #
    # code gen
    #

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:

            # encode the given data and initialize a C array
            csv_array = &#39;,&#39;.join([str(x) for x in self._constant_array])
            return self._array_datatype.cpp_define_variable(  self.getUniqueVarnamePrefix() + &#39;_array&#39; ) + &#39; {&#39; + csv_array + &#39;};\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            # place a reference
            return cgh.defineVariable( signals[0], make_a_reference=True ) + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_array&#39; + &#39;;\n&#39;

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            if self._static:
                return &#39;&#39;

            code = &#39;&#39; +  self.inputs[0].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

            code += self.getUniqueVarnamePrefix() + &#39;_array[tmp] = &#39; + self.inputs[1].name + &#39;;\n&#39;

            return cgh.brackets(code)

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:
            # TODO
            return &#39;// WARNIG: reset of memory not implemented\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.Memory.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):
    # define the output type 
    return [ self._array_datatype ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Memory.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        # place a reference
        return cgh.defineVariable( signals[0], make_a_reference=True ) + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_array&#39; + &#39;;\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Memory.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:
        # TODO
        return &#39;// WARNIG: reset of memory not implemented\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.Memory.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):
    if language == &#39;c++&#39;:

        if self._static:
            return &#39;&#39;

        code = &#39;&#39; +  self.inputs[0].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
        code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
        code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

        code += self.getUniqueVarnamePrefix() + &#39;_array[tmp] = &#39; + self.inputs[1].name + &#39;;\n&#39;

        return cgh.brackets(code)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.MemoryRead"><code class="flex name class">
<span>class <span class="ident">MemoryRead</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, memory: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, index: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryRead(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, memory : Signal, index : Signal ):

        if &#39;memory_length&#39; not in memory.properties_internal:
            raise BaseException(&#39;No property memory_length in input signal. Please create the input signal using memory()&#39;)

        self._length = memory.properties_internal[&#39;memory_length&#39;]

        # print(&#39; ############# reading a memory of length&#39;, self._length)

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [memory, index] )

    def config_request_define_output_types(self, inputTypes):
        # returt the datatype of the array elements
        return [ self.inputs[0].getDatatype().datatype_of_elements ]  

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:

            code = &#39;&#39; +  self.inputs[1].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[1].name + &#39;;\n&#39;
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

            code += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;[tmp];\n&#39;
            
            return cgh.brackets(code)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.MemoryRead.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):
    # returt the datatype of the array elements
    return [ self.inputs[0].getDatatype().datatype_of_elements ]  </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.MemoryRead.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:

        code = &#39;&#39; +  self.inputs[1].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[1].name + &#39;;\n&#39;
        code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
        code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

        code += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;[tmp];\n&#39;
        
        return cgh.brackets(code)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder"><code class="flex name class">
<span>class <span class="ident">MultiSubsystemEmbedder</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, control_inputs: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>], subsystem_prototypes: List[<a title="openrtdynamics2.block_prototypes.GenericSubsystem" href="#openrtdynamics2.block_prototypes.GenericSubsystem">GenericSubsystem</a>], switch_reference_outputs: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>], number_of_control_outputs: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Prototype for a block that includes multiple sub-systems whose outputs are joint in a switching manner
(this is class to be derived, e.g. by StatemachineSwichSubsystems, SwichSubsystems)</p>
<ul>
<li>control_inputs
- inputs used to control the switching strategy</li>
<li>subsystem_prototypes
- a list of the prototypes of all subsystems (of type GenericSubsystem)</li>
<li>switch_reference_outputs
- output signals of the reference subsystem from which the output datatypes are inherited</li>
<li>
<p>number_of_control_outputs
- the number of outputs of the subsystems used to control the execution</p>
</li>
<li>
<p>helper function for code generation -</p>
</li>
<li>
<p>self.generate_switch(), generate_reset()</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiSubsystemEmbedder(bi.BlockPrototype):
    &#34;&#34;&#34;
        Prototype for a block that includes multiple sub-systems whose outputs are joint in a switching manner
          (this is class to be derived, e.g. by StatemachineSwichSubsystems, SwichSubsystems)

        - control_inputs                        - inputs used to control the switching strategy
        - subsystem_prototypes                  - a list of the prototypes of all subsystems (of type GenericSubsystem)
        - switch_reference_outputs              - output signals of the reference subsystem from which the output datatypes are inherited
        - number_of_control_outputs             - the number of outputs of the subsystems used to control the execution

        - helper function for code generation -

        - self.generate_switch(), generate_reset()
    &#34;&#34;&#34;
    def __init__(self, sim : Simulation, control_inputs : List [Signal], subsystem_prototypes : List [GenericSubsystem], switch_reference_outputs : List [Signal], number_of_control_outputs : int = 0 ):

        # a list of the prototypes of all subsystems
        self._subsystem_prototypes = subsystem_prototypes
        
        # analyze the default subsystem (the first) to get the output datatypes to use
        reference_subsystem = self._subsystem_prototypes[0]

        # the number of outputs besides the subsystems outputs
        self._number_of_control_outputs = number_of_control_outputs

        self._total_number_of_subsystem_outputs = len(reference_subsystem.outputs)
        self._number_of_switched_outputs = len(switch_reference_outputs)

        if self._number_of_switched_outputs + number_of_control_outputs != self._total_number_of_subsystem_outputs:
            raise BaseException(&#34;given number of total subsystem outputs does not match&#34;)

        self._number_of_outputs_of_all_nested_systems = len(reference_subsystem.outputs)

        # assertion
        for subsystem_prototype in self._subsystem_prototypes:
            if not len(subsystem_prototype.outputs) == self._total_number_of_subsystem_outputs:
                raise BaseException(&#34;all subsystems must have the same number of outputs&#34;)


        # now call the constructor for block prototypes and make input and output signals available
        bi.BlockPrototype.__init__(self, sim=sim, inputSignals=None, N_outputs = self._total_number_of_subsystem_outputs )



        # control inputs that are used to control how the subsystems are handled
        self._control_inputs = control_inputs 

        # a list of all inputs used by all subsystems
        self._list_of_all_subsystem_inputs = None

        # a list of all inputs including self._list_of_all_subsystem_inputs and self._control_inputs
        # will be filled in on compile_callback_all_subsystems_compiled()
        self._list_of_all_inputs = None

        # inherit output datatypes of the reference subsystem
        for i in range(0, self._number_of_switched_outputs ):

            output_signal_of_embedding_block = self.outputs[i]
            output_signal_of_subsystem = switch_reference_outputs[i]
            output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

        # NOTE: datatypes for control outputs are untouched

    @property
    def additional_outputs(self):
        return self.outputs[ self._number_of_switched_outputs: ]

    @property
    def subsystem_switch_outouts(self):
        return self.outputs[ 0:self._number_of_switched_outputs ]


    def compile_callback_all_subsystems_compiled(self):

        # Get all input signals required by the subsystems and avoid duplicates. 
        # Go through each subsystem in self._subsystem_prototypes and collect all input signals
        # in a set.
        set_of_all_inputs = set()

        for subsystem_prototype in self._subsystem_prototypes:
            set_of_all_inputs.update( subsystem_prototype.inputs )

        self._list_of_all_subsystem_inputs = list( set_of_all_inputs )

        # add additional inputs
        set_of_all_inputs.update( self._control_inputs )

        self._list_of_all_inputs = list(set_of_all_inputs)
            


    def compile_callback_all_datatypes_defined(self):
        pass



    def config_request_define_feedforward_input_dependencies(self, outputSignal):

        # NOTE: This is a simplified veriant so far..
        #       Every output depends on every signal

        return self._list_of_all_inputs
        

    def config_request_define_state_update_input_dependencies(self, outputSignal):
 
        # NOTE: This is a simplified veriant so far..
        #       The update depends on every signal

        return self._list_of_all_inputs



    # for code_gen
    def generate_switch( self, language, switch_control_signal_name, switch_ouput_signals_name=None, calculate_outputs = True, update_states = False, additional_outputs_names=None ):
        &#34;&#34;&#34;
            code generation helper to embed multiple subsystems and a switch for the outputs
        &#34;&#34;&#34;

        lines = &#39;&#39;

        action_list = []
        condition_list = []

        subsystem_counter = 0
        for system_prototype in self._subsystem_prototypes:

            if calculate_outputs:
                # combine all output names to one list: normal subsystem outputs and control outputs
                ouput_signals_name = []
                ouput_signals_name.extend( switch_ouput_signals_name )
                ouput_signals_name.extend( additional_outputs_names )

                # call each subsystem embedder to generate its code
                code_calculate_outputs = cgh.embed_subsystem( language, system_prototype, ouput_signals_name=ouput_signals_name)
            else:
                code_calculate_outputs = &#39;&#39; # no operation


            if update_states:
                # call each subsystem embedder to generate its update code
                code_update_states = cgh.embed_subsystem( language, system_prototype, calculate_outputs=False, update_states=True)
            else:
                code_update_states = &#39;&#39; # no operation

            action_list.append( code_calculate_outputs + code_update_states )

            # generate conditions when to execute the respective subsystem 
            condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

            subsystem_counter += 1

        # combine conditions and their repective actions
        lines += cgh.generate_if_else(language, condition_list, action_list)

        return lines


    
    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:

            # implement state definition for each subsystem
            lines = &#39;&#39;
            for system_prototype in self._subsystem_prototypes:
                lines += system_prototype.generate_code_defStates(language)

            return lines

    def generate_reset(self, language, system_index):
        &#34;&#34;&#34;
            helper fn for code generation
        &#34;&#34;&#34;

        system_to_reset = self._subsystem_prototypes[ system_index ]

        lines = system_to_reset.generate_code_reset(language)

        return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            # reset all subsystems
            lines = &#39;// reset state of all subsystems in multisubsystem &#39; + self.name + &#39;\n&#39;
            for system_prototype in self._subsystem_prototypes:
                lines += system_prototype.generate_code_reset(language)

            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems" href="#openrtdynamics2.block_prototypes.StatemachineSwichSubsystems">StatemachineSwichSubsystems</a></li>
<li><a title="openrtdynamics2.block_prototypes.SwichSubsystems" href="#openrtdynamics2.block_prototypes.SwichSubsystems">SwichSubsystems</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.additional_outputs"><code class="name">var <span class="ident">additional_outputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def additional_outputs(self):
    return self.outputs[ self._number_of_switched_outputs: ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.subsystem_switch_outouts"><code class="name">var <span class="ident">subsystem_switch_outouts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def subsystem_switch_outouts(self):
    return self.outputs[ 0:self._number_of_switched_outputs ]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:

        # reset all subsystems
        lines = &#39;// reset state of all subsystems in multisubsystem &#39; + self.name + &#39;\n&#39;
        for system_prototype in self._subsystem_prototypes:
            lines += system_prototype.generate_code_reset(language)

        return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_reset"><code class="name flex">
<span>def <span class="ident">generate_reset</span></span>(<span>self, language, system_index)</span>
</code></dt>
<dd>
<div class="desc"><p>helper fn for code generation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_reset(self, language, system_index):
    &#34;&#34;&#34;
        helper fn for code generation
    &#34;&#34;&#34;

    system_to_reset = self._subsystem_prototypes[ system_index ]

    lines = system_to_reset.generate_code_reset(language)

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_switch"><code class="name flex">
<span>def <span class="ident">generate_switch</span></span>(<span>self, language, switch_control_signal_name, switch_ouput_signals_name=None, calculate_outputs=True, update_states=False, additional_outputs_names=None)</span>
</code></dt>
<dd>
<div class="desc"><p>code generation helper to embed multiple subsystems and a switch for the outputs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_switch( self, language, switch_control_signal_name, switch_ouput_signals_name=None, calculate_outputs = True, update_states = False, additional_outputs_names=None ):
    &#34;&#34;&#34;
        code generation helper to embed multiple subsystems and a switch for the outputs
    &#34;&#34;&#34;

    lines = &#39;&#39;

    action_list = []
    condition_list = []

    subsystem_counter = 0
    for system_prototype in self._subsystem_prototypes:

        if calculate_outputs:
            # combine all output names to one list: normal subsystem outputs and control outputs
            ouput_signals_name = []
            ouput_signals_name.extend( switch_ouput_signals_name )
            ouput_signals_name.extend( additional_outputs_names )

            # call each subsystem embedder to generate its code
            code_calculate_outputs = cgh.embed_subsystem( language, system_prototype, ouput_signals_name=ouput_signals_name)
        else:
            code_calculate_outputs = &#39;&#39; # no operation


        if update_states:
            # call each subsystem embedder to generate its update code
            code_update_states = cgh.embed_subsystem( language, system_prototype, calculate_outputs=False, update_states=True)
        else:
            code_update_states = &#39;&#39; # no operation

        action_list.append( code_calculate_outputs + code_update_states )

        # generate conditions when to execute the respective subsystem 
        condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

        subsystem_counter += 1

    # combine conditions and their repective actions
    lines += cgh.generate_if_else(language, condition_list, action_list)

    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.Operator0"><code class="flex name class">
<span>class <span class="ident">Operator0</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, u: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, operator_str: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Operator0(bi.StaticFn_1To1):
    def __init__(self, sim : Simulation, u : Signal, operator_str : str ):

        self._operator_str = operator_str

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._operator_str) + self.inputs[0].name +  &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_1To1">StaticFn_1To1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.Operator0.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + str(self._operator_str) + self.inputs[0].name +  &#39;;\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_1To1">StaticFn_1To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.Operator1"><code class="flex name class">
<span>class <span class="ident">Operator1</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, inputSignals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>], operator: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Operator1(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, inputSignals : List[Signal], operator : str ):

        self.operator = operator
        bi.StaticFn_NTo1.__init__(self, sim, inputSignals)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            strs = []
            i = 0
            for s in self.inputSignals:
                strs.append(  str(  s.name ) )
                i = i + 1

            sumline = (&#39; &#39; + self.operator + &#39; &#39;).join( strs )
            lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.Operator1.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        strs = []
        i = 0
        for s in self.inputSignals:
            strs.append(  str(  s.name ) )
            i = i + 1

        sumline = (&#39; &#39; + self.operator + &#39; &#39;).join( strs )
        lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder"><code class="flex name class">
<span>class <span class="ident">SingleSubsystemEmbedder</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, control_inputs: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>], subsystem_prototype: <a title="openrtdynamics2.block_prototypes.GenericSubsystem" href="#openrtdynamics2.block_prototypes.GenericSubsystem">GenericSubsystem</a>, number_of_control_outputs: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Prototype for a block that includes one sub-system
(this is class to be derived, e.g. by XX, XX)</p>
<ul>
<li>control_inputs
- inputs used to control the execution (e.g. the condition for if)</li>
<li>subsystem_prototype
- the prototypes the subsystem (of type GenericSubsystem)</li>
<li>reference_outputs
- output signals of the reference subsystem from which the output datatypes are inherited</li>
<li>
<p>number_of_control_outputs
- the number of outputs of the subsystem used to control execution</p>
</li>
<li>
<p>helper function for code generation -</p>
</li>
<li>
<p>XX</p>
<pre><code>        +--------------------------------------------------+
        | SingleSubsystemEmbedder                          |
        |                       +-------------+            |
</code></pre>
<p>normal input 1
|
|
|
|
normal output 1
+-------------------------&gt;+
+---------------&gt;
|
|
embeded
|
|
normal input 2
|
|
|
|
normal output 2
+-------------------------&gt;+
+---------------&gt;
|
|
subsystem
|
|
|
control status |
| control
|
|
+---------&gt;+
+-----+
|
|
|
|
| output
|
|
|
+-------------+
|
|
|
|
|
|
|
+------+------+
|
|
control input
|
|
execution
|
|
|
+-------&gt;+
control of +&lt;----------------------+
|
|
|
subsystem
|
|
|
+-------------+
|
|
|
+--------------------------------------------------+</p>
</li>
</ul>
<p>Picture drawn by <a href="http://asciiflow.com/">http://asciiflow.com/</a></p>
<h2 id="lists-of-output-signals">Lists Of Output Signals</h2>
<p>self.outputs
- all outputs of the embeding block
self._subsystem_prototype.outputs
- all outputs of the subsystem that are initialily present
self._subsystem_prototype.compileResult.outputSignals
- all outputs of the subsystem that are present after compilation
signals (parameter for generate_code_output_list)
- outputs out of self.outputs that need to be computed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingleSubsystemEmbedder(bi.BlockPrototype):
    &#34;&#34;&#34;
        Prototype for a block that includes one sub-system
          (this is class to be derived, e.g. by XX, XX)

        - control_inputs                        - inputs used to control the execution (e.g. the condition for if)
        - subsystem_prototype                   - the prototypes the subsystem (of type GenericSubsystem)
        - reference_outputs                     - output signals of the reference subsystem from which the output datatypes are inherited
        - number_of_control_outputs             - the number of outputs of the subsystem used to control execution

        - helper function for code generation -

        - XX

                         
                        +--------------------------------------------------+
                        | SingleSubsystemEmbedder                          |
                        |                       +-------------+            |
        normal input 1  |                       |             |            |  normal output 1
                     +-------------------------&gt;+             +---------------&gt;
                        |                       |   embeded   |            |
        normal input 2  |                       |             |            |  normal output 2
                     +-------------------------&gt;+             +---------------&gt;
                        |                       |  subsystem  |            |
                        |        control status |             | control    |
                        |            +---------&gt;+             +-----+      |
                        |            |          |             | output     |
                        |            |          +-------------+     |      |
                        |            |                              |      |
                        |     +------+------+                       |      |
        control input   |     |  execution  |                       |      |
                     +-------&gt;+  control of +&lt;----------------------+      |
                        |     |  subsystem  |                              |
                        |     +-------------+                              |
                        |                                                  |
                        +--------------------------------------------------+

        Picture drawn by http://asciiflow.com/



        lists of output signals
        -----------------------

        self.outputs                                           - all outputs of the embeding block
        self._subsystem_prototype.outputs                      - all outputs of the subsystem that are initialily present
        self._subsystem_prototype.compileResult.outputSignals  - all outputs of the subsystem that are present after compilation
        signals (parameter for generate_code_output_list)      - outputs out of self.outputs that need to be computed

    &#34;&#34;&#34;
    def __init__(self, sim : Simulation, control_inputs : List [Signal], subsystem_prototype : GenericSubsystem, number_of_control_outputs : int = 0 ):

        # the prototypes of the subsystem
        self._subsystem_prototype = subsystem_prototype
        
        # analyze the default subsystem (the first) to get the output datatypes to use
        reference_subsystem = self._subsystem_prototype

        # the number of outputs besides the subsystems outputs
        self._number_of_control_outputs = number_of_control_outputs

        self._total_number_of_subsystem_outputs = len(reference_subsystem.outputs)
        self._number_of_normal_outputs = len(self._subsystem_prototype.outputs) - number_of_control_outputs

        if self._number_of_normal_outputs &lt; 0:
            raise BaseException(&#34;The number of control outputs is higher than the toal number of outputs provided by the subsystem.&#34;)

        self._number_of_outputs_of_all_nested_systems = len(reference_subsystem.outputs)



        # now call the constructor for block prototypes and make input and output signals available
        bi.BlockPrototype.__init__(self, sim=sim, inputSignals=None, N_outputs = self._number_of_normal_outputs )



        # control inputs that are used to control how the subsystems are handled
        self._control_inputs = control_inputs 


        # a list of all inputs including self._list_of_all_subsystem_inputs and self._control_inputs
        # will be filled in on compile_callback_all_subsystems_compiled()
        self._list_of_all_inputs = None


        # output sigal mapping: map each output of SingleSubsystemEmbedder to an output of the subsystem
        self._output_signal_mapping = {} # (TODO: extend/add to MultiSubsystemEmbedder)

        # inherit output datatypes of this block from the embeded subsystem
        for i in range(0, self._number_of_normal_outputs ):

            # fill in mapping table
            self._output_signal_mapping[ self.outputs[i] ] = self._subsystem_prototype.outputs[i]

            output_signal_of_embedding_block = self.outputs[i]
            output_signal_of_subsystem = self._subsystem_prototype.outputs[i] # reference_outputs[i]
            output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

            #output_signal_of_embedding_block.set_data_link( output_signal_of_subsystem )

        # build a list of control signals (TODO: add to MultiSubsystemEmbedder)
        self._control_signals_from_embeded_system = []
        
        # iterate over the control outputs of the embedded subsystem
        for i in range(self._number_of_normal_outputs, self._number_of_normal_outputs + self._number_of_control_outputs ):
            self._control_signals_from_embeded_system.append( self._subsystem_prototype.outputs[i] )


    @property
    def additional_outputs(self):
        return self.outputs[ self._number_of_normal_outputs: ]

    @property
    def normal_outouts(self):
        return self.outputs[ 0:self._number_of_normal_outputs ]


    def compile_callback_all_subsystems_compiled(self):

        # Get all input signals required by the subsystem
        set_of_all_inputs = set()
        set_of_all_inputs.update( self._subsystem_prototype.inputs )

        # add the control inputs
        set_of_all_inputs.update( self._control_inputs )

        self._list_of_all_inputs = list(set_of_all_inputs)

    def compile_callback_all_datatypes_defined(self):
        pass


    def config_request_define_feedforward_input_dependencies(self, outputSignal):

        # NOTE: This is a simplified veriant so far..
        #       Every output depends on every signal

        return self._list_of_all_inputs
        

    def config_request_define_state_update_input_dependencies(self, outputSignal):
 
        # NOTE: This is a simplified veriant so far..
        #       The update depends on every signal

        return self._list_of_all_inputs


    def helper_get_output_signal_mapping_to_subsystem(self, signals_to_calculate):

        mapped_subsystem_output_signals = []
        for s in signals_to_calculate:
            mapped_subsystem_output_signals.append( self._output_signal_mapping[s] )

        return mapped_subsystem_output_signals
    
    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:

            lines = &#39;&#39;
            lines += self._subsystem_prototype.generate_code_defStates(language)

            return lines


    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:


            lines = &#39;// reset state of subsystem embeded by &#39; + self.name + &#39;\n&#39;
            lines += self._subsystem_prototype.generate_code_reset(language)

            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_prototypes.LoopUntilSubsystem" href="#openrtdynamics2.block_prototypes.LoopUntilSubsystem">LoopUntilSubsystem</a></li>
<li><a title="openrtdynamics2.block_prototypes.TruggeredSubsystem" href="#openrtdynamics2.block_prototypes.TruggeredSubsystem">TruggeredSubsystem</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.additional_outputs"><code class="name">var <span class="ident">additional_outputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def additional_outputs(self):
    return self.outputs[ self._number_of_normal_outputs: ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.normal_outouts"><code class="name">var <span class="ident">normal_outouts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def normal_outouts(self):
    return self.outputs[ 0:self._number_of_normal_outputs ]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:


        lines = &#39;// reset state of subsystem embeded by &#39; + self.name + &#39;\n&#39;
        lines += self._subsystem_prototype.generate_code_reset(language)

        return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.helper_get_output_signal_mapping_to_subsystem"><code class="name flex">
<span>def <span class="ident">helper_get_output_signal_mapping_to_subsystem</span></span>(<span>self, signals_to_calculate)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def helper_get_output_signal_mapping_to_subsystem(self, signals_to_calculate):

    mapped_subsystem_output_signals = []
    for s in signals_to_calculate:
        mapped_subsystem_output_signals.append( self._output_signal_mapping[s] )

    return mapped_subsystem_output_signals</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems"><code class="flex name class">
<span>class <span class="ident">StatemachineSwichSubsystems</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, subsystem_prototypes: List[<a title="openrtdynamics2.block_prototypes.GenericSubsystem" href="#openrtdynamics2.block_prototypes.GenericSubsystem">GenericSubsystem</a>], reference_outputs: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatemachineSwichSubsystems(MultiSubsystemEmbedder):
    &#34;&#34;&#34;

    &#34;&#34;&#34;

    def __init__(self, sim : Simulation, subsystem_prototypes : List [GenericSubsystem], reference_outputs : List [Signal] ):
        
        MultiSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[], 
                                        subsystem_prototypes=subsystem_prototypes, 
                                        switch_reference_outputs=reference_outputs,
                                        number_of_control_outputs = 1 )

        # how to add more outputs?
        self.state_output.setDatatype( dt.DataTypeInt32(1) )

        # this output signals must be compted in any way
        # also in case it is not used by other blocks
        sim.add_signal_mandatory_to_compute( self.state_output )


    @property
    def state_output(self):
        return self.additional_outputs[0]


    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            lines = self._state_memory + &#39; = 0;\n&#39; # add something

            lines += MultiSubsystemEmbedder.generate_code_reset(self, language)

            return lines


    def generate_code_defStates(self, language):
        lines = MultiSubsystemEmbedder.generate_code_defStates(self, language)

        self._state_memory = self.getUniqueVarnamePrefix() + &#39;state&#39;
        lines += &#39;int &#39; + self._state_memory + &#39; {0};&#39;
        
        return lines


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            # do not compute all swich outputs, just the ones requested by &#39;signals&#39; 
            outputs_to_compute = []
            for s in signals:
                if s in self.subsystem_switch_outouts:
                    outputs_to_compute.append( s )


            # lines += cgh.defineVariables( signals ) + &#39;\n&#39;
            lines += self.generate_switch( language=language, 
                                            switch_control_signal_name=  self._state_memory ,
                                            switch_ouput_signals_name=cgh.signal_list_to_name_list(outputs_to_compute),
                                            additional_outputs_names=[self.state_output.name] )

            # lines += self.state_output.name + &#39; = &#39; + self._state_memory_delayed + &#39;;\n&#39;

        return lines


    # code_gen helper
    def generate_switch_to_reset_leaving_subsystem( self, language, switch_control_signal_name ):

        lines = &#39;&#39;

        action_list = []
        condition_list = []

        subsystem_counter = 0
        for system_prototype in self._subsystem_prototypes:

            code_reset_states = MultiSubsystemEmbedder.generate_reset( self, language, system_index=subsystem_counter ) 

            action_list.append(  code_reset_states )

            # generate conditions when to execute the respective subsystem 
            condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

            subsystem_counter += 1

        # combine conditions and their repective actions
        lines += cgh.generate_if_else(language, condition_list, action_list)

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            lines += self.generate_switch( language=language, 
                                                    switch_control_signal_name=self._state_memory,
                                                    calculate_outputs=False, 
                                                    update_states=True )


            # get the signal issued by the currently active subsystem that describes state chanhe requests
            state_control_signal_from_subsystems = self.state_output

            # reset current subsystem in case a state transition is requested
            lines_reset_subsystem = self.generate_switch_to_reset_leaving_subsystem(language, self._state_memory )
            lines += cgh.generate_if_else(language, condition_list=[ state_control_signal_from_subsystems.name + &#39; &gt;= 0 &#39; ], action_list=[lines_reset_subsystem])

            # transition to the new state
            lines += self._state_memory + &#39; = (&#39; + state_control_signal_from_subsystems.name + &#39; &gt;= 0 ) ? (&#39;+ state_control_signal_from_subsystems.name + &#39;) : (&#39; + self._state_memory + &#39;);\n&#39;
            
        return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.state_output"><code class="name">var <span class="ident">state_output</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_output(self):
    return self.additional_outputs[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        # do not compute all swich outputs, just the ones requested by &#39;signals&#39; 
        outputs_to_compute = []
        for s in signals:
            if s in self.subsystem_switch_outouts:
                outputs_to_compute.append( s )


        # lines += cgh.defineVariables( signals ) + &#39;\n&#39;
        lines += self.generate_switch( language=language, 
                                        switch_control_signal_name=  self._state_memory ,
                                        switch_ouput_signals_name=cgh.signal_list_to_name_list(outputs_to_compute),
                                        additional_outputs_names=[self.state_output.name] )

        # lines += self.state_output.name + &#39; = &#39; + self._state_memory_delayed + &#39;;\n&#39;

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:

        lines = self._state_memory + &#39; = 0;\n&#39; # add something

        lines += MultiSubsystemEmbedder.generate_code_reset(self, language)

        return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:
        lines += self.generate_switch( language=language, 
                                                switch_control_signal_name=self._state_memory,
                                                calculate_outputs=False, 
                                                update_states=True )


        # get the signal issued by the currently active subsystem that describes state chanhe requests
        state_control_signal_from_subsystems = self.state_output

        # reset current subsystem in case a state transition is requested
        lines_reset_subsystem = self.generate_switch_to_reset_leaving_subsystem(language, self._state_memory )
        lines += cgh.generate_if_else(language, condition_list=[ state_control_signal_from_subsystems.name + &#39; &gt;= 0 &#39; ], action_list=[lines_reset_subsystem])

        # transition to the new state
        lines += self._state_memory + &#39; = (&#39; + state_control_signal_from_subsystems.name + &#39; &gt;= 0 ) ? (&#39;+ state_control_signal_from_subsystems.name + &#39;) : (&#39; + self._state_memory + &#39;);\n&#39;
        
    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_switch_to_reset_leaving_subsystem"><code class="name flex">
<span>def <span class="ident">generate_switch_to_reset_leaving_subsystem</span></span>(<span>self, language, switch_control_signal_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_switch_to_reset_leaving_subsystem( self, language, switch_control_signal_name ):

    lines = &#39;&#39;

    action_list = []
    condition_list = []

    subsystem_counter = 0
    for system_prototype in self._subsystem_prototypes:

        code_reset_states = MultiSubsystemEmbedder.generate_reset( self, language, system_index=subsystem_counter ) 

        action_list.append(  code_reset_states )

        # generate conditions when to execute the respective subsystem 
        condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

        subsystem_counter += 1

    # combine conditions and their repective actions
    lines += cgh.generate_if_else(language, condition_list, action_list)

    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_reset" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_reset">generate_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_switch" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_switch">generate_switch</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.StaticFnByName_1To1"><code class="flex name class">
<span>class <span class="ident">StaticFnByName_1To1</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, u: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, functionName: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StaticFnByName_1To1(bi.StaticFn_1To1):
    def __init__(self, sim : Simulation, u : Signal, functionName : str ):

        self._functionName = functionName

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._functionName) + &#39;(&#39; + self.inputs[0].name +  &#39;);\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_1To1">StaticFn_1To1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.StaticFnByName_1To1.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + str(self._functionName) + &#39;(&#39; + self.inputs[0].name +  &#39;);\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_1To1">StaticFn_1To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_1To1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.StaticFnByName_2To1"><code class="flex name class">
<span>class <span class="ident">StaticFnByName_2To1</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, left: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, right: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, function_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StaticFnByName_2To1(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, left : Signal, right : Signal, function_name : str ):

        self._function_name = function_name

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [left, right])

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = signals[0].name + &#39; = &#39; + self._function_name + &#39;(&#39; + self.inputSignals[0].name +  &#39;, &#39; + self.inputSignals[1].name + &#39;)&#39; + &#39;;\n&#39;
            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.StaticFnByName_2To1.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        lines = signals[0].name + &#39; = &#39; + self._function_name + &#39;(&#39; + self.inputSignals[0].name +  &#39;, &#39; + self.inputSignals[1].name + &#39;)&#39; + &#39;;\n&#39;
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.SwichSubsystems"><code class="flex name class">
<span>class <span class="ident">SwichSubsystems</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, control_input: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, subsystem_prototypes: List[<a title="openrtdynamics2.block_prototypes.GenericSubsystem" href="#openrtdynamics2.block_prototypes.GenericSubsystem">GenericSubsystem</a>], reference_outputs: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>A system that includes multiple subsystems and a control input to switch in-between
The outputs of the currently acrive subsystem are forwarded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwichSubsystems(MultiSubsystemEmbedder):
    &#34;&#34;&#34;
        A system that includes multiple subsystems and a control input to switch in-between
        The outputs of the currently acrive subsystem are forwarded.
    &#34;&#34;&#34;

    def __init__(self, sim : Simulation, control_input : Signal, subsystem_prototypes : List [GenericSubsystem], reference_outputs : List [Signal] ):
        
        self._control_input = control_input

        MultiSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[control_input], 
                                        subsystem_prototypes=subsystem_prototypes, 
                                        switch_reference_outputs=reference_outputs,
                                        number_of_control_outputs=0 )


    def generate_code_defStates(self, language):
        lines = MultiSubsystemEmbedder.generate_code_defStates(self, language)
        lines += &#39;&#39; # add something
        
        return lines


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            
            # the method self.generate_switch is provided by MultiSubsystemEmbedder 
            lines += self.generate_switch( language=language, 
                                            switch_control_signal_name=self._control_input.name,
                                            switch_ouput_signals_name= cgh.signal_list_to_name_list(signals),
                                             calculate_outputs = True, update_states = False )

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            lines += self.generate_switch( language=language, 
                                                    switch_control_signal_name=self._control_input.name,
                                                     calculate_outputs = False, update_states = True )

        return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.SwichSubsystems.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:
        
        # the method self.generate_switch is provided by MultiSubsystemEmbedder 
        lines += self.generate_switch( language=language, 
                                        switch_control_signal_name=self._control_input.name,
                                        switch_ouput_signals_name= cgh.signal_list_to_name_list(signals),
                                         calculate_outputs = True, update_states = False )

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.SwichSubsystems.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:
        lines += self.generate_switch( language=language, 
                                                switch_control_signal_name=self._control_input.name,
                                                 calculate_outputs = False, update_states = True )

    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_reset" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_reset">generate_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_switch" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_switch">generate_switch</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.SwitchNto1"><code class="flex name class">
<span>class <span class="ident">SwitchNto1</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, state: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, inputs: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwitchNto1(bi.StaticFn_NTo1):
    def __init__(self, sim : Simulation, state : Signal, inputs : List [Signal] ):

        self.inputs = inputs
        self.state = state

        inputSignals = [state]
        inputSignals.extend(inputs)

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals )

    def config_request_define_output_types(self, inputTypes):

        # check weather the trigger input is int32
        if inputTypes[0] is not None:
            if dt.DataTypeInt32(1).isEqualTo( inputTypes[0] ) == 0:
                raise BaseException(&#39;state input must be of type Int32&#39;)  

        # determine a guess for the output datatype
        # check if all given datatypes are equal
        autoDatatype = autoDatatype_Nto1(self.outputs[0].getDatatype(), inputTypes[1:-1] )

        return [ autoDatatype ]

    #def generate_code_output(self, language, signal : Signal):
    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = &#39;\n// switch &#39; + str(len(self.inputs)) + &#39; inputs --&gt; &#39; + self.state.name + &#39;\n&#39;
            i = 1
            for ip in self.inputs:
                if i == 1:
                    lines += &#39;if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;
                else:
                    lines += &#39;else if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;

                lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + ip.name + &#39;;\n&#39;
                lines += &#39;} &#39;

                i += 1

            lines += &#39;else {\n&#39;
            lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            lines += &#39;}\n&#39;
            
            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.SwitchNto1.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # check weather the trigger input is int32
    if inputTypes[0] is not None:
        if dt.DataTypeInt32(1).isEqualTo( inputTypes[0] ) == 0:
            raise BaseException(&#39;state input must be of type Int32&#39;)  

    # determine a guess for the output datatype
    # check if all given datatypes are equal
    autoDatatype = autoDatatype_Nto1(self.outputs[0].getDatatype(), inputTypes[1:-1] )

    return [ autoDatatype ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.SwitchNto1.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        lines = &#39;\n// switch &#39; + str(len(self.inputs)) + &#39; inputs --&gt; &#39; + self.state.name + &#39;\n&#39;
        i = 1
        for ip in self.inputs:
            if i == 1:
                lines += &#39;if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;
            else:
                lines += &#39;else if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;

            lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + ip.name + &#39;;\n&#39;
            lines += &#39;} &#39;

            i += 1

        lines += &#39;else {\n&#39;
        lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
        lines += &#39;}\n&#39;
        
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.block_prototypes.TruggeredSubsystem"><code class="flex name class">
<span>class <span class="ident">TruggeredSubsystem</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.libdyn.Simulation" href="libdyn.html#openrtdynamics2.libdyn.Simulation">Simulation</a>, control_input: <a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>, subsystem_prototype: <a title="openrtdynamics2.block_prototypes.GenericSubsystem" href="#openrtdynamics2.block_prototypes.GenericSubsystem">GenericSubsystem</a>, prevent_output_computation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Include a triggered sub-system</p>
<h2 id="optional">Optional</h2>
<p>prevent_output_computation = True:
The subsystems outputs are only computed when triggered. Please note that the outputs
of the subsystem are uninitialized until the subsystem is triggered for the first time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TruggeredSubsystem(SingleSubsystemEmbedder):
    &#34;&#34;&#34;
        Include a triggered sub-system

        Optional:

            prevent_output_computation = True: 
                The subsystems outputs are only computed when triggered. Please note that the outputs
                of the subsystem are uninitialized until the subsystem is triggered for the first time.

    &#34;&#34;&#34;


    def __init__(self, sim : Simulation, control_input : Signal, subsystem_prototype : GenericSubsystem,  prevent_output_computation = False ):
        
        self._control_input = control_input
        self.prevent_output_computation = prevent_output_computation

        SingleSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[control_input], 
                                        subsystem_prototype=subsystem_prototype, 
                                        number_of_control_outputs=0 )



    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            
            # code_compute_output = self._subsystem_prototype.generate_code_output_list(language, self._subsystem_prototype.outputs)




            code_compute_output = cgh.embed_subsystem(language, system_prototype=self._subsystem_prototype, ouput_signals_name=cgh.signal_list_to_name_list(signals), calculate_outputs = True, update_states = False )


            if self.prevent_output_computation:

                # the subsystems outputs are only computed when triggered
                lines += cgh.generate_if_else(language, 
                    condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input, 1 ) ], 
                    action_list=[ code_compute_output ])

                # TODO: copy output signals and only the ones requested

            else:
                # the subsystems outputs are always computed
                lines += code_compute_output


        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            code_compute_state_update = self._subsystem_prototype.generate_code_update(language)

            # the subsystems update is on only performed when triggered
            lines += cgh.generate_if_else(language, 
                condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
                action_list=[ code_compute_state_update ])

        return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></li>
<li><a title="openrtdynamics2.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.block_prototypes.TruggeredSubsystem.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.signals.Signal" href="signals.html#openrtdynamics2.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:
        
        # code_compute_output = self._subsystem_prototype.generate_code_output_list(language, self._subsystem_prototype.outputs)




        code_compute_output = cgh.embed_subsystem(language, system_prototype=self._subsystem_prototype, ouput_signals_name=cgh.signal_list_to_name_list(signals), calculate_outputs = True, update_states = False )


        if self.prevent_output_computation:

            # the subsystems outputs are only computed when triggered
            lines += cgh.generate_if_else(language, 
                condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input, 1 ) ], 
                action_list=[ code_compute_output ])

            # TODO: copy output signals and only the ones requested

        else:
            # the subsystems outputs are always computed
            lines += code_compute_output


    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.block_prototypes.TruggeredSubsystem.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        code_compute_state_update = self._subsystem_prototype.generate_code_update(language)

        # the subsystems update is on only performed when triggered
        lines += cgh.generate_if_else(language, 
            condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
            action_list=[ code_compute_state_update ])

    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_defStates" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_destruct" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_init" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.update_input_config" href="block_interface.html#openrtdynamics2.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openrtdynamics2" href="index.html">openrtdynamics2</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.abs" href="#openrtdynamics2.block_prototypes.abs">abs</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.acos" href="#openrtdynamics2.block_prototypes.acos">acos</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.add" href="#openrtdynamics2.block_prototypes.add">add</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.asin" href="#openrtdynamics2.block_prototypes.asin">asin</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.atan" href="#openrtdynamics2.block_prototypes.atan">atan</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.atan2" href="#openrtdynamics2.block_prototypes.atan2">atan2</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.bitwise_and" href="#openrtdynamics2.block_prototypes.bitwise_and">bitwise_and</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.bitwise_not" href="#openrtdynamics2.block_prototypes.bitwise_not">bitwise_not</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.bitwise_or" href="#openrtdynamics2.block_prototypes.bitwise_or">bitwise_or</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.bitwise_shift_left" href="#openrtdynamics2.block_prototypes.bitwise_shift_left">bitwise_shift_left</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.bitwise_shift_right" href="#openrtdynamics2.block_prototypes.bitwise_shift_right">bitwise_shift_right</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.comparison" href="#openrtdynamics2.block_prototypes.comparison">comparison</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.conditional_overwrite" href="#openrtdynamics2.block_prototypes.conditional_overwrite">conditional_overwrite</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.const" href="#openrtdynamics2.block_prototypes.const">const</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.convert" href="#openrtdynamics2.block_prototypes.convert">convert</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.cos" href="#openrtdynamics2.block_prototypes.cos">cos</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.delay__" href="#openrtdynamics2.block_prototypes.delay__">delay__</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.flipflop" href="#openrtdynamics2.block_prototypes.flipflop">flipflop</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.fmod" href="#openrtdynamics2.block_prototypes.fmod">fmod</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.gain" href="#openrtdynamics2.block_prototypes.gain">gain</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.generic_cpp_static" href="#openrtdynamics2.block_prototypes.generic_cpp_static">generic_cpp_static</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.generic_subsystem" href="#openrtdynamics2.block_prototypes.generic_subsystem">generic_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.logic_and" href="#openrtdynamics2.block_prototypes.logic_and">logic_and</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.logic_not" href="#openrtdynamics2.block_prototypes.logic_not">logic_not</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.logic_or" href="#openrtdynamics2.block_prototypes.logic_or">logic_or</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.logic_xor" href="#openrtdynamics2.block_prototypes.logic_xor">logic_xor</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.memory" href="#openrtdynamics2.block_prototypes.memory">memory</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.memory_read" href="#openrtdynamics2.block_prototypes.memory_read">memory_read</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.operator1" href="#openrtdynamics2.block_prototypes.operator1">operator1</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.pow" href="#openrtdynamics2.block_prototypes.pow">pow</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.sin" href="#openrtdynamics2.block_prototypes.sin">sin</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.sqrt" href="#openrtdynamics2.block_prototypes.sqrt">sqrt</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.switchNto1" href="#openrtdynamics2.block_prototypes.switchNto1">switchNto1</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.tan" href="#openrtdynamics2.block_prototypes.tan">tan</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.Add" href="#openrtdynamics2.block_prototypes.Add">Add</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.Add.generate_code_output_list" href="#openrtdynamics2.block_prototypes.Add.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.ComparisionOperator" href="#openrtdynamics2.block_prototypes.ComparisionOperator">ComparisionOperator</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.ComparisionOperator.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.ComparisionOperator.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.ComparisionOperator.generate_code_output_list" href="#openrtdynamics2.block_prototypes.ComparisionOperator.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.ConditionalOverwrite" href="#openrtdynamics2.block_prototypes.ConditionalOverwrite">ConditionalOverwrite</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.ConditionalOverwrite.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.ConditionalOverwrite.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.ConditionalOverwrite.generate_code_output_list" href="#openrtdynamics2.block_prototypes.ConditionalOverwrite.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.Const" href="#openrtdynamics2.block_prototypes.Const">Const</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.Const.generate_code_output_list" href="#openrtdynamics2.block_prototypes.Const.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.ConvertDatatype" href="#openrtdynamics2.block_prototypes.ConvertDatatype">ConvertDatatype</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.ConvertDatatype.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.ConvertDatatype.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.ConvertDatatype.generate_code_output_list" href="#openrtdynamics2.block_prototypes.ConvertDatatype.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.Delay" href="#openrtdynamics2.block_prototypes.Delay">Delay</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.Delay.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.Delay.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Delay.generate_code_output_list" href="#openrtdynamics2.block_prototypes.Delay.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Delay.generate_code_reset" href="#openrtdynamics2.block_prototypes.Delay.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Delay.generate_code_update" href="#openrtdynamics2.block_prototypes.Delay.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.Flipflop" href="#openrtdynamics2.block_prototypes.Flipflop">Flipflop</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.Flipflop.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.Flipflop.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Flipflop.generate_code_output_list" href="#openrtdynamics2.block_prototypes.Flipflop.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Flipflop.generate_code_reset" href="#openrtdynamics2.block_prototypes.Flipflop.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Flipflop.generate_code_update" href="#openrtdynamics2.block_prototypes.Flipflop.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.Gain" href="#openrtdynamics2.block_prototypes.Gain">Gain</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.Gain.generate_code_output_list" href="#openrtdynamics2.block_prototypes.Gain.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.GenericCppStatic" href="#openrtdynamics2.block_prototypes.GenericCppStatic">GenericCppStatic</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.GenericCppStatic.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.GenericCppStatic.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericCppStatic.generate_code_output_list" href="#openrtdynamics2.block_prototypes.GenericCppStatic.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem" href="#openrtdynamics2.block_prototypes.GenericSubsystem">GenericSubsystem</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.GenericSubsystem.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.embedded_subsystem" href="#openrtdynamics2.block_prototypes.GenericSubsystem.embedded_subsystem">embedded_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_call_OutputFunction" href="#openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_call_OutputFunction">generate_code_call_OutputFunction</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_call_UpdateFunction" href="#openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_call_UpdateFunction">generate_code_call_UpdateFunction</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_output_list" href="#openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_reset" href="#openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_update" href="#openrtdynamics2.block_prototypes.GenericSubsystem.generate_code_update">generate_code_update</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.init" href="#openrtdynamics2.block_prototypes.GenericSubsystem.init">init</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.GenericSubsystem.set_anonymous_output_signal_to_connect" href="#openrtdynamics2.block_prototypes.GenericSubsystem.set_anonymous_output_signal_to_connect">set_anonymous_output_signal_to_connect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.LoopUntilSubsystem" href="#openrtdynamics2.block_prototypes.LoopUntilSubsystem">LoopUntilSubsystem</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.LoopUntilSubsystem.generate_code_output_list" href="#openrtdynamics2.block_prototypes.LoopUntilSubsystem.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.LoopUntilSubsystem.generate_code_update" href="#openrtdynamics2.block_prototypes.LoopUntilSubsystem.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.Memory" href="#openrtdynamics2.block_prototypes.Memory">Memory</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.Memory.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.Memory.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Memory.generate_code_output_list" href="#openrtdynamics2.block_prototypes.Memory.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Memory.generate_code_reset" href="#openrtdynamics2.block_prototypes.Memory.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.Memory.generate_code_update" href="#openrtdynamics2.block_prototypes.Memory.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.MemoryRead" href="#openrtdynamics2.block_prototypes.MemoryRead">MemoryRead</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.MemoryRead.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.MemoryRead.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MemoryRead.generate_code_output_list" href="#openrtdynamics2.block_prototypes.MemoryRead.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.additional_outputs" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.additional_outputs">additional_outputs</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_reset" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_reset" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_reset">generate_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_switch" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.generate_switch">generate_switch</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.subsystem_switch_outouts" href="#openrtdynamics2.block_prototypes.MultiSubsystemEmbedder.subsystem_switch_outouts">subsystem_switch_outouts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.Operator0" href="#openrtdynamics2.block_prototypes.Operator0">Operator0</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.Operator0.generate_code_output_list" href="#openrtdynamics2.block_prototypes.Operator0.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.Operator1" href="#openrtdynamics2.block_prototypes.Operator1">Operator1</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.Operator1.generate_code_output_list" href="#openrtdynamics2.block_prototypes.Operator1.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.additional_outputs" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.additional_outputs">additional_outputs</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_reset" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.helper_get_output_signal_mapping_to_subsystem" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.helper_get_output_signal_mapping_to_subsystem">helper_get_output_signal_mapping_to_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.normal_outouts" href="#openrtdynamics2.block_prototypes.SingleSubsystemEmbedder.normal_outouts">normal_outouts</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems" href="#openrtdynamics2.block_prototypes.StatemachineSwichSubsystems">StatemachineSwichSubsystems</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_output_list" href="#openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_reset" href="#openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_update" href="#openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_code_update">generate_code_update</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_switch_to_reset_leaving_subsystem" href="#openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.generate_switch_to_reset_leaving_subsystem">generate_switch_to_reset_leaving_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.state_output" href="#openrtdynamics2.block_prototypes.StatemachineSwichSubsystems.state_output">state_output</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.StaticFnByName_1To1" href="#openrtdynamics2.block_prototypes.StaticFnByName_1To1">StaticFnByName_1To1</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.StaticFnByName_1To1.generate_code_output_list" href="#openrtdynamics2.block_prototypes.StaticFnByName_1To1.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.StaticFnByName_2To1" href="#openrtdynamics2.block_prototypes.StaticFnByName_2To1">StaticFnByName_2To1</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.StaticFnByName_2To1.generate_code_output_list" href="#openrtdynamics2.block_prototypes.StaticFnByName_2To1.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.SwichSubsystems" href="#openrtdynamics2.block_prototypes.SwichSubsystems">SwichSubsystems</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.SwichSubsystems.generate_code_output_list" href="#openrtdynamics2.block_prototypes.SwichSubsystems.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SwichSubsystems.generate_code_update" href="#openrtdynamics2.block_prototypes.SwichSubsystems.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.SwitchNto1" href="#openrtdynamics2.block_prototypes.SwitchNto1">SwitchNto1</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.SwitchNto1.config_request_define_output_types" href="#openrtdynamics2.block_prototypes.SwitchNto1.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.SwitchNto1.generate_code_output_list" href="#openrtdynamics2.block_prototypes.SwitchNto1.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.block_prototypes.TruggeredSubsystem" href="#openrtdynamics2.block_prototypes.TruggeredSubsystem">TruggeredSubsystem</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.block_prototypes.TruggeredSubsystem.generate_code_output_list" href="#openrtdynamics2.block_prototypes.TruggeredSubsystem.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.block_prototypes.TruggeredSubsystem.generate_code_update" href="#openrtdynamics2.block_prototypes.TruggeredSubsystem.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>