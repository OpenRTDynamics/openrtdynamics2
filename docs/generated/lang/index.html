<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>openrtdynamics2.lang API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openrtdynamics2.lang</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .lang import *

__pdoc__ = {}
__pdoc__[&#39;lang&#39;] = False

# __all__ = [&#39;show_required_inputs&#39;, &#39;run_batch_simulation&#39;, &#39;SystemInstance&#39;, &#39;CompiledCode&#39;]

__all__ = dir()</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="openrtdynamics2.lang.block_interface" href="block_interface.html">openrtdynamics2.lang.block_interface</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.block_prototypes" href="block_prototypes.html">openrtdynamics2.lang.block_prototypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.block_prototypes_single_subsystem" href="block_prototypes_single_subsystem.html">openrtdynamics2.lang.block_prototypes_single_subsystem</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.block_prototypes_subsystems" href="block_prototypes_subsystems.html">openrtdynamics2.lang.block_prototypes_subsystems</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems" href="block_prototypes_switched_subsystems.html">openrtdynamics2.lang.block_prototypes_switched_subsystems</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.code_generation_templates" href="code_generation_templates.html">openrtdynamics2.lang.code_generation_templates</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.core_blocks" href="core_blocks.html">openrtdynamics2.lang.core_blocks</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.diagram_core" href="diagram_core/index.html">openrtdynamics2.lang.diagram_core</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.high_level_user_commands" href="high_level_user_commands.html">openrtdynamics2.lang.high_level_user_commands</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.libraries" href="libraries.html">openrtdynamics2.lang.libraries</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.signal_interface" href="signal_interface.html">openrtdynamics2.lang.signal_interface</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.standard_library" href="standard_library.html">openrtdynamics2.lang.standard_library</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.subsystems" href="subsystems.html">openrtdynamics2.lang.subsystems</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.system_context" href="system_context.html">openrtdynamics2.lang.system_context</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="openrtdynamics2.lang.PID_controller"><code class="name flex">
<span>def <span class="ident">PID_controller</span></span>(<span>r, y, Ts, kp, ki=None, kd=None)</span>
</code></dt>
<dd>
<div class="desc"><p>discrete-time PID-controller</p>
<p>r
- the reference signal
y
- the measured plant output
Ts
- the sampling time
kp, ki, kd
- the controller parameters (proportional, integral, differential)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PID_controller(r, y, Ts, kp, ki = None, kd = None):
    &#34;&#34;&#34;
        discrete-time PID-controller

        r           - the reference signal
        y           - the measured plant output
        Ts          - the sampling time
        kp, ki, kd  - the controller parameters (proportional, integral, differential)
    &#34;&#34;&#34;
    Ts = dy.float64(Ts)

    # control error
    e = r - y

    # P
    u = kp * e

    # D
    if kd is not None:
        u = u + dy.diff(e) * kd / Ts

    # I
    if ki is not None:
        u = u + dy.sum(e) * ki * Ts

    return u</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.abs"><code class="name flex">
<span>def <span class="ident">abs</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Absolute value</p>
<p>|u|</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abs(u : SignalUserTemplate ):
    &#34;&#34;&#34;
    Absolute value

    |u|
    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;abs&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.acos"><code class="name flex">
<span>def <span class="ident">acos</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acos(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;acos&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>input_signals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], factors: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>Linear combination of the list of input signals with the list of factors</p>
<p>the output is given by
input_signals[0] * factors[0] + input_signals[1] * factors[1] + &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(input_signals : List[SignalUserTemplate], factors : List[float]):
    &#34;&#34;&#34;
    Linear combination of the list of input signals with the list of factors

    the output is given by
        input_signals[0] * factors[0] + input_signals[1] * factors[1] + ...
    &#34;&#34;&#34;
    return wrap_signal( Add(dy.get_system_context(), unwrap_list( input_signals ), factors).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.append_primay_ouput"><code class="name flex">
<span>def <span class="ident">append_primay_ouput</span></span>(<span>output_signal, export_name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>add an output to the current system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_primay_ouput(output_signal, export_name : str = None):
    &#34;&#34;&#34;
        add an output to the current system
    &#34;&#34;&#34;

    if export_name is not None:
        output_signal.set_name_raw(export_name)

    get_system_context().append_primay_ouput(output_signal.unwrap)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.asin"><code class="name flex">
<span>def <span class="ident">asin</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asin(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;asin&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.atan"><code class="name flex">
<span>def <span class="ident">atan</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atan(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;atan&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.atan2"><code class="name flex">
<span>def <span class="ident">atan2</span></span>(<span>y: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, x: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atan2(y : SignalUserTemplate, x : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_2To1(dy.get_system_context(), y.unwrap, x.unwrap, &#39;atan2&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_and"><code class="name flex">
<span>def <span class="ident">bitwise_and</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>bitwise and</p>
<p>u1 &amp; u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_and(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        bitwise and

        u1 &amp; u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list([u1,u2]), operator=&#39; &amp; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_not"><code class="name flex">
<span>def <span class="ident">bitwise_not</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Bitwise not operator</p>
<p>'~'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_not(u : SignalUserTemplate ):
    &#34;&#34;&#34;
    Bitwise not operator

    &#39;~&#39;
    &#34;&#34;&#34;
    return wrap_signal( Operator0(dy.get_system_context(), u.unwrap, &#39;~&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_or"><code class="name flex">
<span>def <span class="ident">bitwise_or</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>bitwise or</p>
<p>u1 | u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_or(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        bitwise or
    
        u1 | u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; | &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_shift_left"><code class="name flex">
<span>def <span class="ident">bitwise_shift_left</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, shift: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical shift left</p>
<p>u &lt;&lt; shift</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_shift_left(u : SignalUserTemplate, shift : SignalUserTemplate):
    &#34;&#34;&#34;
        logical shift left
    
        u &lt;&lt; shift
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u,shift] ), operator=&#39; &lt;&lt; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_shift_right"><code class="name flex">
<span>def <span class="ident">bitwise_shift_right</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, shift: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical shift left</p>
<p>u &gt;&gt; shift</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_shift_right(u : SignalUserTemplate, shift : SignalUserTemplate):
    &#34;&#34;&#34;
        logical shift left
    
        u &gt;&gt; shift
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u,shift] ), operator=&#39; &gt;&gt; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.boolean"><code class="name flex">
<span>def <span class="ident">boolean</span></span>(<span>value: int)</span>
</code></dt>
<dd>
<div class="desc"><p>cast anything to DataTypeBoolean</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boolean(value : int):
    &#34;&#34;&#34;
        cast anything to DataTypeBoolean
    &#34;&#34;&#34;
    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeBoolean(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>clear the context</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear():
    &#34;&#34;&#34;
        clear the context
    &#34;&#34;&#34;
    init_simulation_context()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.comparison"><code class="name flex">
<span>def <span class="ident">comparison</span></span>(<span>left: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, right: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, operator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison(left : SignalUserTemplate, right : SignalUserTemplate, operator : str ):
    return wrap_signal( ComparisionOperator(dy.get_system_context(), left.unwrap, right.unwrap, operator).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.compile_system"><code class="name flex">
<span>def <span class="ident">compile_system</span></span>(<span>system=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_system(system = None):

    if system is None:
        system = get_system_context() 

    system.propagate_datatypes()

    #
    # compile the diagram: turn the blocks and signals into a tree-structure of commands to execute
    # at runtime.
    #

    compiler = dc.CompileDiagram()
    compile_results = compiler.compile( system )

    #
    return compile_results</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.conditional_overwrite"><code class="name flex">
<span>def <span class="ident">conditional_overwrite</span></span>(<span>signal: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, condition: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, new_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwrite the input signal by a given value in case a condition is true</p>
<p>The output is given by</p>
<pre><code>signal     for condition==false
new_value  for condition==true
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conditional_overwrite(signal : SignalUserTemplate, condition : SignalUserTemplate, new_value ):
    &#34;&#34;&#34;
    Overwrite the input signal by a given value in case a condition is true

    The output is given by

        signal     for condition==false
        new_value  for condition==true

    &#34;&#34;&#34;

    if isinstance(new_value, SignalUserTemplate):
        new_value = new_value.unwrap

    return wrap_signal( ConditionalOverwrite(dy.get_system_context(), signal.unwrap, condition.unwrap, new_value).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.const"><code class="name flex">
<span>def <span class="ident">const</span></span>(<span>constant, datatype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def const(constant, datatype ):
    return wrap_signal( Const(dy.get_system_context(), constant, datatype).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, target_type: <a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Datatype conversion</p>
<p>The input is converted to the given datatype</p>
<p>u
- the input signal
target_type - the datatype</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(u : SignalUserTemplate, target_type : dt.DataType ):
    &#34;&#34;&#34;
    Datatype conversion

    The input is converted to the given datatype

    u           - the input signal
    target_type - the datatype
    &#34;&#34;&#34;
    return wrap_signal( ConvertDatatype(dy.get_system_context(), u.unwrap, target_type).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.cos"><code class="name flex">
<span>def <span class="ident">cos</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cos(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;cos&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.counter"><code class="name flex">
<span>def <span class="ident">counter</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic counter</p>
<p>The integer output is increasing with each sampling instant by 1.
Counting starts at zero.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counter():
    &#34;&#34;&#34;
        Basic counter

        The integer output is increasing with each sampling instant by 1.
        Counting starts at zero.
    &#34;&#34;&#34;

    if not &#39;counter&#39; in dy.get_system_context().components:
        # no counter has been defined in this system so far. Hence, create one.

        increase = dy.const(1, dy.DataTypeInt32(1) )
        cnt = dy.signal()
        tmp = dy.delay(cnt + increase)
        cnt &lt;&lt; tmp 

        tmp.set_name(&#39;shared_couter&#39;)

        # store the output signal of the counter as it might be used again. 
        dy.get_system_context().components[&#39;counter&#39;] = __Counter(tmp)

    else:
        # use the output of an already created counter
        tmp = dy.get_system_context().components[&#39;counter&#39;].output

    return tmp</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.counter_triggered"><code class="name flex">
<span>def <span class="ident">counter_triggered</span></span>(<span>upper_limit, stepwidth=None, initial_state=0, reset=None, reset_on_limit: bool = False, start_trigger=None, pause_trigger=None, auto_start: bool = True, no_delay: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic counter</p>
<p>Features:
.) upper limit
.) triggerable start/pause
.) resetable
.) dynamic adjustable step-size</p>
<p>upper_limit
- the upper limit of the counter
initial_state
- the state after reset
reset
- reset the counter
reset_on_limit
- reset counter once the upper limit is reached
start_trigger
- event to start counting
pause_trigger
- event to pause counting
auto_start
- start counting automatically
no_delay
- when True the new value of the counter is returned without delay</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counter_triggered( upper_limit, stepwidth=None, initial_state = 0, reset=None, reset_on_limit:bool=False, start_trigger=None, pause_trigger=None, auto_start:bool=True, no_delay:bool=False ):
    &#34;&#34;&#34;
        A generic counter

        Features:
        .) upper limit
        .) triggerable start/pause
        .) resetable
        .) dynamic adjustable step-size

        upper_limit              - the upper limit of the counter
        initial_state            - the state after reset
        reset                    - reset the counter
        reset_on_limit           - reset counter once the upper limit is reached
        start_trigger            - event to start counting
        pause_trigger            - event to pause counting
        auto_start               - start counting automatically
        no_delay                 - when True the new value of the counter is returned without delay 
    &#34;&#34;&#34;

    if stepwidth is None:
        stepwidth = dy.int32(1)

    counter = dy.signal()

    reached_upper_limit = counter &gt; dy.int32(upper_limit)

    if start_trigger is None:
        start_trigger = dy.boolean(0)

    # 
    if pause_trigger is not None: 
        activate_trigger = dy.logic_or(reached_upper_limit, pause_trigger)
    else:
        if not auto_start:
            activate_trigger = reached_upper_limit
        else:
            # when auto_start is active, continue counting after reset on reached_upper_limit
            activate_trigger = dy.boolean(0)


    # state for pause/counting
    paused =  dy.flipflop(activate_trigger=activate_trigger, disable_trigger=start_trigger, initial_state = not auto_start).set_name(&#39;paused&#39;)

    # prevent counter increase
    stepwidth = dy.conditional_overwrite(stepwidth, paused, 0).set_name(&#39;stepwidth&#39;)

    # increase the counter until the end is reached
    new_counter = counter + dy.conditional_overwrite(stepwidth, reached_upper_limit, 0)

    if reset is not None:
        # reset in case this is requested
        new_counter = dy.conditional_overwrite(new_counter, reset, initial_state)

    if reset_on_limit:
        new_counter = dy.conditional_overwrite(new_counter, reached_upper_limit, initial_state)

    # introduce a state variable for the counter
    counter &lt;&lt; dy.delay( new_counter, initial_state=initial_state )

    if not no_delay:
        return counter
    else:
        return new_counter</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>u, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>unit delay</p>
<p>delay the input u by one sampling instant</p>
<p>y[k+1] = u[k], y[0] = initial_state</p>
<p>u
- the input signal to delay
initial_state - the initial state (signal or constant value)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay(u , initial_state = None):
    &#34;&#34;&#34;
        unit delay

        delay the input u by one sampling instant

        y[k+1] = u[k], y[0] = initial_state

        u             - the input signal to delay
        initial_state - the initial state (signal or constant value)
    &#34;&#34;&#34;

    if not isinstance( initial_state, SignalUserTemplate ):
        return dy.delay__( u, initial_state )

    else:

        event_on_first_sample = initial_event()

        delayed_input = dy.delay__( u, None )
        delayed_input = dy.conditional_overwrite( delayed_input, event_on_first_sample, initial_state )

        return delayed_input</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.delay__"><code class="name flex">
<span>def <span class="ident">delay__</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay__(u : SignalUserTemplate, initial_state = None):
    return wrap_signal( Delay(dy.get_system_context(), u.unwrap, initial_state ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Discrete difference</p>
<p>y = u[k] - u[k-1] </p>
<p>initial state</p>
<p>u[0] = initial_state
in case initial_state is not None
u[0] = 0
otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(u : Signal, initial_state = None):
    &#34;&#34;&#34;
        Discrete difference

        y = u[k] - u[k-1] 

        initial state

        u[0] = initial_state   in case initial_state is not None
        u[0] = 0               otherwise
    &#34;&#34;&#34;

    i = dy.delay( u, initial_state )
    y = dy.add( [ i, u ], [ -1, 1 ] )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.dtf_lowpass_1_order"><code class="name flex">
<span>def <span class="ident">dtf_lowpass_1_order</span></span>(<span>u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, z_infinity)</span>
</code></dt>
<dd>
<div class="desc"><p>First-order discrete-time low pass filter</p>
<pre><code>     1 - z_infinity
</code></pre>
<p>H (z) =
--------------
z - z_infinity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dtf_lowpass_1_order(u : Signal, z_infinity):
    &#34;&#34;&#34;
        First-order discrete-time low pass filter

                 1 - z_infinity
        H (z) =  --------------
                 z - z_infinity
    &#34;&#34;&#34;

    zinf = dy.float64( z_infinity )
    zinf_ = dy.float64( 1 ) - zinf

    y_delayed = dy.signal()
    y =  zinf * y_delayed + zinf_ * u

    y_delayed &lt;&lt; dy.delay(y)
    
    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.enter_system"><code class="name flex">
<span>def <span class="ident">enter_system</span></span>(<span>name: str = 'simulation', upper_level_system=None)</span>
</code></dt>
<dd>
<div class="desc"><p>create a new system and activate it in the context</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enter_system(name : str = &#39;simulation&#39;, upper_level_system = None):
    &#34;&#34;&#34;
        create a new system and activate it in the context
    &#34;&#34;&#34;
    # new simulation
    system = System(upper_level_system, name)

    # register this subsystem to the parent system
    if get_system_context() is not None:
        get_system_context().append_subsystem( system )

    push_simulation_context(system)

    return system</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.euler_integrator"><code class="name flex">
<span>def <span class="ident">euler_integrator</span></span>(<span>u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, Ts, initial_state=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Euler (forward) integrator</p>
<p>y[k+1] = y[k] + Ts * u[k]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euler_integrator( u : Signal, Ts, initial_state = 0.0):
    &#34;&#34;&#34;
        Euler (forward) integrator

        y[k+1] = y[k] + Ts * u[k]
    &#34;&#34;&#34;

    yFb = dy.signal()

    if not isinstance( Ts, SignalUserTemplate ): 
        i = dy.add( [ yFb, u ], [ 1, Ts ] )
    else:
        i = yFb + Ts * u

    y = dy.delay( i, initial_state )

    yFb &lt;&lt; y

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.export_graph"><code class="name flex">
<span>def <span class="ident">export_graph</span></span>(<span>filename, system=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_graph(filename, system = None):

    if system is None:
        system = get_system_context() 

    graph = system.exportGraph()

    with open( os.path.join(  filename ), &#39;w&#39;) as outfile:  
        json.dump(graph, outfile)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.flipflop"><code class="name flex">
<span>def <span class="ident">flipflop</span></span>(<span>activate_trigger: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, disable_trigger: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, initial_state=False, nodelay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Flipflop logic element</p>
<p>The block has a state that can be activated or deactivated by the external boolean events 'activate_trigger'
and 'disable_trigger', respectively.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flipflop(activate_trigger : Signal, disable_trigger : Signal, initial_state = False, nodelay = False):
    &#34;&#34;&#34;
    Flipflop logic element

    The block has a state that can be activated or deactivated by the external boolean events &#39;activate_trigger&#39;
    and &#39;disable_trigger&#39;, respectively.
    &#34;&#34;&#34;
    
    return wrap_signal( Flipflop(dy.get_system_context(), activate_trigger.unwrap, disable_trigger.unwrap, initial_state = initial_state, nodelay=nodelay ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.float64"><code class="name flex">
<span>def <span class="ident">float64</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>cast anything to DataTypeFloat64</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def float64(value):
    &#34;&#34;&#34;
        cast anything to DataTypeFloat64
    &#34;&#34;&#34;
    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeFloat64(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.fmod"><code class="name flex">
<span>def <span class="ident">fmod</span></span>(<span>x: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, y: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>modulo function for floating point values</p>
<p>This function returns the remainder of dividing x/y.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fmod(x : SignalUserTemplate, y : SignalUserTemplate ):
    &#34;&#34;&#34;
        modulo function for floating point values

        This function returns the remainder of dividing x/y.
    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_2To1(dy.get_system_context(), x.unwrap, y.unwrap, &#39;fmod&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.gain"><code class="name flex">
<span>def <span class="ident">gain</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, gain: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gain(u : SignalUserTemplate, gain : float ):
    return wrap_signal( Gain(dy.get_system_context(), u.unwrap, gain).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.generate_code"><code class="name flex">
<span>def <span class="ident">generate_code</span></span>(<span>template: <a title="openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper">PutRuntimeCppHelper</a>, folder=None, build=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code(template : PutRuntimeCppHelper, folder=None, build=False):

    # Compile system (propagate datatypes)
    compile_results = compile_system()

    # Build an executable based on a template
    template.set_compile_results( compile_results )
    code_gen_results = template.code_gen()

    if folder is not None:

        # check of path exists - in case no, create it
        pl.Path(folder).mkdir(parents=True, exist_ok=True)

        print(&#34;Generated code will be written to &#34; + str(folder) + &#39; .&#39;)

        # write generated code into a folder and build
        template.write_code(folder)

        if build:
            template.build()


    return code_gen_results</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.generic_cpp_static"><code class="name flex">
<span>def <span class="ident">generic_cpp_static</span></span>(<span>input_signals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], input_names: List[str], input_types, output_types, output_names, cpp_source_code: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Embed C/C++ source code (stateless code only)</p>
<h2 id="example">Example</h2>
<p>source_code = """</p>
<pre><code>// c++ code

output1 = value;
if (someinput &gt; value) {
    output2 = value;
} else {
    output2 = someinput;
}
output3 = 0.0;
</code></pre>
<p>"""</p>
<p>outputs = dy.generic_cpp_static(input_signals=[ someinput, value ], input_names=[ 'someinput', 'value' ],
input_types=[ dy.DataTypeFloat64(1), dy.DataTypeFloat64(1) ],
output_names=['output1', 'output2', 'output3'],
output_types=[ dy.DataTypeFloat64(1), dy.DataTypeFloat64(1), dy.DataTypeFloat64(1) ],
cpp_source_code = source_code )</p>
<p>output1 = outputs[0]
output2 = outputs[1]
output3 = outputs[2]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_cpp_static(input_signals : List[SignalUserTemplate], input_names : List [str], input_types, output_types, output_names, cpp_source_code : str ):
    &#34;&#34;&#34;
    Embed C/C++ source code (stateless code only)

    Example:

        source_code = \&#34;\&#34;\&#34;

            // c++ code

            output1 = value;
            if (someinput &gt; value) {
                output2 = value;
            } else {
                output2 = someinput;
            }
            output3 = 0.0;

        \&#34;\&#34;\&#34;

        outputs = dy.generic_cpp_static(input_signals=[ someinput, value ], input_names=[ &#39;someinput&#39;, &#39;value&#39; ], 
                            input_types=[ dy.DataTypeFloat64(1), dy.DataTypeFloat64(1) ], 
                            output_names=[&#39;output1&#39;, &#39;output2&#39;, &#39;output3&#39;],
                            output_types=[ dy.DataTypeFloat64(1), dy.DataTypeFloat64(1), dy.DataTypeFloat64(1) ],
                            cpp_source_code = source_code )

        output1 = outputs[0]
        output2 = outputs[1]
        output3 = outputs[2]
    &#34;&#34;&#34;
    return wrap_signal_list( GenericCppStatic(dy.get_system_context(), unwrap_list(input_signals), input_names, input_types, output_names, output_types, cpp_source_code  ).outputs )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.generic_subsystem"><code class="name flex">
<span>def <span class="ident">generic_subsystem</span></span>(<span>manifest, inputSignals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_subsystem( manifest, inputSignals : List[SignalUserTemplate] ):
    return wrap_signal_list( GenericSubsystem(dy.get_system_context(), manifest, unwrap_hash(inputSignals) ).outputSignals )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.get_system_context"><code class="name flex">
<span>def <span class="ident">get_system_context</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_context():
    global current_simulation_context
    return current_simulation_context</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>autoreset=False, convert=None, strip=None, wrap=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(autoreset=False, convert=None, strip=None, wrap=True):

    if not wrap and any([autoreset, convert, strip]):
        raise ValueError(&#39;wrap=False conflicts with any other arg=True&#39;)

    global wrapped_stdout, wrapped_stderr
    global orig_stdout, orig_stderr

    orig_stdout = sys.stdout
    orig_stderr = sys.stderr

    if sys.stdout is None:
        wrapped_stdout = None
    else:
        sys.stdout = wrapped_stdout = \
            wrap_stream(orig_stdout, convert, strip, autoreset, wrap)
    if sys.stderr is None:
        wrapped_stderr = None
    else:
        sys.stderr = wrapped_stderr = \
            wrap_stream(orig_stderr, convert, strip, autoreset, wrap)

    global atexit_done
    if not atexit_done:
        atexit.register(reset_all)
        atexit_done = True</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.init_simulation_context"><code class="name flex">
<span>def <span class="ident">init_simulation_context</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_simulation_context():
    global simulation_stack
    global current_simulation_context
    global counter_of_created_systems

    current_simulation_context = None
    simulation_stack = []
    counter_of_created_systems = 1000</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.initial_event"><code class="name flex">
<span>def <span class="ident">initial_event</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Fires an event on the first sampling instant after the reset of the system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initial_event():
    &#34;&#34;&#34;
        Fires an event on the first sampling instant after the reset of the system
    &#34;&#34;&#34;

    # TODO: introduce caching like done for counter()

    return dy.counter() == int32(0)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.int32"><code class="name flex">
<span>def <span class="ident">int32</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>cast anything to DataTypeInt32</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int32(value):
    &#34;&#34;&#34;
        cast anything to DataTypeInt32
    &#34;&#34;&#34;

    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeInt32(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.leave_system"><code class="name flex">
<span>def <span class="ident">leave_system</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leave_system():
    return pop_simulation_context()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.logic_and"><code class="name flex">
<span>def <span class="ident">logic_and</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical and</p>
<p>u1 &amp;&amp; u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_and(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        logical and

        u1 &amp;&amp; u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list([u1,u2]), operator=&#39; &amp;&amp; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.logic_not"><code class="name flex">
<span>def <span class="ident">logic_not</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logic negation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_not(u : SignalUserTemplate ):
    &#34;&#34;&#34;
        logic negation
    &#34;&#34;&#34;
    return wrap_signal( Operator0(dy.get_system_context(), u.unwrap, &#39;!&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.logic_or"><code class="name flex">
<span>def <span class="ident">logic_or</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical or</p>
<p>u1 || u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_or(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        logical or
    
        u1 || u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; || &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.logic_xor"><code class="name flex">
<span>def <span class="ident">logic_xor</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>exclusive logical or (xor)</p>
<p>u1 ^ u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_xor(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        exclusive logical or (xor)
    
        u1 ^ u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; ^ &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.memory"><code class="name flex">
<span>def <span class="ident">memory</span></span>(<span>datatype, constant_array, write_index: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a> = None, value: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Define an array</p>
<p>Allocates static memory for an array of elements given a datatype.
During each sampling instant, one element can be (over)written. </p>
<p>datatype
- the datatype of the array elements
constant_array - list of constants that contain the data to initialize the array
write_index
- the array index of the element to replace by value (optional)
value
- the value to write into the array at write_index (optional)</p>
<p>returns a reference to the memory segment which is accessible by memory_read()</p>
<p>Limitations: currently the memory is not reset on subsystem reset. This will change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory(datatype, constant_array, write_index : SignalUserTemplate = None, value : SignalUserTemplate = None):
    &#34;&#34;&#34;
        Define an array

        Allocates static memory for an array of elements given a datatype.
        During each sampling instant, one element can be (over)written. 

        datatype       - the datatype of the array elements
        constant_array - list of constants that contain the data to initialize the array
        write_index    - the array index of the element to replace by value (optional)
        value          - the value to write into the array at write_index (optional)

        returns a reference to the memory segment which is accessible by memory_read()

        Limitations: currently the memory is not reset on subsystem reset. This will change.
    &#34;&#34;&#34;

    if write_index is not None and value is not None:
        return wrap_signal( Memory(dy.get_system_context(), datatype, constant_array, write_index.unwrap, value.unwrap).outputs[0] )
    elif write_index is None and value is None:
        return wrap_signal( Memory(dy.get_system_context(), datatype, constant_array).outputs[0] )
    else:
        raise BaseException(&#39;memory: write_index and value were not properly defined&#39;)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.memory_read"><code class="name flex">
<span>def <span class="ident">memory_read</span></span>(<span>memory: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, index: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Read an element from an array defined by memory()</p>
<p>index - the index indicating the element to read.</p>
<p>Returns the value of the element</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_read( memory : SignalUserTemplate, index : SignalUserTemplate ):
    &#34;&#34;&#34;
        Read an element from an array defined by memory()

        index - the index indicating the element to read.

        Returns the value of the element
    &#34;&#34;&#34;
    return wrap_signal( MemoryRead(dy.get_system_context(), memory.unwrap, index.unwrap ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.operator1"><code class="name flex">
<span>def <span class="ident">operator1</span></span>(<span>inputSignals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], operator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operator1(inputSignals : List[SignalUserTemplate], operator : str ):
    return wrap_signal( Operator1(dy.get_system_context(), unwrap_list( inputSignals ), operator).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>sequence_array, stepwidth=None, initial_state=0, reset=None, reset_on_end: bool = False, start_trigger=None, pause_trigger=None, auto_start: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>playback of a sequence (TODO: update)</p>
<p>returns sample, playback_index</p>
<p>sequence_array
- the sequence given as a list of values
reset
- reset the playback and start from the beginning
reset_on_end
- reset playback once the end is reached (repetitive playback)
start_trigger
- event to start playback
pause_trigger
- event to pause playback
auto_start
- start playback automatically </p>
<p>return values</p>
<p>sample
- the value obtained from sequence_array
playback_index
- the current position of playback (index of the currently issued sequence element)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play( sequence_array,  stepwidth=None, initial_state = 0, reset=None, reset_on_end:bool=False, start_trigger=None, pause_trigger=None, auto_start:bool=True ):
    &#34;&#34;&#34;
        playback of a sequence (TODO: update)

        returns sample, playback_index

        sequence_array           - the sequence given as a list of values
        reset                    - reset the playback and start from the beginning
        reset_on_end             - reset playback once the end is reached (repetitive playback)
        start_trigger            - event to start playback
        pause_trigger            - event to pause playback
        auto_start               - start playback automatically 


        return values

        sample                   - the value obtained from sequence_array
        playback_index           - the current position of playback (index of the currently issued sequence element)
    &#34;&#34;&#34;

    sequence_array_storage = dy.memory(datatype=dy.DataTypeFloat64(1), constant_array=sequence_array )

    # if prevent_initial_playback:
    #     initial_counter_state = np.size(sequence_array)
    # else:
        

    playback_index = counter_triggered( upper_limit=np.size(sequence_array)-1, 
                                        stepwidth=stepwidth, initial_state=initial_state, 
                                        reset=reset, reset_on_limit=reset_on_end, 
                                        start_trigger=start_trigger, pause_trigger=pause_trigger, 
                                        auto_start=auto_start)

    # sample the given data
    sample = dy.memory_read(sequence_array_storage, playback_index)

    return sample, playback_index</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.pow"><code class="name flex">
<span>def <span class="ident">pow</span></span>(<span>base: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, power: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pow(base : SignalUserTemplate, power : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_2To1(dy.get_system_context(), base.unwrap, power.unwrap, &#39;pow&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.rate_limit"><code class="name flex">
<span>def <span class="ident">rate_limit</span></span>(<span>u, Ts, lower_limit, uppper_limit, initial_state=0)</span>
</code></dt>
<dd>
<div class="desc"><p>rate limiter</p>
<p>Ts
- sampling time (constant)
lower_limit
- lower rate limit
upper_limit
- upper rate limit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rate_limit( u, Ts, lower_limit, uppper_limit, initial_state = 0 ):
    &#34;&#34;&#34;
        rate limiter

        Ts           - sampling time (constant)
        lower_limit  - lower rate limit
        upper_limit  - upper rate limit
    &#34;&#34;&#34;

    Ts_ = float64(Ts)

    y = dy.signal()

    omega = u - y
    omega_sat = saturate(omega, float64(lower_limit) * Ts_, float64(uppper_limit) * Ts_)
    y &lt;&lt; euler_integrator( omega_sat, 1, initial_state=initial_state)

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sample_and_hold"><code class="name flex">
<span>def <span class="ident">sample_and_hold</span></span>(<span>u, event, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>sample &amp; hold</p>
<p>Samples the input when event is true and hold this value for the proceeding time instants. </p>
<p>u
- the input
event
- the trigger signal to perform the sampling
initial_state - the initial output</p>
<p>return values</p>
<p>the sampled input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_and_hold(u, event, initial_state = None):
    &#34;&#34;&#34;
        sample &amp; hold

        Samples the input when event is true and hold this value for the proceeding time instants. 

        u             - the input
        event         - the trigger signal to perform the sampling
        initial_state - the initial output

        return values

        the sampled input

    &#34;&#34;&#34;

    # NOTE: this could be implemented in a more comp. efficient way directly in C in block_prototypes.py

    y = dy.signal()

    delayed_y = delay( y, initial_state )
    y &lt;&lt; dy.conditional_overwrite( delayed_y, event, u )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.saturate"><code class="name flex">
<span>def <span class="ident">saturate</span></span>(<span>u, lower_limit=None, uppper_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>saturate the input signal</p>
<p>The output is the saturated input</p>
<p>lower_limit
- lower bound for the output
uppper_limit
- upper bound for the output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saturate(u, lower_limit = None, uppper_limit = None):
    &#34;&#34;&#34;
        saturate the input signal

        The output is the saturated input

        lower_limit   - lower bound for the output 
        uppper_limit  - upper bound for the output
    &#34;&#34;&#34;

    y = u

    if lower_limit is not None:
        y = dy.conditional_overwrite( y, y &lt; float64(lower_limit), lower_limit )
    
    if uppper_limit is not None:
        y = dy.conditional_overwrite( y, y &gt; float64(uppper_limit), uppper_limit )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.set_primary_outputs"><code class="name flex">
<span>def <span class="ident">set_primary_outputs</span></span>(<span>output_signals, names=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_primary_outputs(output_signals, names = None):

    if names is not None:
        for i in range(0,len(names)):
            output_signals[i].set_name_raw( names[i] )

    get_system_context().set_primary_outputs( si.unwrap_list( output_signals ) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.show_blocks"><code class="name flex">
<span>def <span class="ident">show_blocks</span></span>(<span>system=None)</span>
</code></dt>
<dd>
<div class="desc"><p>List all blocks in the current or given system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_blocks(system = None):
    &#34;&#34;&#34;
        List all blocks in the current or given system
    &#34;&#34;&#34;

    if system is None:
        system = get_system_context() 

    print()
    print(Style.BRIGHT + &#34;-------- list of blocks --------&#34;)
    print()

    system.ShowBlocks()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.show_execution_lines"><code class="name flex">
<span>def <span class="ident">show_execution_lines</span></span>(<span>compile_results)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_execution_lines(compile_results):

    print()
    print(Style.BRIGHT + &#34;-------- List all execution lines and commands  --------&#34;)
    print()

    compile_results.command_to_execute.print_execution()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal"><code class="name flex">
<span>def <span class="ident">signal</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new signal for defining a closed-loop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal():
    &#34;&#34;&#34;
        Create a new signal for defining a closed-loop
    &#34;&#34;&#34;

    # return an anonymous signal
    return si.SignalUser(get_system_context())</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_impulse"><code class="name flex">
<span>def <span class="ident">signal_impulse</span></span>(<span>k_event)</span>
</code></dt>
<dd>
<div class="desc"><p>Pulse signal generator</p>
<p>generates a unique pulse at sampling index k_event</p>
<p>k_event - the sampling index at which the pulse appears</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_impulse(k_event):
    &#34;&#34;&#34;
        Pulse signal generator

        generates a unique pulse at sampling index k_event

        k_event - the sampling index at which the pulse appears
    &#34;&#34;&#34;

    if k_event &lt; 0:
        raise BaseException(&#39;The sampling index for the event is invalid (k_event &lt; 0)&#39;)

    k = dy.counter()
    pulse_signal = dy.int32(k_event) == k

    return pulse_signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_periodic_impulse"><code class="name flex">
<span>def <span class="ident">signal_periodic_impulse</span></span>(<span>period, phase)</span>
</code></dt>
<dd>
<div class="desc"><p>signal generator for periodic pulses</p>
<p>generates a sequence of pulses</p>
<p>period - singal or constant describing the period in samples at which the pulses are generated
phase
- singal or constant describing the phase in samples at which the pulses are generated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_periodic_impulse(period, phase):
    &#34;&#34;&#34;
        signal generator for periodic pulses

        generates a sequence of pulses

        period - singal or constant describing the period in samples at which the pulses are generated
        phase  - singal or constant describing the phase in samples at which the pulses are generated
    &#34;&#34;&#34;

    k = counter_triggered( upper_limit=dy.int32(period) - dy.int32(2), reset_on_limit=True )
    pulse_signal = dy.int32(phase) == k

    return pulse_signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_ramp"><code class="name flex">
<span>def <span class="ident">signal_ramp</span></span>(<span>k_start)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for a ramp signal</p>
<p>k_start - the sampling index as returned by counter() at which the ramp starts increasing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_ramp(k_start):
    &#34;&#34;&#34;
        Signal generator for a ramp signal

        k_start - the sampling index as returned by counter() at which the ramp starts increasing.
    &#34;&#34;&#34;
    k = dy.counter()
    active = dy.int32(k_start) &lt;= k

    linearRise = dy.convert( (k - dy.int32(k_start) ), dy.DataTypeFloat64(1) )
    activation = dy.convert( active, dy.DataTypeFloat64(1) )

    return activation * linearRise</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_sinus"><code class="name flex">
<span>def <span class="ident">signal_sinus</span></span>(<span>N_period: int = 100, phi=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for sinosoidal signals</p>
<p>The output is computed as follows:</p>
<p>y = sin( k * (1 / N_period * 2 * pi) + phi )</p>
<p>k - is the sampling index</p>
<p>N_period - period in sampling instants (type: constant integer)
phi
- phase shift (signal)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_sinus(N_period : int = 100, phi = None):
    &#34;&#34;&#34;
        Signal generator for sinosoidal signals

        The output is computed as follows:

        y = sin( k * (1 / N_period * 2 * pi) + phi )

        k - is the sampling index

        N_period - period in sampling instants (type: constant integer)
        phi      - phase shift (signal)
    &#34;&#34;&#34;

    if N_period &lt;= 0:
        raise BaseException(&#39;N_period &lt;= 0&#39;)

    if phi is None:
        phi = dy.float64(0.0)

    i = dy.counter_triggered( upper_limit=N_period-1, reset_on_limit=True )
    y = dy.sin( i * dy.float64(1/N_period * 2*math.pi) + phi )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_square"><code class="name flex">
<span>def <span class="ident">signal_square</span></span>(<span>period, phase)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_square(period, phase):

    trigger = signal_periodic_impulse(period, phase)

    state, activate, deactivate = toggle(trigger)

    return state, activate, deactivate</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_step"><code class="name flex">
<span>def <span class="ident">signal_step</span></span>(<span>k_step)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for a step signal</p>
<p>k_step - the sampling index as returned by counter() at which the step appears.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_step(k_step):
    &#34;&#34;&#34;
        Signal generator for a step signal

        k_step - the sampling index as returned by counter() at which the step appears.
    &#34;&#34;&#34;
    k = dy.counter()
    y = dy.int32(k_step) &lt;= k

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_step_wise_sequence"><code class="name flex">
<span>def <span class="ident">signal_step_wise_sequence</span></span>(<span>time_instance_indices, values, time_scale=None, counter=None, reset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>signal generator for a step-wise changeing signal</p>
<p>time_instance_indices - an array of sampling instants at which the signal changes its values
values
- an array of values; must have one more element than time_instance_indices
time_scale
- multiplies all elements of time_instance_indices by the given factor (optional)
counter
- an alternative sample counter (optional)
reset
- boolean signal to reset the sequence (optional)</p>
<h2 id="example">Example</h2>
<p>time_instance_indices = [
50, 100, 150, 250, 300, 350, 400,
450, 500
]
values
= [ 0, -1.0,
0, 1.0,
0, -1.0, 0,
0.2, -0.2, 0
]</p>
<p>v = step_wise_sequence( time_instance_indices, values )</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_step_wise_sequence( time_instance_indices, values, time_scale=None, counter=None, reset=None ):
    &#34;&#34;&#34;
        signal generator for a step-wise changeing signal

        time_instance_indices - an array of sampling instants at which the signal changes its values
        values                - an array of values; must have one more element than time_instance_indices
        time_scale            - multiplies all elements of time_instance_indices by the given factor (optional)
        counter               - an alternative sample counter (optional)
        reset                 - boolean signal to reset the sequence (optional)

        Example
        -------

        time_instance_indices = [      50, 100, 150, 250, 300, 350, 400,  450, 500  ]
        values                = [ 0, -1.0,   0, 1.0,  0, -1.0, 0,   0.2, -0.2, 0   ]

        v = step_wise_sequence( time_instance_indices, values )
    &#34;&#34;&#34;
    
    if len(values) - 1 != len(time_instance_indices):
        raise BaseException( &#34;len(values) - 1 != len(time_instance_indices)&#34; )

    if counter is None:
        counter = dy.counter()

    indices_mem = dy.memory(datatype=dy.DataTypeInt32(1),   constant_array=time_instance_indices )
    values_mem  = dy.memory(datatype=dy.DataTypeFloat64(1), constant_array=values )

    current_index = dy.signal()

    current_time_index_to_check = dy.memory_read( indices_mem, current_index )

    # scale time
    if time_scale is not None:
        index_to_check = time_scale * current_time_index_to_check
    else:
        index_to_check = current_time_index_to_check

    # check wether to step to the next sample
    increase_index = dy.int32(0)
    increase_index = dy.conditional_overwrite(increase_index, counter &gt;= index_to_check, dy.int32(1) )
    current_index &lt;&lt; dy.counter_triggered(upper_limit=len(time_instance_indices), stepwidth=increase_index, reset=reset )

    val = dy.memory_read(values_mem, current_index)

    return val</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sin"><code class="name flex">
<span>def <span class="ident">sin</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sin(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;sin&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sqrt"><code class="name flex">
<span>def <span class="ident">sqrt</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Square root</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sqrt(u : SignalUserTemplate ):
    &#34;&#34;&#34;
    Square root
    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;sqrt&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, initial_state=0, no_delay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulative sum</p>
<p>The difference equation</p>
<pre><code>y[k+1] = y[k] + u[k]
</code></pre>
<p>is evaluated. The return value is either</p>
<pre><code>y[k]   by default or when no_delay == False
</code></pre>
<p>or</p>
<pre><code>y[k+1] in case no_delay == True .
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(u : Signal, initial_state=0, no_delay=False):
    &#34;&#34;&#34;
        Accumulative sum

        The difference equation

            y[k+1] = y[k] + u[k]

        is evaluated. The return value is either

            y[k]   by default or when no_delay == False
        or

            y[k+1] in case no_delay == True .
    &#34;&#34;&#34;

    y_k = dy.signal()
    
    y_kp1 = y_k + u

    y_k &lt;&lt; dy.delay(y_kp1, initial_state=initial_state)

    if no_delay:
        return y_kp1
    else:
        return y_k</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sum2"><code class="name flex">
<span>def <span class="ident">sum2</span></span>(<span>u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, initial_state=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulative sum</p>
<p>The difference equation</p>
<pre><code>y[k+1] = y[k] + u[k]
</code></pre>
<p>is evaluated. The return values are</p>
<pre><code>y[k], y[k+1]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum2(u : Signal, initial_state=0):
    &#34;&#34;&#34;
        Accumulative sum

        The difference equation

            y[k+1] = y[k] + u[k]

        is evaluated. The return values are

            y[k], y[k+1]
    &#34;&#34;&#34;

    y_k = dy.signal()
    
    y_kp1 = y_k + u

    y_k &lt;&lt; dy.delay(y_kp1, initial_state=initial_state)

    return y_k, y_kp1</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.switchNto1"><code class="name flex">
<span>def <span class="ident">switchNto1</span></span>(<span>state: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, inputs: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switchNto1( state : SignalUserTemplate, inputs : SignalUserTemplate ):
    return wrap_signal( SwitchNto1(dy.get_system_context(), state.unwrap, unwrap_list(inputs) ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.system_input"><code class="name flex">
<span>def <span class="ident">system_input</span></span>(<span>datatype, name: str = None, default_value=None, value_range=None, title: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Introduce a new system input signal</p>
<p>datatype
- the datatype of the signal
name
- the name of the signal
default_value - the default value the will be applied to the system input by default
value_range
- the available numeric range for the signal the form [min, max]<br>
title
- the description of the signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_input(datatype, name : str = None, default_value=None, value_range=None, title : str = &#34;&#34;):
    &#34;&#34;&#34;
        Introduce a new system input signal

        datatype      - the datatype of the signal
        name          - the name of the signal
        default_value - the default value the will be applied to the system input by default
        value_range   - the available numeric range for the signal the form [min, max]  
        title         - the description of the signal
    &#34;&#34;&#34;

    signal = si.SimulationInputSignalUser(get_system_context(), datatype)

    if name is not None:
        signal.set_name(name)

    properties = {}

    if default_value is not None:
        properties[&#39;default_value&#39;] = default_value

    if value_range is not None:
        properties[&#39;range&#39;] = value_range

    if title is not None:
        properties[&#39;title&#39;] = title

    signal.set_properties(properties)

    return signal </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.tan"><code class="name flex">
<span>def <span class="ident">tan</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tan(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;tan&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.toggle"><code class="name flex">
<span>def <span class="ident">toggle</span></span>(<span>trigger, initial_state=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle(trigger, initial_state=False):

    state = dy.signal()

    activate   = dy.logic_and( dy.logic_not( state ), trigger )
    deactivate = dy.logic_and( trigger , state)

    tmp = dy.flipflop( activate, deactivate, 
                            initial_state = 0, 
                            nodelay=False )

    state &lt;&lt; tmp

    return state, activate, deactivate</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.transfer_function_discrete"><code class="name flex">
<span>def <span class="ident">transfer_function_discrete</span></span>(<span>u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, num_coeff: List[float], den_coeff: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>Discrete time transfer function</p>
<p>u
- input signal
num_coeff - list of numerator coefficients of the transfer function
den_coeff - list of denominator coefficients of the transfer function</p>
<p>returns the output of the filter</p>
<h2 id="details">Details:</h2>
<p>This filter realizes a discrete-time transfer function by using 'direct form II'
c.f. <a href="https://en.wikipedia.org/wiki/Digital_filter">https://en.wikipedia.org/wiki/Digital_filter</a> .</p>
<pre><code>    b0 + b1 z^-1 + b2 z^-2 + ... + bN z^-N
</code></pre>
<p>H(z) = ----------------------------------------
1 + a1 z^-1 + a2 z^-2 + &hellip; + aM z^-M</p>
<p>The coefficient vectors num_coeff and den_coeff describe the numerator and
denominator polynomials, respectively, and are defined as follows:</p>
<p>num_coeff = [b0, b1, .., bN]
den_coeff = [a1, a2, &hellip; aM] .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_function_discrete(u : Signal, num_coeff : t.List[float], den_coeff : t.List[float] ):

    &#34;&#34;&#34;
    Discrete time transfer function

    u         - input signal
    num_coeff - list of numerator coefficients of the transfer function
    den_coeff - list of denominator coefficients of the transfer function

    returns the output of the filter

    Details:
    --------

    This filter realizes a discrete-time transfer function by using &#39;direct form II&#39;
    c.f. https://en.wikipedia.org/wiki/Digital_filter .

            b0 + b1 z^-1 + b2 z^-2 + ... + bN z^-N
    H(z) = ----------------------------------------
             1 + a1 z^-1 + a2 z^-2 + ... + aM z^-M

    The coefficient vectors num_coeff and den_coeff describe the numerator and 
    denominator polynomials, respectively, and are defined as follows:

    num_coeff = [b0, b1, .., bN]
    den_coeff = [a1, a2, ... aM] .
    
    &#34;&#34;&#34;


    # get filter order
    N = len(num_coeff)-1

    # feedback start signal
    z_pre = dy.signal()

    # array to store state signals
    z_ = []

    # create delay chain
    z_iterate = z_pre
    for i in range(0,N):

        z_iterate = dy.delay( z_iterate ).extendName(&#39;_z&#39; + str(i) )
        z_.append( z_iterate ) 


    # build feedback path
    #
    # a1 = den_coeff[0]
    # a2 = den_coeff[1]
    # a3 = den_coeff[2]
    #        ...
    sum_feedback = u
    for i in range(0,N):

        a_ip1 = dy.float64( den_coeff[i] ).extendName(&#39;_a&#39; + str(i+1) )

        sum_feedback = sum_feedback - a_ip1 * z_[i]

    sum_feedback.extendName(&#39;_i&#39;)


    # close the feedback loop
    z_pre &lt;&lt; sum_feedback

    # build output path
    #
    # b0 = num_coeff[0]
    # b1 = num_coeff[1]
    # b2 = num_coeff[2]
    #        ...    
    for i in range(0,N+1):
        
        b_i = dy.float64( num_coeff[i] ).extendName(&#39;_b&#39; + str(i) )

        if i==0:
            y = b_i * sum_feedback
        else:
            y = y + b_i * z_[i-1]

    # y is the filter output   
    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.unwrap_angle"><code class="name flex">
<span>def <span class="ident">unwrap_angle</span></span>(<span>angle, normalize_around_zero=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unwrap an angle</p>
<p>Unrap and normalize the input angle to the range </p>
<p>1) [0, 2*pi[
in case normalize_around_zero == false
2) [-pi, pi]
in case normalize_around_zero == true</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_angle(angle, normalize_around_zero = False):
    &#34;&#34;&#34;
        Unwrap an angle

        Unrap and normalize the input angle to the range 

          1) [0, 2*pi[     in case normalize_around_zero == false
          2) [-pi, pi]     in case normalize_around_zero == true
    &#34;&#34;&#34;

    def normalize_aruond_zero(angle):
        &#34;&#34;&#34;
            Normalize an angle

            Normalize an angle to a range [-pi, pi]

            Important: the assumed range for the input is - 2*pi &lt;= angle &lt;= 2*p
        &#34;&#34;&#34;

        tmp = angle            + dy.conditional_overwrite( dy.float64(0), angle &lt;= float64(-math.pi), 2*math.pi )
        normalized_angle = tmp + dy.conditional_overwrite( dy.float64(0), angle &gt; float64(math.pi), -2*math.pi )

        return normalized_angle

    #
    #
    angle_ = dy.fmod(angle, dy.float64(2*math.pi) )

    unwrapped_angle = angle_ + dy.conditional_overwrite( dy.float64(0), angle_ &lt; float64(0), 2*math.pi )

    if normalize_around_zero:
        return normalize_aruond_zero(unwrapped_angle)
    else:
        return unwrapped_angle</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="openrtdynamics2.lang.DataTypeArray"><code class="flex name class">
<span>class <span class="ident">DataTypeArray</span></span>
<span>(</span><span>length: int, datatype: <a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeArray(DataType):

    def __init__(self, length : int, datatype : DataType ):
        DataType.__init__(self, type=None, size=1)

        self._array_element_datatype = datatype
        self._length    = length

    @property
    def cppDataType(self):
        return self._array_element_datatype.cppDataType + &#39; [&#39; + str(self._length) + &#39;]&#39;
    
    @property
    def datatype_of_elements(self):
        return self._array_element_datatype

    def cpp_define_variable(self, variable_name, make_a_reference = False):

        if make_a_reference:
            variable_name_ = &#39; (&amp;&#39; + variable_name + &#39;)&#39;
        else:
            variable_name_ = variable_name

        return self._array_element_datatype.cppDataType + &#39; &#39; + variable_name_ + &#39;[&#39; + str(self._length) + &#39;]&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeArray.cppDataType"><code class="name">var <span class="ident">cppDataType</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cppDataType(self):
    return self._array_element_datatype.cppDataType + &#39; [&#39; + str(self._length) + &#39;]&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeArray.datatype_of_elements"><code class="name">var <span class="ident">datatype_of_elements</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def datatype_of_elements(self):
    return self._array_element_datatype</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeArray.cpp_define_variable"><code class="name flex">
<span>def <span class="ident">cpp_define_variable</span></span>(<span>self, variable_name, make_a_reference=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cpp_define_variable(self, variable_name, make_a_reference = False):

    if make_a_reference:
        variable_name_ = &#39; (&amp;&#39; + variable_name + &#39;)&#39;
    else:
        variable_name_ = variable_name

    return self._array_element_datatype.cppDataType + &#39; &#39; + variable_name_ + &#39;[&#39; + str(self._length) + &#39;]&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.DataTypeBoolean"><code class="flex name class">
<span>class <span class="ident">DataTypeBoolean</span></span>
<span>(</span><span>size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeBoolean(DataType):

    def __init__(self, size : int):
        DataType.__init__(self, type=ORTD_DATATYPE_BOOLEAN, size=size)

    @property
    def cppDataType(self):
        return &#39;bool&#39;

    @property
    def cppPrintfPattern(self):
        return &#39;%d&#39;

    @property
    def cpp_zero_element(self):
        return &#39;false&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeBoolean.cppDataType"><code class="name">var <span class="ident">cppDataType</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cppDataType(self):
    return &#39;bool&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeBoolean.cppPrintfPattern"><code class="name">var <span class="ident">cppPrintfPattern</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cppPrintfPattern(self):
    return &#39;%d&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeBoolean.cpp_zero_element"><code class="name">var <span class="ident">cpp_zero_element</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_zero_element(self):
    return &#39;false&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.DataTypeFloat64"><code class="flex name class">
<span>class <span class="ident">DataTypeFloat64</span></span>
<span>(</span><span>size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeFloat64(DataTypeNumeric):

    def __init__(self, size : int):
        DataType.__init__(self, type=ORTD_DATATYPE_FLOAT, size=size)

    @property
    def cppDataType(self):
        return &#39;double&#39;

    @property
    def cppPrintfPattern(self):
        return &#39;%f&#39;

    @property
    def cpp_zero_element(self):
        return &#39;0.0&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeNumeric" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeNumeric">DataTypeNumeric</a></li>
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeFloat64.cppDataType"><code class="name">var <span class="ident">cppDataType</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cppDataType(self):
    return &#39;double&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeFloat64.cppPrintfPattern"><code class="name">var <span class="ident">cppPrintfPattern</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cppPrintfPattern(self):
    return &#39;%f&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeFloat64.cpp_zero_element"><code class="name">var <span class="ident">cpp_zero_element</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_zero_element(self):
    return &#39;0.0&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.DataTypeInt32"><code class="flex name class">
<span>class <span class="ident">DataTypeInt32</span></span>
<span>(</span><span>size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeInt32(DataTypeNumeric):

    def __init__(self, size : int):

        DataType.__init__(self, type=ORTD_DATATYPE_INT32, size=size)

    @property
    def cppDataType(self):
        return &#39;int32_t&#39;

    @property
    def cppPrintfPattern(self):
        return &#39;%d&#39;

    @property
    def cpp_zero_element(self):
        return &#39;0&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeNumeric" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeNumeric">DataTypeNumeric</a></li>
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeInt32.cppDataType"><code class="name">var <span class="ident">cppDataType</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cppDataType(self):
    return &#39;int32_t&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeInt32.cppPrintfPattern"><code class="name">var <span class="ident">cppPrintfPattern</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cppPrintfPattern(self):
    return &#39;%d&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeInt32.cpp_zero_element"><code class="name">var <span class="ident">cpp_zero_element</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_zero_element(self):
    return &#39;0&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.DataTypeNumeric"><code class="flex name class">
<span>class <span class="ident">DataTypeNumeric</span></span>
<span>(</span><span>size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeNumeric(DataType):
    def __init__(self, size : int):
        DataType.__init__(self, type=ORTD_DATATYPE_FLOAT, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeFloat64" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeFloat64">DataTypeFloat64</a></li>
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeInt32" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeInt32">DataTypeInt32</a></li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.PutBasicRuntimeCpp"><code class="flex name class">
<span>class <span class="ident">PutBasicRuntimeCpp</span></span>
<span>(</span><span>i_max: int, input_signals_mapping={})</span>
</code></dt>
<dd>
<div class="desc"><p>generates code for the runtime evironment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PutBasicRuntimeCpp(PutRuntimeCppHelper):
    &#34;&#34;&#34;
        generates code for the runtime evironment
    &#34;&#34;&#34;

    def __init__(self, i_max : int, input_signals_mapping = {} ):

        self._i_max = i_max

        PutRuntimeCppHelper.__init__(self)

        self.input_signals_mapping = input_signals_mapping
        self.initCodeTemplate()

        
    def code_gen(self):

        # call helper to fill in some generic elements into the template
        code_gen_results = PutRuntimeCppHelper.code_gen(self)

        #
        # make strings 
        # 

        # constant inputs
        inputConstAssignments = []
        for signal, value in self.input_signals_mapping.items():
            inputConstAssignments.append( signal.name + &#39; = &#39; + str(value) )

        inputConstAssignment = &#39;; &#39;.join( inputConstAssignments ) + &#39;;&#39;

        self.sourceCode = Template(self.template).safe_substitute( iMax=self._i_max,
                                                                 inputConstAssignment=inputConstAssignment    ) 

        code_gen_results[&#39;sourcecode&#39;] = self.sourceCode
        return code_gen_results

    def write_code(self, folder):
        PutRuntimeCppHelper.writeFiles(self, folder)

        self.codeFolder = folder

        f = open(os.path.join( folder + &#34;main.cpp&#34;), &#34;w&#34;)
        f.write( self.sourceCode )
        f.close()


    def build(self):
        os.system(&#34;c++ &#34; + self.codeFolder + &#34;main.cpp -o &#34; + self.codeFolder + &#34;main&#34;)


    def run(self):
        # run the generated executable
        p = subprocess.Popen(self.codeFolder + &#39;main&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        retval = p.wait()

        # parse csv data
        data = [ ]
        outputs = range(0, len(self.main_command.command_to_put_main_system.outputCommand.outputSignals) )

        for o in outputs:
            data.append( [] )

        for line in p.stdout.readlines():
            sample = line.decode(&#34;utf-8&#34;).split(&#39; &#39;)

            for o in outputs:
                data[ o ].append( float( sample[o] ) )

        # put data into a key-array
        dataStruct = { }
        o = 0
        for s in self.main_command.command_to_put_main_system.outputCommand.outputSignals:
            dataStruct[ s.name ] = data[o]

            o = o + 1

        return dataStruct


    def initCodeTemplate(self):

        #
        # template for main function in c++
        #

        self.template = &#34;&#34;&#34;
            
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

//
// implementation of $mainSimulationName
//

$algorithmCode

//
// main
//

int main () {

    // create an instance of the simulation
    $mainSimulationName simulation;

    // input signals
    $inputAll_NamesVarDef

    // output signals
    $outputNamesVarDef

    // const assignments of the input signals
    $inputConstAssignment

    // reset the simulation
    simulation.resetStates();

    // simulate
    int i;

    for (i=0; i&lt; $iMax; ++i) {
        simulation.calcResults_1( $calcOutputsArgs );
        simulation.updateStates(  $input2_NamesCSVList );

        printf(&#34;$outputPrinfPattern\\n&#34;, $outputNamesCSVList);
    }

}

            
        &#34;&#34;&#34;        </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper">PutRuntimeCppHelper</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.PutBasicRuntimeCpp.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self):
    os.system(&#34;c++ &#34; + self.codeFolder + &#34;main.cpp -o &#34; + self.codeFolder + &#34;main&#34;)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutBasicRuntimeCpp.code_gen"><code class="name flex">
<span>def <span class="ident">code_gen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_gen(self):

    # call helper to fill in some generic elements into the template
    code_gen_results = PutRuntimeCppHelper.code_gen(self)

    #
    # make strings 
    # 

    # constant inputs
    inputConstAssignments = []
    for signal, value in self.input_signals_mapping.items():
        inputConstAssignments.append( signal.name + &#39; = &#39; + str(value) )

    inputConstAssignment = &#39;; &#39;.join( inputConstAssignments ) + &#39;;&#39;

    self.sourceCode = Template(self.template).safe_substitute( iMax=self._i_max,
                                                             inputConstAssignment=inputConstAssignment    ) 

    code_gen_results[&#39;sourcecode&#39;] = self.sourceCode
    return code_gen_results</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutBasicRuntimeCpp.initCodeTemplate"><code class="name flex">
<span>def <span class="ident">initCodeTemplate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def initCodeTemplate(self):

        #
        # template for main function in c++
        #

        self.template = &#34;&#34;&#34;
            
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

//
// implementation of $mainSimulationName
//

$algorithmCode

//
// main
//

int main () {

    // create an instance of the simulation
    $mainSimulationName simulation;

    // input signals
    $inputAll_NamesVarDef

    // output signals
    $outputNamesVarDef

    // const assignments of the input signals
    $inputConstAssignment

    // reset the simulation
    simulation.resetStates();

    // simulate
    int i;

    for (i=0; i&lt; $iMax; ++i) {
        simulation.calcResults_1( $calcOutputsArgs );
        simulation.updateStates(  $input2_NamesCSVList );

        printf(&#34;$outputPrinfPattern\\n&#34;, $outputNamesCSVList);
    }

}

            
        &#34;&#34;&#34;        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutBasicRuntimeCpp.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    # run the generated executable
    p = subprocess.Popen(self.codeFolder + &#39;main&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    retval = p.wait()

    # parse csv data
    data = [ ]
    outputs = range(0, len(self.main_command.command_to_put_main_system.outputCommand.outputSignals) )

    for o in outputs:
        data.append( [] )

    for line in p.stdout.readlines():
        sample = line.decode(&#34;utf-8&#34;).split(&#39; &#39;)

        for o in outputs:
            data[ o ].append( float( sample[o] ) )

    # put data into a key-array
    dataStruct = { }
    o = 0
    for s in self.main_command.command_to_put_main_system.outputCommand.outputSignals:
        dataStruct[ s.name ] = data[o]

        o = o + 1

    return dataStruct</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutBasicRuntimeCpp.write_code"><code class="name flex">
<span>def <span class="ident">write_code</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_code(self, folder):
    PutRuntimeCppHelper.writeFiles(self, folder)

    self.codeFolder = folder

    f = open(os.path.join( folder + &#34;main.cpp&#34;), &#34;w&#34;)
    f.write( self.sourceCode )
    f.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper">PutRuntimeCppHelper</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper.get_algorithm_code" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper.get_algorithm_code">get_algorithm_code</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.PutRuntimeCppHelper"><code class="flex name class">
<span>class <span class="ident">PutRuntimeCppHelper</span></span>
<span>(</span><span>enable_tracing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generates code for the runtime environment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PutRuntimeCppHelper:
    &#34;&#34;&#34;
        generates code for the runtime environment
    &#34;&#34;&#34;

    def __init__(self, enable_tracing=False ):
        ExecutionCommand.__init__(self)  # TODO: what is this?

        # if compile_results is not None:
        #     self.compileResults = compile_results
        #     self.main_command = compile_results.command_to_execute

        # else:

        # those are set via set_compile_results after a system is compiled
        self.compileResults = None
        self.main_command = None

        #
        self._algorithm_code = None

        # list of inlcuded system
        self._includedSystems = []

        self._enable_tracing = enable_tracing

    def set_compile_results(self, compile_results : CompileResults ):
        self.compileResults = compile_results
        self.main_command = compile_results.command_to_execute

    def include_systems(self, system : SystemLibraryEntry):
        self._includedSystems = system

    def get_algorithm_code(self):
        &#34;&#34;&#34;
            Return only the code that implement the system and all sub systems
        &#34;&#34;&#34;
        return self._algorithm_code



    def code_gen(self):

        # generate code for the algorithm
        self.manifest, self._algorithm_code = generate_algorithm_code(self.compileResults, self._enable_tracing, self._includedSystems)

        
        # TODO: iterate over all functions present in the API of the system
        # NOTE: Currently only the main functions are used: output, update, and reset
        #
        API_functions = self.main_command.command_to_put_main_system.API_functions

        #
        # make strings 
        # 

        def makeStrings(signals):
            names_CSV_list = cgh.signal_list_to_names_string(signals)
            names_var_def = cgh.define_variable_list_string(signals)
            printf_pattern = cgh.signalListHelper_printfPattern_string(signals)

            return names_CSV_list, names_var_def, printf_pattern


        # for the output signals
        # input1_NamesCSVList; list of output signals. e.g. &#39;y1, y2, y3&#39; 
        outputNamesCSVList, outputNamesVarDef, outputPrinfPattern = makeStrings( self.main_command.command_to_put_main_system.outputCommand.outputSignals )

        # the inputs to the output command
        # input1_NamesCSVList: list of output signals. e.g. &#39;y1, y2, y3&#39; 
        input1_NamesCSVList, input1_NamesVarDef, input1PrinfPattern = makeStrings( self.main_command.command_to_put_main_system.outputCommand.inputSignals )

        # the inputs to the update command
        # input2_NamesCSVList list of output signals. e.g. &#39;u1, u2, u3&#39; 
        input2_NamesCSVList, input2_NamesVarDef, input2_PrinfPattern = makeStrings( self.main_command.command_to_put_main_system.updateCommand.inputSignals )

        # all inputs
        # merge the list of inputs for the calcoutput and stateupdate function
        allInputs = list(set(self.main_command.command_to_put_main_system.outputCommand.inputSignals + self.main_command.command_to_put_main_system.updateCommand.inputSignals))
        inputAll_NamesCSVList, inputAll_NamesVarDef, inputAll_PrinfPattern = makeStrings( allInputs )

        # the names of input and output signals of the outputCommand combined
        calcOutputsArgs = cgh.signal_list_to_name_list( self.main_command.command_to_put_main_system.outputCommand.outputSignals + self.main_command.command_to_put_main_system.outputCommand.inputSignals )

        # fill in template
        self.template = Template(self.template).safe_substitute(  
                                                    mainSimulationName = self.main_command.command_to_put_main_system.API_name,
                                                    algorithmCode=self._algorithm_code,

                                                    input1_NamesVarDef=input1_NamesVarDef,
                                                    input1_NamesCSVList=input1_NamesCSVList,

                                                    input2_NamesVarDef=input2_NamesVarDef,
                                                    input2_NamesCSVList=input2_NamesCSVList,

                                                    inputAll_NamesVarDef=inputAll_NamesVarDef,
                                                    inputAll_NamesCSVList=inputAll_NamesCSVList,

                                                    outputNamesCSVList=outputNamesCSVList, 
                                                    outputNamesVarDef=outputNamesVarDef,
                                                    outputPrinfPattern=outputPrinfPattern,
                                                    
                                                    calcOutputsArgs=calcOutputsArgs )


        return {&#39;sourcecode&#39; : self.template, &#39;manifest&#39; : self.manifest, &#39;algorithm_sourcecode&#39; : self._algorithm_code }

    def writeFiles(self, folder):

        with open( os.path.join( folder + &#39;//simulation_manifest.json&#39; ), &#39;w&#39;) as outfile:  
            json.dump(self.manifest, outfile)

    def build(self):
        pass

    def run(self):
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.code_generation_templates.PutBasicRuntimeCpp" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.PutBasicRuntimeCpp">PutBasicRuntimeCpp</a></li>
<li><a title="openrtdynamics2.lang.code_generation_templates.WasmRuntime" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.WasmRuntime">WasmRuntime</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.PutRuntimeCppHelper.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self):
    pass</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutRuntimeCppHelper.code_gen"><code class="name flex">
<span>def <span class="ident">code_gen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_gen(self):

    # generate code for the algorithm
    self.manifest, self._algorithm_code = generate_algorithm_code(self.compileResults, self._enable_tracing, self._includedSystems)

    
    # TODO: iterate over all functions present in the API of the system
    # NOTE: Currently only the main functions are used: output, update, and reset
    #
    API_functions = self.main_command.command_to_put_main_system.API_functions

    #
    # make strings 
    # 

    def makeStrings(signals):
        names_CSV_list = cgh.signal_list_to_names_string(signals)
        names_var_def = cgh.define_variable_list_string(signals)
        printf_pattern = cgh.signalListHelper_printfPattern_string(signals)

        return names_CSV_list, names_var_def, printf_pattern


    # for the output signals
    # input1_NamesCSVList; list of output signals. e.g. &#39;y1, y2, y3&#39; 
    outputNamesCSVList, outputNamesVarDef, outputPrinfPattern = makeStrings( self.main_command.command_to_put_main_system.outputCommand.outputSignals )

    # the inputs to the output command
    # input1_NamesCSVList: list of output signals. e.g. &#39;y1, y2, y3&#39; 
    input1_NamesCSVList, input1_NamesVarDef, input1PrinfPattern = makeStrings( self.main_command.command_to_put_main_system.outputCommand.inputSignals )

    # the inputs to the update command
    # input2_NamesCSVList list of output signals. e.g. &#39;u1, u2, u3&#39; 
    input2_NamesCSVList, input2_NamesVarDef, input2_PrinfPattern = makeStrings( self.main_command.command_to_put_main_system.updateCommand.inputSignals )

    # all inputs
    # merge the list of inputs for the calcoutput and stateupdate function
    allInputs = list(set(self.main_command.command_to_put_main_system.outputCommand.inputSignals + self.main_command.command_to_put_main_system.updateCommand.inputSignals))
    inputAll_NamesCSVList, inputAll_NamesVarDef, inputAll_PrinfPattern = makeStrings( allInputs )

    # the names of input and output signals of the outputCommand combined
    calcOutputsArgs = cgh.signal_list_to_name_list( self.main_command.command_to_put_main_system.outputCommand.outputSignals + self.main_command.command_to_put_main_system.outputCommand.inputSignals )

    # fill in template
    self.template = Template(self.template).safe_substitute(  
                                                mainSimulationName = self.main_command.command_to_put_main_system.API_name,
                                                algorithmCode=self._algorithm_code,

                                                input1_NamesVarDef=input1_NamesVarDef,
                                                input1_NamesCSVList=input1_NamesCSVList,

                                                input2_NamesVarDef=input2_NamesVarDef,
                                                input2_NamesCSVList=input2_NamesCSVList,

                                                inputAll_NamesVarDef=inputAll_NamesVarDef,
                                                inputAll_NamesCSVList=inputAll_NamesCSVList,

                                                outputNamesCSVList=outputNamesCSVList, 
                                                outputNamesVarDef=outputNamesVarDef,
                                                outputPrinfPattern=outputPrinfPattern,
                                                
                                                calcOutputsArgs=calcOutputsArgs )


    return {&#39;sourcecode&#39; : self.template, &#39;manifest&#39; : self.manifest, &#39;algorithm_sourcecode&#39; : self._algorithm_code }</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutRuntimeCppHelper.get_algorithm_code"><code class="name flex">
<span>def <span class="ident">get_algorithm_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return only the code that implement the system and all sub systems</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_algorithm_code(self):
    &#34;&#34;&#34;
        Return only the code that implement the system and all sub systems
    &#34;&#34;&#34;
    return self._algorithm_code</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutRuntimeCppHelper.include_systems"><code class="name flex">
<span>def <span class="ident">include_systems</span></span>(<span>self, system: <a title="openrtdynamics2.lang.libraries.SystemLibraryEntry" href="libraries.html#openrtdynamics2.lang.libraries.SystemLibraryEntry">SystemLibraryEntry</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def include_systems(self, system : SystemLibraryEntry):
    self._includedSystems = system</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutRuntimeCppHelper.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    pass</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutRuntimeCppHelper.set_compile_results"><code class="name flex">
<span>def <span class="ident">set_compile_results</span></span>(<span>self, compile_results: <a title="openrtdynamics2.lang.diagram_core.diagram_compiler.CompileResults" href="diagram_core/diagram_compiler.html#openrtdynamics2.lang.diagram_core.diagram_compiler.CompileResults">CompileResults</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compile_results(self, compile_results : CompileResults ):
    self.compileResults = compile_results
    self.main_command = compile_results.command_to_execute</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.PutRuntimeCppHelper.writeFiles"><code class="name flex">
<span>def <span class="ident">writeFiles</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeFiles(self, folder):

    with open( os.path.join( folder + &#39;//simulation_manifest.json&#39; ), &#39;w&#39;) as outfile:  
        json.dump(self.manifest, outfile)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.Signal"><code class="flex name class">
<span>class <span class="ident">Signal</span></span>
<span>(</span><span>sim, autogeneratedName: str, datatype=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signal(object):
    
    def __init__(self, sim, autogeneratedName : str, datatype = None ):
        self.sim = sim
        
        # the fixed and final datatype of this signals either as a result of the datatype determination phase
        # or manually fixed.
        self._datatype = datatype

        # datatype proposal that may be filled out during the datatype determination phase
        self.proposedDatatype = None

        # indicates a signal that is not computed by a set of instructions but points to a memory containing the value
        self._is_referencing_memory = False

        # give this signal a unique default name
        self._name = autogeneratedName
        self._nameIsDefault = True

        # the list of destinations this signals goes to
        self.destinationBlocks = []
        self.destinationPorts = []

        # the list of signals to which the datatype of this signal is inherited
        self._inherit_datatype_to_list = []

        # used by graph_traversion as a helper variable to perform a marking of the graph nodes
        self.graphTraversionMarker = -1

        # inherit the datatype for this anonymous signals from the signal refered to by inherit_datatype_of_signal
        self.inherit_datatype_of_signal = None







        # In case not None: the data/value of the signal are aboutained from the given signal
        # NOTE: not used so far.
        self._data_link = None









        # NOTE: this mus be the last in the list
        # notify the creation of this signal
        self.sim.datatype_propagation_instance.notifySignal(self)

        # properties (user)
        self._properties = None

        # properties (internal, controlled by block prototypes)
        self.properties_internal = {}

        # optional: port number of input / output w.r.t. to the system &#39;sim&#39;
        self.port = None

    @property
    def properties(self):
        return self.lookupSource()._properties

    def set_properties(self, p):
        self.lookupSource()._properties = p

    # TODO: remove
    def getDatatype(self):
        return self.lookupSource()._datatype

    @property
    def datatype(self):
        return self.lookupSource()._datatype
    
    def update_datatype_config(self, datatype):
        &#34;&#34;&#34;
            set the datatype in case it was not defined in the constructor
        &#34;&#34;&#34;
        if self.lookupSource()._datatype is not None:
            raise BaseException(&#34;datatype already defined&#34;)
        
        self.lookupSource()._datatype = datatype


    @property
    def is_referencing_memory(self):
        return self._is_referencing_memory

    def set_is_referencing_memory(self, val : bool):
        self._is_referencing_memory = val

    @property
    def nameIsDefault(self):
        return self._nameIsDefault

    @property
    def system(self):
        # system == simulation
        return self.sim

    # in case resolveUndeterminedSignals becomes obsolet, those 3 fns might be important
    # otherwise TODO: remove them
    def is_proxy(self):
        return self.lookupSource().is_proxy()

    def is_block_output(self):
        return self.lookupSource().is_block_output()

    def is_simulation_input(self):
        return self.lookupSource().is_simulation_input()


    def is_crossing_system_boundary(self, system):

        &#34;&#34;&#34;
            test if fot the given system this signals comes from an outer/higher level
            system.
        &#34;&#34;&#34;

        if self.sim == system:
            return False

        # check if this signal is coming from an upper/outer system 
        # (if not it comes from a parallel system that cannot be accessed: this is an error)

        # go up in the system-nesting hirachy starting at system
        system_iter = system

        while system_iter.parent_system is not None:

            if system_iter.parent_system == self.system:
                return True

            system_iter = system_iter.parent_system

        raise BaseException(&#34;Bad access to signal &#34; + Fore.YELLOW + self.name + Fore.RESET + &#34;: did you access a signal from another subsystem that cannot be reached?&#34;)

    def lookupSource(self):
        return self

    def graphTraversionMarkerReset(self):
        self.lookupSource().graphTraversionMarker = -1

    def graphTraversionMarkerMarkVisited(self, level):
        if level &lt; 0:
            raise BaseException(&#34;level cannot be &lt; 0&#34;)

        self.lookupSource().graphTraversionMarker = level
    
    def graphTraversionMarkerMarkIsVisited(self):
        # check of this node was marked on level or a level below
        return self.lookupSource().graphTraversionMarker &gt;= 0

    def graphTraversionMarkerMarkIsVisitedOnLevelLowerThan(self, onLevel):
        # check of this node was marked on level or a level below
        return self.graphTraversionMarkerMarkIsVisited() and self.lookupSource().graphTraversionMarker &lt; onLevel

    # set the name of this signal
    def set_name(self, name):
        self.lookupSource()._name = name

        # indicate that this Signal has a specified name (not a default/auto-generated name)
        self._nameIsDefault = False

        return self

    # set the name of this signal (this method shall not get overwritten)
    def set_name_raw(self, name):
        self.lookupSource()._name = name

        # indicate that this Signal has a specified name (not a default/auto-generated name)
        self._nameIsDefault = False

        return self

        


    @property
    def name(self):
        return self.lookupSource()._name

    def toStr(self):
        ret = &#39;&#39;
        ret += self.name

        if self.datatype is not None:
            ret += &#34; (&#34; + self.datatype.toStr() + &#34;)&#34;
        else:
            # ret += &#34; (undef datatype)&#34;
            pass


        if self.lookupSource().proposedDatatype is not None:
            ret += &#34; type proposal: (&#34; + self.lookupSource().proposedDatatype.toStr() + &#34;)&#34;
        else:
            # ret += &#34;proposal: (undef datatype)&#34;
            pass

        if self.lookupSource().inherit_datatype_of_signal is not None:
            ret = ret + &#39;type inherit from &#39; + self.lookupSource().inherit_datatype_of_signal.name

        return ret
        

    def addDestination(self, block , port : int):
        # add this destination to the list
        self.lookupSource().destinationBlocks.append( block )
        self.lookupSource().destinationPorts.append( port )

    def getDestinationBlocks(self):
        return self.lookupSource().destinationBlocks



    def setDatatype_nonotitication(self, datatype):
        self.lookupSource()._datatype = datatype

        # TODO: maybe there should be a notification in the next step in the datatype propagation phase?
        # e.g.:
        # self.lookupSource()._datatype_changed_but_not_notified_so_far = True

    def setDatatype(self, datatype):

        self.setDatatype_nonotitication( datatype )

        # NOTE: should be added lookupSource() here (though effectively no difference)
        # notify the change of the datatype
        self.sim.datatype_propagation_instance.notifySignal(self)

    def fixDatatype(self):
        # this shall explicitely not trigger a notification!
        self.lookupSource()._datatype = self.lookupSource().proposedDatatype

    def getProposedDatatype(self):
        return self.lookupSource().proposedDatatype

    def setProposedDatatype(self, proposedDatatype):
        # only proceed if the datatype of this signals is not already fixed
        if self.lookupSource()._datatype is None:

            # only proceed of the prosed datatype is diffent to the stored one
            # or the stored type is None (not set before)
            if not proposedDatatype.isEqualTo( self.lookupSource().proposedDatatype ) or self.lookupSource().proposedDatatype is None:

                self.lookupSource().proposedDatatype = proposedDatatype
                # self.lookupSource().proposedDatatypeUpdated = True

                # notify the change of the datatype
                self.sim.datatype_propagation_instance.notify_updateOfProposedDatatype(self)

        else:
            if not self.lookupSource()._datatype.isEqualTo( proposedDatatype ):
                raise BaseException(&#34;setProposedDatatype: only possible for signals the datatypes of which is not already fixed!&#34;)

    @property
    def proposed_datatype(self):
        return self.lookupSource().proposedDatatype



    def inherit_datatype_from_signal(self, from_signal):
        &#34;&#34;&#34;
            The datatype of this anonymous signal shall be inherited from the given signal &#39;from_signal&#39;.
            This creates a bi-directional link in-between the signals self and from_signal
        &#34;&#34;&#34;
        self.lookupSource().inherit_datatype_of_signal = from_signal

        from_signal.inherit_datatype_to( self )

    def inherit_datatype_to(self, to_signal):
        &#34;&#34;&#34;
            add to_signal to the list of signals that inherit the datatype of this signal
        &#34;&#34;&#34;
        # once the datatype of this signal is fixed, inherit it to to_signal
        self.lookupSource()._inherit_datatype_to_list.append( to_signal )

    @property
    def inherit_datatype_to_list(self):
        return self.lookupSource()._inherit_datatype_to_list









    def set_data_link(self, signal):
        &#34;&#34;&#34;
            The data/value of the signal are based on the given signal

            This is used for:
                1) accessing the output of a subsystem 
        &#34;&#34;&#34;
        self.lookupSource()._data_link = signal

    @property
    def data_link(self):
        return self.lookupSource()._data_link









    # move to derived classes below
    def getSourceBlock(self):
        return self.lookupSource().sourceBlock


    def set_blockname(self, name):
        if not self.lookupSource().getSourceBlock() is None:
            self.lookupSource().getSourceBlock().set_name(name)

        return self

    def ShowOrigin(self):
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.signal_network.signals.BlockOutputSignal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.BlockOutputSignal">BlockOutputSignal</a></li>
<li><a title="openrtdynamics2.lang.diagram_core.signal_network.signals.SimulationInputSignal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.SimulationInputSignal">SimulationInputSignal</a></li>
<li><a title="openrtdynamics2.lang.diagram_core.signal_network.signals.UndeterminedSignal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.UndeterminedSignal">UndeterminedSignal</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.Signal.data_link"><code class="name">var <span class="ident">data_link</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_link(self):
    return self.lookupSource()._data_link</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.datatype"><code class="name">var <span class="ident">datatype</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def datatype(self):
    return self.lookupSource()._datatype</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.inherit_datatype_to_list"><code class="name">var <span class="ident">inherit_datatype_to_list</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def inherit_datatype_to_list(self):
    return self.lookupSource()._inherit_datatype_to_list</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.is_referencing_memory"><code class="name">var <span class="ident">is_referencing_memory</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_referencing_memory(self):
    return self._is_referencing_memory</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self.lookupSource()._name</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.nameIsDefault"><code class="name">var <span class="ident">nameIsDefault</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def nameIsDefault(self):
    return self._nameIsDefault</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.properties"><code class="name">var <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self):
    return self.lookupSource()._properties</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.proposed_datatype"><code class="name">var <span class="ident">proposed_datatype</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def proposed_datatype(self):
    return self.lookupSource().proposedDatatype</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.system"><code class="name">var <span class="ident">system</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def system(self):
    # system == simulation
    return self.sim</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.Signal.ShowOrigin"><code class="name flex">
<span>def <span class="ident">ShowOrigin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ShowOrigin(self):
    pass</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.addDestination"><code class="name flex">
<span>def <span class="ident">addDestination</span></span>(<span>self, block, port: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def addDestination(self, block , port : int):
    # add this destination to the list
    self.lookupSource().destinationBlocks.append( block )
    self.lookupSource().destinationPorts.append( port )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.fixDatatype"><code class="name flex">
<span>def <span class="ident">fixDatatype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fixDatatype(self):
    # this shall explicitely not trigger a notification!
    self.lookupSource()._datatype = self.lookupSource().proposedDatatype</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.getDatatype"><code class="name flex">
<span>def <span class="ident">getDatatype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDatatype(self):
    return self.lookupSource()._datatype</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.getDestinationBlocks"><code class="name flex">
<span>def <span class="ident">getDestinationBlocks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getDestinationBlocks(self):
    return self.lookupSource().destinationBlocks</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.getProposedDatatype"><code class="name flex">
<span>def <span class="ident">getProposedDatatype</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getProposedDatatype(self):
    return self.lookupSource().proposedDatatype</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.getSourceBlock"><code class="name flex">
<span>def <span class="ident">getSourceBlock</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getSourceBlock(self):
    return self.lookupSource().sourceBlock</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.graphTraversionMarkerMarkIsVisited"><code class="name flex">
<span>def <span class="ident">graphTraversionMarkerMarkIsVisited</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graphTraversionMarkerMarkIsVisited(self):
    # check of this node was marked on level or a level below
    return self.lookupSource().graphTraversionMarker &gt;= 0</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.graphTraversionMarkerMarkIsVisitedOnLevelLowerThan"><code class="name flex">
<span>def <span class="ident">graphTraversionMarkerMarkIsVisitedOnLevelLowerThan</span></span>(<span>self, onLevel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graphTraversionMarkerMarkIsVisitedOnLevelLowerThan(self, onLevel):
    # check of this node was marked on level or a level below
    return self.graphTraversionMarkerMarkIsVisited() and self.lookupSource().graphTraversionMarker &lt; onLevel</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.graphTraversionMarkerMarkVisited"><code class="name flex">
<span>def <span class="ident">graphTraversionMarkerMarkVisited</span></span>(<span>self, level)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graphTraversionMarkerMarkVisited(self, level):
    if level &lt; 0:
        raise BaseException(&#34;level cannot be &lt; 0&#34;)

    self.lookupSource().graphTraversionMarker = level</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.graphTraversionMarkerReset"><code class="name flex">
<span>def <span class="ident">graphTraversionMarkerReset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def graphTraversionMarkerReset(self):
    self.lookupSource().graphTraversionMarker = -1</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.inherit_datatype_from_signal"><code class="name flex">
<span>def <span class="ident">inherit_datatype_from_signal</span></span>(<span>self, from_signal)</span>
</code></dt>
<dd>
<div class="desc"><p>The datatype of this anonymous signal shall be inherited from the given signal 'from_signal'.
This creates a bi-directional link in-between the signals self and from_signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_datatype_from_signal(self, from_signal):
    &#34;&#34;&#34;
        The datatype of this anonymous signal shall be inherited from the given signal &#39;from_signal&#39;.
        This creates a bi-directional link in-between the signals self and from_signal
    &#34;&#34;&#34;
    self.lookupSource().inherit_datatype_of_signal = from_signal

    from_signal.inherit_datatype_to( self )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.inherit_datatype_to"><code class="name flex">
<span>def <span class="ident">inherit_datatype_to</span></span>(<span>self, to_signal)</span>
</code></dt>
<dd>
<div class="desc"><p>add to_signal to the list of signals that inherit the datatype of this signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inherit_datatype_to(self, to_signal):
    &#34;&#34;&#34;
        add to_signal to the list of signals that inherit the datatype of this signal
    &#34;&#34;&#34;
    # once the datatype of this signal is fixed, inherit it to to_signal
    self.lookupSource()._inherit_datatype_to_list.append( to_signal )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.is_block_output"><code class="name flex">
<span>def <span class="ident">is_block_output</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_block_output(self):
    return self.lookupSource().is_block_output()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.is_crossing_system_boundary"><code class="name flex">
<span>def <span class="ident">is_crossing_system_boundary</span></span>(<span>self, system)</span>
</code></dt>
<dd>
<div class="desc"><p>test if fot the given system this signals comes from an outer/higher level
system.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_crossing_system_boundary(self, system):

    &#34;&#34;&#34;
        test if fot the given system this signals comes from an outer/higher level
        system.
    &#34;&#34;&#34;

    if self.sim == system:
        return False

    # check if this signal is coming from an upper/outer system 
    # (if not it comes from a parallel system that cannot be accessed: this is an error)

    # go up in the system-nesting hirachy starting at system
    system_iter = system

    while system_iter.parent_system is not None:

        if system_iter.parent_system == self.system:
            return True

        system_iter = system_iter.parent_system

    raise BaseException(&#34;Bad access to signal &#34; + Fore.YELLOW + self.name + Fore.RESET + &#34;: did you access a signal from another subsystem that cannot be reached?&#34;)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.is_proxy"><code class="name flex">
<span>def <span class="ident">is_proxy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_proxy(self):
    return self.lookupSource().is_proxy()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.is_simulation_input"><code class="name flex">
<span>def <span class="ident">is_simulation_input</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_simulation_input(self):
    return self.lookupSource().is_simulation_input()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.lookupSource"><code class="name flex">
<span>def <span class="ident">lookupSource</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookupSource(self):
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.setDatatype"><code class="name flex">
<span>def <span class="ident">setDatatype</span></span>(<span>self, datatype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDatatype(self, datatype):

    self.setDatatype_nonotitication( datatype )

    # NOTE: should be added lookupSource() here (though effectively no difference)
    # notify the change of the datatype
    self.sim.datatype_propagation_instance.notifySignal(self)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.setDatatype_nonotitication"><code class="name flex">
<span>def <span class="ident">setDatatype_nonotitication</span></span>(<span>self, datatype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDatatype_nonotitication(self, datatype):
    self.lookupSource()._datatype = datatype</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.setProposedDatatype"><code class="name flex">
<span>def <span class="ident">setProposedDatatype</span></span>(<span>self, proposedDatatype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setProposedDatatype(self, proposedDatatype):
    # only proceed if the datatype of this signals is not already fixed
    if self.lookupSource()._datatype is None:

        # only proceed of the prosed datatype is diffent to the stored one
        # or the stored type is None (not set before)
        if not proposedDatatype.isEqualTo( self.lookupSource().proposedDatatype ) or self.lookupSource().proposedDatatype is None:

            self.lookupSource().proposedDatatype = proposedDatatype
            # self.lookupSource().proposedDatatypeUpdated = True

            # notify the change of the datatype
            self.sim.datatype_propagation_instance.notify_updateOfProposedDatatype(self)

    else:
        if not self.lookupSource()._datatype.isEqualTo( proposedDatatype ):
            raise BaseException(&#34;setProposedDatatype: only possible for signals the datatypes of which is not already fixed!&#34;)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.set_blockname"><code class="name flex">
<span>def <span class="ident">set_blockname</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_blockname(self, name):
    if not self.lookupSource().getSourceBlock() is None:
        self.lookupSource().getSourceBlock().set_name(name)

    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.set_data_link"><code class="name flex">
<span>def <span class="ident">set_data_link</span></span>(<span>self, signal)</span>
</code></dt>
<dd>
<div class="desc"><p>The data/value of the signal are based on the given signal</p>
<p>This is used for:
1) accessing the output of a subsystem</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_data_link(self, signal):
    &#34;&#34;&#34;
        The data/value of the signal are based on the given signal

        This is used for:
            1) accessing the output of a subsystem 
    &#34;&#34;&#34;
    self.lookupSource()._data_link = signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.set_is_referencing_memory"><code class="name flex">
<span>def <span class="ident">set_is_referencing_memory</span></span>(<span>self, val: bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_is_referencing_memory(self, val : bool):
    self._is_referencing_memory = val</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    self.lookupSource()._name = name

    # indicate that this Signal has a specified name (not a default/auto-generated name)
    self._nameIsDefault = False

    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.set_name_raw"><code class="name flex">
<span>def <span class="ident">set_name_raw</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name_raw(self, name):
    self.lookupSource()._name = name

    # indicate that this Signal has a specified name (not a default/auto-generated name)
    self._nameIsDefault = False

    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.set_properties"><code class="name flex">
<span>def <span class="ident">set_properties</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_properties(self, p):
    self.lookupSource()._properties = p</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.toStr"><code class="name flex">
<span>def <span class="ident">toStr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toStr(self):
    ret = &#39;&#39;
    ret += self.name

    if self.datatype is not None:
        ret += &#34; (&#34; + self.datatype.toStr() + &#34;)&#34;
    else:
        # ret += &#34; (undef datatype)&#34;
        pass


    if self.lookupSource().proposedDatatype is not None:
        ret += &#34; type proposal: (&#34; + self.lookupSource().proposedDatatype.toStr() + &#34;)&#34;
    else:
        # ret += &#34;proposal: (undef datatype)&#34;
        pass

    if self.lookupSource().inherit_datatype_of_signal is not None:
        ret = ret + &#39;type inherit from &#39; + self.lookupSource().inherit_datatype_of_signal.name

    return ret</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.Signal.update_datatype_config"><code class="name flex">
<span>def <span class="ident">update_datatype_config</span></span>(<span>self, datatype)</span>
</code></dt>
<dd>
<div class="desc"><p>set the datatype in case it was not defined in the constructor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_datatype_config(self, datatype):
    &#34;&#34;&#34;
        set the datatype in case it was not defined in the constructor
    &#34;&#34;&#34;
    if self.lookupSource()._datatype is not None:
        raise BaseException(&#34;datatype already defined&#34;)
    
    self.lookupSource()._datatype = datatype</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate"><code class="flex name class">
<span>class <span class="ident">SignalUserTemplate</span></span>
<span>(</span><span>sim, wrapped_signal: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalUserTemplate(object):
    def __init__(self, sim, wrapped_signal : Signal):

        self.sim = sim
        self.wrapped_signal_ = wrapped_signal

    def __hash__(self):
        return id(self)

    @property
    def unwrap(self):
        return self.wrapped_signal_

    @property
    def name(self):
        return self.wrapped_signal_.name

    @property
    def properties(self):
        return self.wrapped_signal_.properties

    def set_properties(self, p):
        self.wrapped_signal_.set_properties(p)
        return self

    def set_datatype(self, datatype):
        # call setDatatype_nonotitication to prevent the (untested) automatic update of the datatypes
        self.wrapped_signal_.setDatatype_nonotitication(datatype)
        return self

    def set_name(self, name):
        self.wrapped_signal_.set_name(name)
        return self

    def set_name_raw(self, name):
        self.wrapped_signal_.set_name_raw(name)
        return self


    def extendName(self, name):
        self.wrapped_signal_.set_name( self.wrapped_signal_.name + name )
        return self

    def set_blockname(self, name):
        self.wrapped_signal_.set_blockname(name)
        return self

    # ...

    #
    # operator overloads
    #

    def __add__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;+&#39;).outputs[0] )

    def __radd__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;+&#39;).outputs[0] )


    def __sub__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;-&#39;).outputs[0] )

    def __rsub__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ other.unwrap, self.unwrap ], operator=&#39;-&#39;).outputs[0] )


    def __mul__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;*&#39;).outputs[0] )

    def __rmul__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;*&#39;).outputs[0] )


    def __truediv__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;/&#39;).outputs[0] )

    def __rtruediv__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ other.unwrap, self.unwrap ], operator=&#39;/&#39;).outputs[0] )



    # _comparison operators
    def __le__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;&lt;=&#39; ) )

    def __rle__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = other, right = self, operator = &#39;&lt;=&#39; ) )



    def __ge__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;&gt;=&#39; ) )

    def __rge__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = other, right = self, operator = &#39;&gt;=&#39; ) )



    def __lt__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;&lt;&#39; ) )

    def __rlt__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = other, right = self, operator = &#39;&lt;&#39; ) )



    def __gt__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;&gt;&#39; ) )

    def __rgt__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = other, right = self, operator = &#39;&gt;&#39; ) )



    def __eq__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;==&#39; ) )

    def __req__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;==&#39; ) )

    def __ne__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;!=&#39; ) )

    def __rne__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;!=&#39; ) )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.signal_interface.BlockOutputSignalUser" href="signal_interface.html#openrtdynamics2.lang.signal_interface.BlockOutputSignalUser">BlockOutputSignalUser</a></li>
<li><a title="openrtdynamics2.lang.signal_interface.SignalUser" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUser">SignalUser</a></li>
<li><a title="openrtdynamics2.lang.signal_interface.SimulationInputSignalUser" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SimulationInputSignalUser">SimulationInputSignalUser</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.SignalUserTemplate.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    return self.wrapped_signal_.name</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.properties"><code class="name">var <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self):
    return self.wrapped_signal_.properties</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.unwrap"><code class="name">var <span class="ident">unwrap</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unwrap(self):
    return self.wrapped_signal_</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.SignalUserTemplate.extendName"><code class="name flex">
<span>def <span class="ident">extendName</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extendName(self, name):
    self.wrapped_signal_.set_name( self.wrapped_signal_.name + name )
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_blockname"><code class="name flex">
<span>def <span class="ident">set_blockname</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_blockname(self, name):
    self.wrapped_signal_.set_blockname(name)
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_datatype"><code class="name flex">
<span>def <span class="ident">set_datatype</span></span>(<span>self, datatype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_datatype(self, datatype):
    # call setDatatype_nonotitication to prevent the (untested) automatic update of the datatypes
    self.wrapped_signal_.setDatatype_nonotitication(datatype)
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    self.wrapped_signal_.set_name(name)
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_name_raw"><code class="name flex">
<span>def <span class="ident">set_name_raw</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name_raw(self, name):
    self.wrapped_signal_.set_name_raw(name)
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_properties"><code class="name flex">
<span>def <span class="ident">set_properties</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_properties(self, p):
    self.wrapped_signal_.set_properties(p)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.WasmRuntime"><code class="flex name class">
<span>class <span class="ident">WasmRuntime</span></span>
<span>(</span><span>enable_tracing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generates code for the Webassemble runtime environment</p>
<p><a href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html">https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class WasmRuntime(PutRuntimeCppHelper):
    &#34;&#34;&#34;
        generates code for the Webassemble runtime environment

        https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html

    &#34;&#34;&#34;

    def __init__(self, enable_tracing = False ):

        PutRuntimeCppHelper.__init__(self, enable_tracing=enable_tracing)

        self.initCodeTemplate()

        
    def code_gen(self):

        # build I/O structs
        ioExport = self.generate_code_writeIO(self.main_command.command_to_put_main_system.outputCommand)
        ioExport += self.generate_code_writeIO(self.main_command.command_to_put_main_system.updateCommand)

        ioExport += self.generate_code_writeIO(self.main_command.command_to_put_main_system.resetCommand)

        self.template = Template(self.template).safe_substitute( ioExport=ioExport,
                                                                 inputConstAssignment=&#39;&#39;    ) 

        # call helper to fill in some generic elements into the template
        code_gen_results = PutRuntimeCppHelper.code_gen(self)

        self.sourceCode = self.template

        code_gen_results[&#39;sourcecode&#39;] = self.sourceCode
        return code_gen_results



    def generate_code_writeIO__(self, command_API, inputOutput : int):

        if inputOutput == 1:
            structPrefix = &#39;Inputs_&#39;
            signals = command_API.inputSignals

        elif inputOutput == 2:
            structPrefix = &#39;Outputs_&#39;
            signals = command_API.outputSignals

        mainSimulationName = self.main_command.command_to_put_main_system.API_name

        lines = &#39;&#39;

        # Inputs
        structname = structPrefix + command_API.API_name 

        lines += &#39;value_object&lt;&#39; + mainSimulationName + &#39;::&#39; + structname + &#39;&gt;(&#34;&#39; + mainSimulationName + &#39;__&#39; + structname + &#39;&#34;)\n&#39;

        for s in signals:
            fieldName = s.name

            lines += &#39;.field(&#34;&#39; + fieldName + &#39;&#34;, &amp;&#39; + mainSimulationName + &#39;::&#39; + structname + &#39;::&#39; + fieldName + &#39;)\n&#39;

        lines += &#39;;\n\n&#39;


        return lines

    def generate_code_writeIO(self, command_API):
        return self.generate_code_writeIO__(command_API, 1) + self.generate_code_writeIO__(command_API, 2)


    def write_code(self, folder):

        PutRuntimeCppHelper.writeFiles(self, folder)

        self.codeFolder = folder

        f = open( Path( folder ) / &#34;main.cpp&#34;, &#34;w&#34;)
        f.write( self.sourceCode )
        f.close()


    def build(self):

        buildCommand = &#39;emcc --bind -s MODULARIZE=1 -s EXPORT_NAME=&#34;ORTD_simulator&#34; &#39;  + os.path.join(self.codeFolder , &#34;main.cpp&#34;) + &#34; -g4 -s -o &#34; + os.path.join( self.codeFolder , &#34;main.js&#34; )
        print(&#34;Running compiler: &#34; + buildCommand)

        returnCode = os.system(buildCommand)

        print( &#34;Compilation result: &#34;, returnCode )


    def initCodeTemplate(self):

        #
        # template for main function in c++
        #

        self.template = &#34;&#34;&#34;
            
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;emscripten/bind.h&gt;

using namespace emscripten;

//
// implementation of $mainSimulationName
//

$algorithmCode

// Binding code
EMSCRIPTEN_BINDINGS(my_class_example) {
  class_&lt;$mainSimulationName&gt;(&#34;$mainSimulationName&#34;)
    .constructor&lt;&gt;()
    .function(&#34;resetStates&#34;, &amp;$mainSimulationName::resetStates__)
    .function(&#34;calcResults_1&#34;, &amp;$mainSimulationName::calcResults_1__)
    .function(&#34;updateStates&#34;, &amp;$mainSimulationName::updateStates__)
    ;


// --------------------------------

$ioExport


}
            
        &#34;&#34;&#34;        </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper">PutRuntimeCppHelper</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.WasmRuntime.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self):

    buildCommand = &#39;emcc --bind -s MODULARIZE=1 -s EXPORT_NAME=&#34;ORTD_simulator&#34; &#39;  + os.path.join(self.codeFolder , &#34;main.cpp&#34;) + &#34; -g4 -s -o &#34; + os.path.join( self.codeFolder , &#34;main.js&#34; )
    print(&#34;Running compiler: &#34; + buildCommand)

    returnCode = os.system(buildCommand)

    print( &#34;Compilation result: &#34;, returnCode )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.WasmRuntime.code_gen"><code class="name flex">
<span>def <span class="ident">code_gen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_gen(self):

    # build I/O structs
    ioExport = self.generate_code_writeIO(self.main_command.command_to_put_main_system.outputCommand)
    ioExport += self.generate_code_writeIO(self.main_command.command_to_put_main_system.updateCommand)

    ioExport += self.generate_code_writeIO(self.main_command.command_to_put_main_system.resetCommand)

    self.template = Template(self.template).safe_substitute( ioExport=ioExport,
                                                             inputConstAssignment=&#39;&#39;    ) 

    # call helper to fill in some generic elements into the template
    code_gen_results = PutRuntimeCppHelper.code_gen(self)

    self.sourceCode = self.template

    code_gen_results[&#39;sourcecode&#39;] = self.sourceCode
    return code_gen_results</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.WasmRuntime.generate_code_writeIO"><code class="name flex">
<span>def <span class="ident">generate_code_writeIO</span></span>(<span>self, command_API)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_writeIO(self, command_API):
    return self.generate_code_writeIO__(command_API, 1) + self.generate_code_writeIO__(command_API, 2)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.WasmRuntime.generate_code_writeIO__"><code class="name flex">
<span>def <span class="ident">generate_code_writeIO__</span></span>(<span>self, command_API, inputOutput: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_writeIO__(self, command_API, inputOutput : int):

    if inputOutput == 1:
        structPrefix = &#39;Inputs_&#39;
        signals = command_API.inputSignals

    elif inputOutput == 2:
        structPrefix = &#39;Outputs_&#39;
        signals = command_API.outputSignals

    mainSimulationName = self.main_command.command_to_put_main_system.API_name

    lines = &#39;&#39;

    # Inputs
    structname = structPrefix + command_API.API_name 

    lines += &#39;value_object&lt;&#39; + mainSimulationName + &#39;::&#39; + structname + &#39;&gt;(&#34;&#39; + mainSimulationName + &#39;__&#39; + structname + &#39;&#34;)\n&#39;

    for s in signals:
        fieldName = s.name

        lines += &#39;.field(&#34;&#39; + fieldName + &#39;&#34;, &amp;&#39; + mainSimulationName + &#39;::&#39; + structname + &#39;::&#39; + fieldName + &#39;)\n&#39;

    lines += &#39;;\n\n&#39;


    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.WasmRuntime.initCodeTemplate"><code class="name flex">
<span>def <span class="ident">initCodeTemplate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def initCodeTemplate(self):

        #
        # template for main function in c++
        #

        self.template = &#34;&#34;&#34;
            
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;emscripten/bind.h&gt;

using namespace emscripten;

//
// implementation of $mainSimulationName
//

$algorithmCode

// Binding code
EMSCRIPTEN_BINDINGS(my_class_example) {
  class_&lt;$mainSimulationName&gt;(&#34;$mainSimulationName&#34;)
    .constructor&lt;&gt;()
    .function(&#34;resetStates&#34;, &amp;$mainSimulationName::resetStates__)
    .function(&#34;calcResults_1&#34;, &amp;$mainSimulationName::calcResults_1__)
    .function(&#34;updateStates&#34;, &amp;$mainSimulationName::updateStates__)
    ;


// --------------------------------

$ioExport


}
            
        &#34;&#34;&#34;        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.WasmRuntime.write_code"><code class="name flex">
<span>def <span class="ident">write_code</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_code(self, folder):

    PutRuntimeCppHelper.writeFiles(self, folder)

    self.codeFolder = folder

    f = open( Path( folder ) / &#34;main.cpp&#34;, &#34;w&#34;)
    f.write( self.sourceCode )
    f.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper">PutRuntimeCppHelper</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper.get_algorithm_code" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.PutRuntimeCppHelper.get_algorithm_code">get_algorithm_code</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.state_sub"><code class="flex name class">
<span>class <span class="ident">state_sub</span></span>
<span>(</span><span>subsystem_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A single subsystem as part of a state machine (implemented by sub_statemachine)</p>
<ul>
<li>methods to called by the user -</li>
</ul>
<p>set_switched_outputs(signals, state_signal)
- connect a list of signals to the output of the state machine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class state_sub(SwitchedSubsystemPrototype):
    &#34;&#34;&#34;
        A single subsystem as part of a state machine (implemented by sub_statemachine)

        - methods to called by the user -

        set_switched_outputs(signals, state_signal)  - connect a list of signals to the output of the state machine
    &#34;&#34;&#34;

    def __init__(self, subsystem_name = None ):
        SwitchedSubsystemPrototype.__init__(self, subsystem_name)

        self._output_signals = None
        self._state_signal = None


    def set_switched_outputs(self, signals, state_signal):
        &#34;&#34;&#34;
            set the output signals of a subsystem embedded into the state machine

            - signals      - normal system output that are forwarded using a switch
            - state_signal - control signal indicating the next state the state machine enters
        &#34;&#34;&#34;
        self._output_signals = signals
        self._state_signal = state_signal

        self.set_switched_outputs_prototype( signals +  [state_signal] )

    @property
    def state_control_output(self):
         return self._state_signal

    @property
    def subsystem_outputs(self):
        return self._output_signals</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype">SwitchedSubsystemPrototype</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.state_sub.state_control_output"><code class="name">var <span class="ident">state_control_output</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_control_output(self):
     return self._state_signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.state_sub.subsystem_outputs"><code class="name">var <span class="ident">subsystem_outputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def subsystem_outputs(self):
    return self._output_signals</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.state_sub.set_switched_outputs"><code class="name flex">
<span>def <span class="ident">set_switched_outputs</span></span>(<span>self, signals, state_signal)</span>
</code></dt>
<dd>
<div class="desc"><p>set the output signals of a subsystem embedded into the state machine</p>
<ul>
<li>signals
- normal system output that are forwarded using a switch</li>
<li>state_signal - control signal indicating the next state the state machine enters</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_switched_outputs(self, signals, state_signal):
    &#34;&#34;&#34;
        set the output signals of a subsystem embedded into the state machine

        - signals      - normal system output that are forwarded using a switch
        - state_signal - control signal indicating the next state the state machine enters
    &#34;&#34;&#34;
    self._output_signals = signals
    self._state_signal = state_signal

    self.set_switched_outputs_prototype( signals +  [state_signal] )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype">SwitchedSubsystemPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype.set_switched_outputs_prototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype.set_switched_outputs_prototype">set_switched_outputs_prototype</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.sub_if"><code class="flex name class">
<span>class <span class="ident">sub_if</span></span>
<span>(</span><span>condition_signal: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, subsystem_name=None, prevent_output_computation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>NOTE: in case the if condition is false, the outputs are hold. Eventally uninitialized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sub_if:
    &#34;&#34;&#34;

        NOTE: in case the if condition is false, the outputs are hold. Eventally uninitialized.
    &#34;&#34;&#34;


    def __init__(self, condition_signal : dy.SignalUserTemplate, subsystem_name = None, prevent_output_computation = False ):

        if subsystem_name is not None:
            self._subsystem_name = subsystem_name
        else:
            self._subsystem_name = generate_subsystem_name()

        self._condition_signal = condition_signal
        self._prevent_output_computation = prevent_output_computation

        # 
        self._outputs_of_embeded_subsystem = []

        # outputs (links to the subsystem outputs) to be used by the user
        self._output_links = None


    def set_outputs(self, signals):
        self._outputs_of_embeded_subsystem = signals.copy()

    def __enter__(self):
        self._system = enter_subsystem(self._subsystem_name )

        return self


    def __exit__(self, type, value, traceback):

        embedded_subsystem = dy.get_system_context()

        # set the outputs of the system
        embedded_subsystem.set_primary_outputs( si.unwrap_list( self._outputs_of_embeded_subsystem ) )

        # create generic subsystem block prototype
        self._subsystem_block_prototype = bp.GenericSubsystem( sim=embedded_subsystem.upper_level_system, 
                                                    manifest=None, inputSignals=None, 
                                                    embedded_subsystem=embedded_subsystem,
                                                    N_outputs=len(self._outputs_of_embeded_subsystem) )

        # leave the context of the subsystem
        dy.leave_system()

        #
        # now in the system in which the embeder block (including the logic) shall be placed.
        #

        # create the embedder prototype
        embeddedingBlockPrototype = bp.TruggeredSubsystem( sim=dy.get_system_context(), 
                control_input=si.unwrap( self._condition_signal ), 
                subsystem_prototype=self._subsystem_block_prototype,
                prevent_output_computation = self._prevent_output_computation)


        # connect the normal outputs via links
        self._output_links = si.wrap_signal_list( embeddedingBlockPrototype.outputs )

        # connect the additional (control) outputs
        # self._state_output = si.wrap_signal( embeddedingBlockPrototype.state_output )

    @property
    def outputs(self):

        if self._output_links is None:
            BaseException(&#34;Please close the subsystem before querying its outputs&#34;)
        
        return self._output_links</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_if.outputs"><code class="name">var <span class="ident">outputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def outputs(self):

    if self._output_links is None:
        BaseException(&#34;Please close the subsystem before querying its outputs&#34;)
    
    return self._output_links</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_if.set_outputs"><code class="name flex">
<span>def <span class="ident">set_outputs</span></span>(<span>self, signals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_outputs(self, signals):
    self._outputs_of_embeded_subsystem = signals.copy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.sub_loop"><code class="flex name class">
<span>class <span class="ident">sub_loop</span></span>
<span>(</span><span>max_iterations: int, subsystem_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sub_loop:
    &#34;&#34;&#34;

    &#34;&#34;&#34;


    def __init__(self, max_iterations : int, subsystem_name = None ):

        if subsystem_name is not None:
            self._subsystem_name = subsystem_name
        else:
            self._subsystem_name = generate_subsystem_name()

        self._max_iterations = max_iterations

        # control outputs of the embedded subsystem
        self._until_signal = None
        self._yield_signal = None

        # 
        self._outputs_of_embeded_subsystem = []

        # outputs (links to the subsystem outputs) to be used by the user
        self._output_links = None


    def set_outputs(self, signals):
        self._outputs_of_embeded_subsystem = si.unwrap_list( signals.copy() )

    def loop_until(self, condition_signal):
        self._until_signal = condition_signal.unwrap

    def loop_yield(self, condition_signal):
        self._yield_signal = condition_signal.unwrap

    def __enter__(self):

        self._system = enter_subsystem(self._subsystem_name )

        return self


    def __exit__(self, type, value, traceback):

        embedded_subsystem = dy.get_system_context()

        # collect all outputs
        all_output_signals = []
        all_output_signals.extend(self._outputs_of_embeded_subsystem)
        if self._until_signal is not None:
            all_output_signals.append(self._until_signal)
        if self._yield_signal is not None:
            all_output_signals.append(self._yield_signal)

        # set the outputs of the system
        embedded_subsystem.set_primary_outputs(  all_output_signals  )

        # create generic subsystem block prototype
        self._subsystem_block_prototype = bp.GenericSubsystem( sim=embedded_subsystem.upper_level_system, 
                                                    manifest=None, inputSignals=None, 
                                                    embedded_subsystem=embedded_subsystem,
                                                    N_outputs=len(all_output_signals) )

        # leave the context of the subsystem
        dy.leave_system()

        #
        # now in the system in which the embeder block (including the logic) shall be placed.
        #

        # create the embeeder prototype
        embeddedingBlockPrototype = bp.LoopUntilSubsystem( sim=dy.get_system_context(), 
                max_iterations=self._max_iterations, 
                subsystem_prototype=self._subsystem_block_prototype,
                until_signal=self._until_signal,
                yield_signal=self._yield_signal)


                # subsystem_prototypes=subsystem_prototypes, 
                # reference_outputs=  si.unwrap_list( self._reference_outputs ) )

        # connect the normal outputs via links
        self._output_links = si.wrap_signal_list( embeddedingBlockPrototype.outputs )

        # connect the additional (control) outputs
        # self._state_output = si.wrap_signal( embeddedingBlockPrototype.state_output )

    @property
    def outputs(self):

        if self._output_links is None:
            BaseException(&#34;Please close the subsystem before querying its outputs&#34;)
        
        return self._output_links</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_loop.outputs"><code class="name">var <span class="ident">outputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def outputs(self):

    if self._output_links is None:
        BaseException(&#34;Please close the subsystem before querying its outputs&#34;)
    
    return self._output_links</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_loop.loop_until"><code class="name flex">
<span>def <span class="ident">loop_until</span></span>(<span>self, condition_signal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_until(self, condition_signal):
    self._until_signal = condition_signal.unwrap</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sub_loop.loop_yield"><code class="name flex">
<span>def <span class="ident">loop_yield</span></span>(<span>self, condition_signal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_yield(self, condition_signal):
    self._yield_signal = condition_signal.unwrap</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sub_loop.set_outputs"><code class="name flex">
<span>def <span class="ident">set_outputs</span></span>(<span>self, signals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_outputs(self, signals):
    self._outputs_of_embeded_subsystem = si.unwrap_list( signals.copy() )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.sub_statemachine"><code class="flex name class">
<span>class <span class="ident">sub_statemachine</span></span>
<span>(</span><span>switch_subsystem_name)</span>
</code></dt>
<dd>
<div class="desc"><p>A state machine subsystem</p>
<ul>
<li>properties -</li>
</ul>
<p>self.state - status signal of the state machine (available after 'with sub_statemachine' has findished)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sub_statemachine(SwitchPrototype):
    &#34;&#34;&#34;
        A state machine subsystem

        - properties -

        self.state - status signal of the state machine (available after &#39;with sub_statemachine&#39; has findished)
    &#34;&#34;&#34;
    def __init__(self, switch_subsystem_name):
        number_of_control_outputs = 1 # add one control output to inform about the current state

        SwitchPrototype.__init__(self, switch_subsystem_name, number_of_control_outputs )

        # state output signal undefined until defined by on_exit() 
        self._state_output = None

    @property
    def state(self):
        &#34;&#34;&#34;
            get the signal describing the current state
        &#34;&#34;&#34;
        return self._state_output

    def new_subsystem(self, subsystem_name = None):

        system = state_sub(subsystem_name=subsystem_name)
        self._subsystem_list.append(system)

        return system

    def on_exit(self, subsystem_prototypes):

        # create the embeeder prototype
        embeddedingBlockPrototype = bp.StatemachineSwitchSubsystems( sim=dy.get_system_context(), 
                subsystem_prototypes=subsystem_prototypes, 
                reference_outputs=  si.unwrap_list( self._reference_outputs ) )

        # connect the normal outputs via links
        self._switch_output_links = si.wrap_signal_list( embeddedingBlockPrototype.switched_normal_outputs )

        # connect the additional (control) outputs
        self._state_output = si.wrap_signal( embeddedingBlockPrototype.state_output )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.subsystems.SwitchPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype">SwitchPrototype</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_statemachine.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<div class="desc"><p>get the signal describing the current state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self):
    &#34;&#34;&#34;
        get the signal describing the current state
    &#34;&#34;&#34;
    return self._state_output</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_statemachine.new_subsystem"><code class="name flex">
<span>def <span class="ident">new_subsystem</span></span>(<span>self, subsystem_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_subsystem(self, subsystem_name = None):

    system = state_sub(subsystem_name=subsystem_name)
    self._subsystem_list.append(system)

    return system</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.subsystems.SwitchPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype">SwitchPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.subsystems.SwitchPrototype.on_exit" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype.on_exit">on_exit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.sub_switch"><code class="flex name class">
<span>class <span class="ident">sub_switch</span></span>
<span>(</span><span>switch_subsystem_name, select_signal: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>a switch for subsystems that are implemented by SwitchedSubsystemPrototype (class to be derived)</p>
<p>switch_subsystem_name
- the name of the switch
number_of_control_outputs - the number of system outputs in addition to the embedded systems outputs
i.e. control outputs of a switch/statemaching/&hellip;</p>
<ul>
<li>member variables -</li>
</ul>
<p>self._switch_output_links
- overwrite by derived class when calling on_exit()
self.outputs
- a list of output signals as defined by self._switch_output_links</p>
<ul>
<li>methods to be defined -</li>
</ul>
<p>on_exit(subsystem_prototypes)
- callback once all subsystems were defined
during this callback self._switch_output_links must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sub_switch(SwitchPrototype):
    def __init__(self, switch_subsystem_name, select_signal : dy.SignalUserTemplate ):

        self._select_signal = select_signal
        SwitchPrototype.__init__(self, switch_subsystem_name, number_of_control_outputs=0)

    def new_subsystem(self, subsystem_name = None):

        system = SwitchedSubsystem(subsystem_name=subsystem_name)
        self._subsystem_list.append(system)

        return system


    def on_exit(self, subsystem_prototypes):

        # create the  embeeder prototype
        embeddedingBlockPrototype = bp.SwitchSubsystems( sim=dy.get_system_context(), 
                control_input=self._select_signal.unwrap, 
                subsystem_prototypes=subsystem_prototypes, 
                reference_outputs=  si.unwrap_list( self._reference_outputs ) )

        # connect the normal outputs via links
        self._switch_output_links = si.wrap_signal_list( embeddedingBlockPrototype.switched_normal_outputs )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.subsystems.SwitchPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype">SwitchPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_switch.new_subsystem"><code class="name flex">
<span>def <span class="ident">new_subsystem</span></span>(<span>self, subsystem_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_subsystem(self, subsystem_name = None):

    system = SwitchedSubsystem(subsystem_name=subsystem_name)
    self._subsystem_list.append(system)

    return system</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.subsystems.SwitchPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype">SwitchPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.subsystems.SwitchPrototype.on_exit" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype.on_exit">on_exit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openrtdynamics2" href="../index.html">openrtdynamics2</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="openrtdynamics2.lang.block_interface" href="block_interface.html">openrtdynamics2.lang.block_interface</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes" href="block_prototypes.html">openrtdynamics2.lang.block_prototypes</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem" href="block_prototypes_single_subsystem.html">openrtdynamics2.lang.block_prototypes_single_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems" href="block_prototypes_subsystems.html">openrtdynamics2.lang.block_prototypes_subsystems</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems" href="block_prototypes_switched_subsystems.html">openrtdynamics2.lang.block_prototypes_switched_subsystems</a></code></li>
<li><code><a title="openrtdynamics2.lang.code_generation_templates" href="code_generation_templates.html">openrtdynamics2.lang.code_generation_templates</a></code></li>
<li><code><a title="openrtdynamics2.lang.core_blocks" href="core_blocks.html">openrtdynamics2.lang.core_blocks</a></code></li>
<li><code><a title="openrtdynamics2.lang.diagram_core" href="diagram_core/index.html">openrtdynamics2.lang.diagram_core</a></code></li>
<li><code><a title="openrtdynamics2.lang.high_level_user_commands" href="high_level_user_commands.html">openrtdynamics2.lang.high_level_user_commands</a></code></li>
<li><code><a title="openrtdynamics2.lang.libraries" href="libraries.html">openrtdynamics2.lang.libraries</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_interface" href="signal_interface.html">openrtdynamics2.lang.signal_interface</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library" href="standard_library.html">openrtdynamics2.lang.standard_library</a></code></li>
<li><code><a title="openrtdynamics2.lang.subsystems" href="subsystems.html">openrtdynamics2.lang.subsystems</a></code></li>
<li><code><a title="openrtdynamics2.lang.system_context" href="system_context.html">openrtdynamics2.lang.system_context</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="openrtdynamics2.lang.PID_controller" href="#openrtdynamics2.lang.PID_controller">PID_controller</a></code></li>
<li><code><a title="openrtdynamics2.lang.abs" href="#openrtdynamics2.lang.abs">abs</a></code></li>
<li><code><a title="openrtdynamics2.lang.acos" href="#openrtdynamics2.lang.acos">acos</a></code></li>
<li><code><a title="openrtdynamics2.lang.add" href="#openrtdynamics2.lang.add">add</a></code></li>
<li><code><a title="openrtdynamics2.lang.append_primay_ouput" href="#openrtdynamics2.lang.append_primay_ouput">append_primay_ouput</a></code></li>
<li><code><a title="openrtdynamics2.lang.asin" href="#openrtdynamics2.lang.asin">asin</a></code></li>
<li><code><a title="openrtdynamics2.lang.atan" href="#openrtdynamics2.lang.atan">atan</a></code></li>
<li><code><a title="openrtdynamics2.lang.atan2" href="#openrtdynamics2.lang.atan2">atan2</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_and" href="#openrtdynamics2.lang.bitwise_and">bitwise_and</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_not" href="#openrtdynamics2.lang.bitwise_not">bitwise_not</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_or" href="#openrtdynamics2.lang.bitwise_or">bitwise_or</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_shift_left" href="#openrtdynamics2.lang.bitwise_shift_left">bitwise_shift_left</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_shift_right" href="#openrtdynamics2.lang.bitwise_shift_right">bitwise_shift_right</a></code></li>
<li><code><a title="openrtdynamics2.lang.boolean" href="#openrtdynamics2.lang.boolean">boolean</a></code></li>
<li><code><a title="openrtdynamics2.lang.clear" href="#openrtdynamics2.lang.clear">clear</a></code></li>
<li><code><a title="openrtdynamics2.lang.comparison" href="#openrtdynamics2.lang.comparison">comparison</a></code></li>
<li><code><a title="openrtdynamics2.lang.compile_system" href="#openrtdynamics2.lang.compile_system">compile_system</a></code></li>
<li><code><a title="openrtdynamics2.lang.conditional_overwrite" href="#openrtdynamics2.lang.conditional_overwrite">conditional_overwrite</a></code></li>
<li><code><a title="openrtdynamics2.lang.const" href="#openrtdynamics2.lang.const">const</a></code></li>
<li><code><a title="openrtdynamics2.lang.convert" href="#openrtdynamics2.lang.convert">convert</a></code></li>
<li><code><a title="openrtdynamics2.lang.cos" href="#openrtdynamics2.lang.cos">cos</a></code></li>
<li><code><a title="openrtdynamics2.lang.counter" href="#openrtdynamics2.lang.counter">counter</a></code></li>
<li><code><a title="openrtdynamics2.lang.counter_triggered" href="#openrtdynamics2.lang.counter_triggered">counter_triggered</a></code></li>
<li><code><a title="openrtdynamics2.lang.delay" href="#openrtdynamics2.lang.delay">delay</a></code></li>
<li><code><a title="openrtdynamics2.lang.delay__" href="#openrtdynamics2.lang.delay__">delay__</a></code></li>
<li><code><a title="openrtdynamics2.lang.diff" href="#openrtdynamics2.lang.diff">diff</a></code></li>
<li><code><a title="openrtdynamics2.lang.dtf_lowpass_1_order" href="#openrtdynamics2.lang.dtf_lowpass_1_order">dtf_lowpass_1_order</a></code></li>
<li><code><a title="openrtdynamics2.lang.enter_system" href="#openrtdynamics2.lang.enter_system">enter_system</a></code></li>
<li><code><a title="openrtdynamics2.lang.euler_integrator" href="#openrtdynamics2.lang.euler_integrator">euler_integrator</a></code></li>
<li><code><a title="openrtdynamics2.lang.export_graph" href="#openrtdynamics2.lang.export_graph">export_graph</a></code></li>
<li><code><a title="openrtdynamics2.lang.flipflop" href="#openrtdynamics2.lang.flipflop">flipflop</a></code></li>
<li><code><a title="openrtdynamics2.lang.float64" href="#openrtdynamics2.lang.float64">float64</a></code></li>
<li><code><a title="openrtdynamics2.lang.fmod" href="#openrtdynamics2.lang.fmod">fmod</a></code></li>
<li><code><a title="openrtdynamics2.lang.gain" href="#openrtdynamics2.lang.gain">gain</a></code></li>
<li><code><a title="openrtdynamics2.lang.generate_code" href="#openrtdynamics2.lang.generate_code">generate_code</a></code></li>
<li><code><a title="openrtdynamics2.lang.generic_cpp_static" href="#openrtdynamics2.lang.generic_cpp_static">generic_cpp_static</a></code></li>
<li><code><a title="openrtdynamics2.lang.generic_subsystem" href="#openrtdynamics2.lang.generic_subsystem">generic_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.lang.get_system_context" href="#openrtdynamics2.lang.get_system_context">get_system_context</a></code></li>
<li><code><a title="openrtdynamics2.lang.init" href="#openrtdynamics2.lang.init">init</a></code></li>
<li><code><a title="openrtdynamics2.lang.init_simulation_context" href="#openrtdynamics2.lang.init_simulation_context">init_simulation_context</a></code></li>
<li><code><a title="openrtdynamics2.lang.initial_event" href="#openrtdynamics2.lang.initial_event">initial_event</a></code></li>
<li><code><a title="openrtdynamics2.lang.int32" href="#openrtdynamics2.lang.int32">int32</a></code></li>
<li><code><a title="openrtdynamics2.lang.leave_system" href="#openrtdynamics2.lang.leave_system">leave_system</a></code></li>
<li><code><a title="openrtdynamics2.lang.logic_and" href="#openrtdynamics2.lang.logic_and">logic_and</a></code></li>
<li><code><a title="openrtdynamics2.lang.logic_not" href="#openrtdynamics2.lang.logic_not">logic_not</a></code></li>
<li><code><a title="openrtdynamics2.lang.logic_or" href="#openrtdynamics2.lang.logic_or">logic_or</a></code></li>
<li><code><a title="openrtdynamics2.lang.logic_xor" href="#openrtdynamics2.lang.logic_xor">logic_xor</a></code></li>
<li><code><a title="openrtdynamics2.lang.memory" href="#openrtdynamics2.lang.memory">memory</a></code></li>
<li><code><a title="openrtdynamics2.lang.memory_read" href="#openrtdynamics2.lang.memory_read">memory_read</a></code></li>
<li><code><a title="openrtdynamics2.lang.operator1" href="#openrtdynamics2.lang.operator1">operator1</a></code></li>
<li><code><a title="openrtdynamics2.lang.play" href="#openrtdynamics2.lang.play">play</a></code></li>
<li><code><a title="openrtdynamics2.lang.pow" href="#openrtdynamics2.lang.pow">pow</a></code></li>
<li><code><a title="openrtdynamics2.lang.rate_limit" href="#openrtdynamics2.lang.rate_limit">rate_limit</a></code></li>
<li><code><a title="openrtdynamics2.lang.sample_and_hold" href="#openrtdynamics2.lang.sample_and_hold">sample_and_hold</a></code></li>
<li><code><a title="openrtdynamics2.lang.saturate" href="#openrtdynamics2.lang.saturate">saturate</a></code></li>
<li><code><a title="openrtdynamics2.lang.set_primary_outputs" href="#openrtdynamics2.lang.set_primary_outputs">set_primary_outputs</a></code></li>
<li><code><a title="openrtdynamics2.lang.show_blocks" href="#openrtdynamics2.lang.show_blocks">show_blocks</a></code></li>
<li><code><a title="openrtdynamics2.lang.show_execution_lines" href="#openrtdynamics2.lang.show_execution_lines">show_execution_lines</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal" href="#openrtdynamics2.lang.signal">signal</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_impulse" href="#openrtdynamics2.lang.signal_impulse">signal_impulse</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_periodic_impulse" href="#openrtdynamics2.lang.signal_periodic_impulse">signal_periodic_impulse</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_ramp" href="#openrtdynamics2.lang.signal_ramp">signal_ramp</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_sinus" href="#openrtdynamics2.lang.signal_sinus">signal_sinus</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_square" href="#openrtdynamics2.lang.signal_square">signal_square</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_step" href="#openrtdynamics2.lang.signal_step">signal_step</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_step_wise_sequence" href="#openrtdynamics2.lang.signal_step_wise_sequence">signal_step_wise_sequence</a></code></li>
<li><code><a title="openrtdynamics2.lang.sin" href="#openrtdynamics2.lang.sin">sin</a></code></li>
<li><code><a title="openrtdynamics2.lang.sqrt" href="#openrtdynamics2.lang.sqrt">sqrt</a></code></li>
<li><code><a title="openrtdynamics2.lang.sum" href="#openrtdynamics2.lang.sum">sum</a></code></li>
<li><code><a title="openrtdynamics2.lang.sum2" href="#openrtdynamics2.lang.sum2">sum2</a></code></li>
<li><code><a title="openrtdynamics2.lang.switchNto1" href="#openrtdynamics2.lang.switchNto1">switchNto1</a></code></li>
<li><code><a title="openrtdynamics2.lang.system_input" href="#openrtdynamics2.lang.system_input">system_input</a></code></li>
<li><code><a title="openrtdynamics2.lang.tan" href="#openrtdynamics2.lang.tan">tan</a></code></li>
<li><code><a title="openrtdynamics2.lang.toggle" href="#openrtdynamics2.lang.toggle">toggle</a></code></li>
<li><code><a title="openrtdynamics2.lang.transfer_function_discrete" href="#openrtdynamics2.lang.transfer_function_discrete">transfer_function_discrete</a></code></li>
<li><code><a title="openrtdynamics2.lang.unwrap_angle" href="#openrtdynamics2.lang.unwrap_angle">unwrap_angle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeArray" href="#openrtdynamics2.lang.DataTypeArray">DataTypeArray</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypeArray.cppDataType" href="#openrtdynamics2.lang.DataTypeArray.cppDataType">cppDataType</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeArray.cpp_define_variable" href="#openrtdynamics2.lang.DataTypeArray.cpp_define_variable">cpp_define_variable</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeArray.datatype_of_elements" href="#openrtdynamics2.lang.DataTypeArray.datatype_of_elements">datatype_of_elements</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeBoolean" href="#openrtdynamics2.lang.DataTypeBoolean">DataTypeBoolean</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypeBoolean.cppDataType" href="#openrtdynamics2.lang.DataTypeBoolean.cppDataType">cppDataType</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeBoolean.cppPrintfPattern" href="#openrtdynamics2.lang.DataTypeBoolean.cppPrintfPattern">cppPrintfPattern</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeBoolean.cpp_zero_element" href="#openrtdynamics2.lang.DataTypeBoolean.cpp_zero_element">cpp_zero_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeFloat64" href="#openrtdynamics2.lang.DataTypeFloat64">DataTypeFloat64</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypeFloat64.cppDataType" href="#openrtdynamics2.lang.DataTypeFloat64.cppDataType">cppDataType</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeFloat64.cppPrintfPattern" href="#openrtdynamics2.lang.DataTypeFloat64.cppPrintfPattern">cppPrintfPattern</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeFloat64.cpp_zero_element" href="#openrtdynamics2.lang.DataTypeFloat64.cpp_zero_element">cpp_zero_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeInt32" href="#openrtdynamics2.lang.DataTypeInt32">DataTypeInt32</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypeInt32.cppDataType" href="#openrtdynamics2.lang.DataTypeInt32.cppDataType">cppDataType</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeInt32.cppPrintfPattern" href="#openrtdynamics2.lang.DataTypeInt32.cppPrintfPattern">cppPrintfPattern</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeInt32.cpp_zero_element" href="#openrtdynamics2.lang.DataTypeInt32.cpp_zero_element">cpp_zero_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeNumeric" href="#openrtdynamics2.lang.DataTypeNumeric">DataTypeNumeric</a></code></h4>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.PutBasicRuntimeCpp" href="#openrtdynamics2.lang.PutBasicRuntimeCpp">PutBasicRuntimeCpp</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.PutBasicRuntimeCpp.build" href="#openrtdynamics2.lang.PutBasicRuntimeCpp.build">build</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutBasicRuntimeCpp.code_gen" href="#openrtdynamics2.lang.PutBasicRuntimeCpp.code_gen">code_gen</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutBasicRuntimeCpp.initCodeTemplate" href="#openrtdynamics2.lang.PutBasicRuntimeCpp.initCodeTemplate">initCodeTemplate</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutBasicRuntimeCpp.run" href="#openrtdynamics2.lang.PutBasicRuntimeCpp.run">run</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutBasicRuntimeCpp.write_code" href="#openrtdynamics2.lang.PutBasicRuntimeCpp.write_code">write_code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.PutRuntimeCppHelper" href="#openrtdynamics2.lang.PutRuntimeCppHelper">PutRuntimeCppHelper</a></code></h4>
<ul class="two-column">
<li><code><a title="openrtdynamics2.lang.PutRuntimeCppHelper.build" href="#openrtdynamics2.lang.PutRuntimeCppHelper.build">build</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutRuntimeCppHelper.code_gen" href="#openrtdynamics2.lang.PutRuntimeCppHelper.code_gen">code_gen</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutRuntimeCppHelper.get_algorithm_code" href="#openrtdynamics2.lang.PutRuntimeCppHelper.get_algorithm_code">get_algorithm_code</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutRuntimeCppHelper.include_systems" href="#openrtdynamics2.lang.PutRuntimeCppHelper.include_systems">include_systems</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutRuntimeCppHelper.run" href="#openrtdynamics2.lang.PutRuntimeCppHelper.run">run</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutRuntimeCppHelper.set_compile_results" href="#openrtdynamics2.lang.PutRuntimeCppHelper.set_compile_results">set_compile_results</a></code></li>
<li><code><a title="openrtdynamics2.lang.PutRuntimeCppHelper.writeFiles" href="#openrtdynamics2.lang.PutRuntimeCppHelper.writeFiles">writeFiles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.Signal" href="#openrtdynamics2.lang.Signal">Signal</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.Signal.ShowOrigin" href="#openrtdynamics2.lang.Signal.ShowOrigin">ShowOrigin</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.addDestination" href="#openrtdynamics2.lang.Signal.addDestination">addDestination</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.data_link" href="#openrtdynamics2.lang.Signal.data_link">data_link</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.datatype" href="#openrtdynamics2.lang.Signal.datatype">datatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.fixDatatype" href="#openrtdynamics2.lang.Signal.fixDatatype">fixDatatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.getDatatype" href="#openrtdynamics2.lang.Signal.getDatatype">getDatatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.getDestinationBlocks" href="#openrtdynamics2.lang.Signal.getDestinationBlocks">getDestinationBlocks</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.getProposedDatatype" href="#openrtdynamics2.lang.Signal.getProposedDatatype">getProposedDatatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.getSourceBlock" href="#openrtdynamics2.lang.Signal.getSourceBlock">getSourceBlock</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.graphTraversionMarkerMarkIsVisited" href="#openrtdynamics2.lang.Signal.graphTraversionMarkerMarkIsVisited">graphTraversionMarkerMarkIsVisited</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.graphTraversionMarkerMarkIsVisitedOnLevelLowerThan" href="#openrtdynamics2.lang.Signal.graphTraversionMarkerMarkIsVisitedOnLevelLowerThan">graphTraversionMarkerMarkIsVisitedOnLevelLowerThan</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.graphTraversionMarkerMarkVisited" href="#openrtdynamics2.lang.Signal.graphTraversionMarkerMarkVisited">graphTraversionMarkerMarkVisited</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.graphTraversionMarkerReset" href="#openrtdynamics2.lang.Signal.graphTraversionMarkerReset">graphTraversionMarkerReset</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.inherit_datatype_from_signal" href="#openrtdynamics2.lang.Signal.inherit_datatype_from_signal">inherit_datatype_from_signal</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.inherit_datatype_to" href="#openrtdynamics2.lang.Signal.inherit_datatype_to">inherit_datatype_to</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.inherit_datatype_to_list" href="#openrtdynamics2.lang.Signal.inherit_datatype_to_list">inherit_datatype_to_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.is_block_output" href="#openrtdynamics2.lang.Signal.is_block_output">is_block_output</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.is_crossing_system_boundary" href="#openrtdynamics2.lang.Signal.is_crossing_system_boundary">is_crossing_system_boundary</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.is_proxy" href="#openrtdynamics2.lang.Signal.is_proxy">is_proxy</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.is_referencing_memory" href="#openrtdynamics2.lang.Signal.is_referencing_memory">is_referencing_memory</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.is_simulation_input" href="#openrtdynamics2.lang.Signal.is_simulation_input">is_simulation_input</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.lookupSource" href="#openrtdynamics2.lang.Signal.lookupSource">lookupSource</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.name" href="#openrtdynamics2.lang.Signal.name">name</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.nameIsDefault" href="#openrtdynamics2.lang.Signal.nameIsDefault">nameIsDefault</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.properties" href="#openrtdynamics2.lang.Signal.properties">properties</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.proposed_datatype" href="#openrtdynamics2.lang.Signal.proposed_datatype">proposed_datatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.setDatatype" href="#openrtdynamics2.lang.Signal.setDatatype">setDatatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.setDatatype_nonotitication" href="#openrtdynamics2.lang.Signal.setDatatype_nonotitication">setDatatype_nonotitication</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.setProposedDatatype" href="#openrtdynamics2.lang.Signal.setProposedDatatype">setProposedDatatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.set_blockname" href="#openrtdynamics2.lang.Signal.set_blockname">set_blockname</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.set_data_link" href="#openrtdynamics2.lang.Signal.set_data_link">set_data_link</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.set_is_referencing_memory" href="#openrtdynamics2.lang.Signal.set_is_referencing_memory">set_is_referencing_memory</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.set_name" href="#openrtdynamics2.lang.Signal.set_name">set_name</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.set_name_raw" href="#openrtdynamics2.lang.Signal.set_name_raw">set_name_raw</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.set_properties" href="#openrtdynamics2.lang.Signal.set_properties">set_properties</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.system" href="#openrtdynamics2.lang.Signal.system">system</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.toStr" href="#openrtdynamics2.lang.Signal.toStr">toStr</a></code></li>
<li><code><a title="openrtdynamics2.lang.Signal.update_datatype_config" href="#openrtdynamics2.lang.Signal.update_datatype_config">update_datatype_config</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></h4>
<ul class="two-column">
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.extendName" href="#openrtdynamics2.lang.SignalUserTemplate.extendName">extendName</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.name" href="#openrtdynamics2.lang.SignalUserTemplate.name">name</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.properties" href="#openrtdynamics2.lang.SignalUserTemplate.properties">properties</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_blockname" href="#openrtdynamics2.lang.SignalUserTemplate.set_blockname">set_blockname</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_datatype" href="#openrtdynamics2.lang.SignalUserTemplate.set_datatype">set_datatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_name" href="#openrtdynamics2.lang.SignalUserTemplate.set_name">set_name</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_name_raw" href="#openrtdynamics2.lang.SignalUserTemplate.set_name_raw">set_name_raw</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_properties" href="#openrtdynamics2.lang.SignalUserTemplate.set_properties">set_properties</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.unwrap" href="#openrtdynamics2.lang.SignalUserTemplate.unwrap">unwrap</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.WasmRuntime" href="#openrtdynamics2.lang.WasmRuntime">WasmRuntime</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.WasmRuntime.build" href="#openrtdynamics2.lang.WasmRuntime.build">build</a></code></li>
<li><code><a title="openrtdynamics2.lang.WasmRuntime.code_gen" href="#openrtdynamics2.lang.WasmRuntime.code_gen">code_gen</a></code></li>
<li><code><a title="openrtdynamics2.lang.WasmRuntime.generate_code_writeIO" href="#openrtdynamics2.lang.WasmRuntime.generate_code_writeIO">generate_code_writeIO</a></code></li>
<li><code><a title="openrtdynamics2.lang.WasmRuntime.generate_code_writeIO__" href="#openrtdynamics2.lang.WasmRuntime.generate_code_writeIO__">generate_code_writeIO__</a></code></li>
<li><code><a title="openrtdynamics2.lang.WasmRuntime.initCodeTemplate" href="#openrtdynamics2.lang.WasmRuntime.initCodeTemplate">initCodeTemplate</a></code></li>
<li><code><a title="openrtdynamics2.lang.WasmRuntime.write_code" href="#openrtdynamics2.lang.WasmRuntime.write_code">write_code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.state_sub" href="#openrtdynamics2.lang.state_sub">state_sub</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.state_sub.set_switched_outputs" href="#openrtdynamics2.lang.state_sub.set_switched_outputs">set_switched_outputs</a></code></li>
<li><code><a title="openrtdynamics2.lang.state_sub.state_control_output" href="#openrtdynamics2.lang.state_sub.state_control_output">state_control_output</a></code></li>
<li><code><a title="openrtdynamics2.lang.state_sub.subsystem_outputs" href="#openrtdynamics2.lang.state_sub.subsystem_outputs">subsystem_outputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.sub_if" href="#openrtdynamics2.lang.sub_if">sub_if</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.sub_if.outputs" href="#openrtdynamics2.lang.sub_if.outputs">outputs</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_if.set_outputs" href="#openrtdynamics2.lang.sub_if.set_outputs">set_outputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.sub_loop" href="#openrtdynamics2.lang.sub_loop">sub_loop</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.sub_loop.loop_until" href="#openrtdynamics2.lang.sub_loop.loop_until">loop_until</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_loop.loop_yield" href="#openrtdynamics2.lang.sub_loop.loop_yield">loop_yield</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_loop.outputs" href="#openrtdynamics2.lang.sub_loop.outputs">outputs</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_loop.set_outputs" href="#openrtdynamics2.lang.sub_loop.set_outputs">set_outputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.sub_statemachine" href="#openrtdynamics2.lang.sub_statemachine">sub_statemachine</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.sub_statemachine.new_subsystem" href="#openrtdynamics2.lang.sub_statemachine.new_subsystem">new_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_statemachine.state" href="#openrtdynamics2.lang.sub_statemachine.state">state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.sub_switch" href="#openrtdynamics2.lang.sub_switch">sub_switch</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.sub_switch.new_subsystem" href="#openrtdynamics2.lang.sub_switch.new_subsystem">new_subsystem</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>