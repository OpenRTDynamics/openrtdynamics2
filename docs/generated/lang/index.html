<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>openrtdynamics2.lang API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openrtdynamics2.lang</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .lang import *

__pdoc__ = {}
__pdoc__[&#39;lang&#39;] = False

# __all__ = [&#39;show_required_inputs&#39;, &#39;run_batch_simulation&#39;, &#39;SystemInstance&#39;, &#39;CompiledCode&#39;]

__all__ = dir()</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="openrtdynamics2.lang.block_interface" href="block_interface.html">openrtdynamics2.lang.block_interface</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.block_prototypes" href="block_prototypes.html">openrtdynamics2.lang.block_prototypes</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.block_prototypes_single_subsystem" href="block_prototypes_single_subsystem.html">openrtdynamics2.lang.block_prototypes_single_subsystem</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.block_prototypes_subsystems" href="block_prototypes_subsystems.html">openrtdynamics2.lang.block_prototypes_subsystems</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems" href="block_prototypes_switched_subsystems.html">openrtdynamics2.lang.block_prototypes_switched_subsystems</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.code_generation_templates" href="code_generation_templates.html">openrtdynamics2.lang.code_generation_templates</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.core_blocks" href="core_blocks.html">openrtdynamics2.lang.core_blocks</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.diagram_core" href="diagram_core/index.html">openrtdynamics2.lang.diagram_core</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.high_level_user_commands" href="high_level_user_commands.html">openrtdynamics2.lang.high_level_user_commands</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.libraries" href="libraries.html">openrtdynamics2.lang.libraries</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.signal_interface" href="signal_interface.html">openrtdynamics2.lang.signal_interface</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.standard_library" href="standard_library.html">openrtdynamics2.lang.standard_library</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.subsystems" href="subsystems.html">openrtdynamics2.lang.subsystems</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="openrtdynamics2.lang.system_context" href="system_context.html">openrtdynamics2.lang.system_context</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="openrtdynamics2.lang.PID_controller"><code class="name flex">
<span>def <span class="ident">PID_controller</span></span>(<span>r, y, Ts, kp, ki=None, kd=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Discrete-time PID-controller</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the reference signal</dd>
<dt><strong><code>y</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the measured plant output</dd>
<dt><strong><code>Ts</code></strong> :&ensp;<code>float</code></dt>
<dd>the sampleing time</dd>
<dt><strong><code>kp</code></strong> :&ensp;<code>float</code></dt>
<dd>the parameter kp (proportional)</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>float</code></dt>
<dd>the parameter ki (integral)</dd>
<dt><strong><code>kd</code></strong> :&ensp;<code>float</code></dt>
<dd>the parameter kd (differential)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the control variable u</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PID_controller(r, y, Ts, kp, ki = None, kd = None):
    &#34;&#34;&#34;Discrete-time PID-controller

    Parameters
    ----------
    r : SignalUserTemplate
        the reference signal
    y : SignalUserTemplate
        the measured plant output
    Ts : float
        the sampleing time
    kp : float
        the parameter kp (proportional)
    ki : float
        the parameter ki (integral)
    kd : float
        the parameter kd (differential)

    Returns
    -------
    SignalUserTemplate
        the control variable u

    &#34;&#34;&#34;
    Ts = dy.float64(Ts)

    # control error
    e = r - y

    # P
    u = kp * e

    # D
    if kd is not None:
        u = u + dy.diff(e) * kd / Ts

    # I
    if ki is not None:
        u = u + dy.sum(e) * ki * Ts

    return u</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.abs"><code class="name flex">
<span>def <span class="ident">abs</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Absolute value</p>
<p>Computes the absolute value |u|.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abs(u : SignalUserTemplate ):
    &#34;&#34;&#34;
    Absolute value

    Computes the absolute value |u|.
    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;abs&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.acos"><code class="name flex">
<span>def <span class="ident">acos</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acos(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;acos&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>input_signals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], factors: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>Linear combination of the list of input signals with the list of factors</p>
<p>the output is given by</p>
<pre><code>input_signals[0] * factors[0] + input_signals[1] * factors[1] + ...
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(input_signals : List[SignalUserTemplate], factors : List[float]):
    &#34;&#34;&#34;
    Linear combination of the list of input signals with the list of factors

    the output is given by

        input_signals[0] * factors[0] + input_signals[1] * factors[1] + ...
    &#34;&#34;&#34;
    return wrap_signal( Add(dy.get_system_context(), unwrap_list( input_signals ), factors).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.append_primay_ouput"><code class="name flex">
<span>def <span class="ident">append_primay_ouput</span></span>(<span>output_signal, export_name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>add an output to the current system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_primay_ouput(output_signal, export_name : str = None):
    &#34;&#34;&#34;
        add an output to the current system
    &#34;&#34;&#34;

    if export_name is not None:
        output_signal.set_name_raw(export_name)

    get_system_context().append_primay_ouput(output_signal.unwrap)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.asin"><code class="name flex">
<span>def <span class="ident">asin</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def asin(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;asin&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.atan"><code class="name flex">
<span>def <span class="ident">atan</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atan(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;atan&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.atan2"><code class="name flex">
<span>def <span class="ident">atan2</span></span>(<span>y: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, x: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>atan2</p>
<p>This function returns atan2(x,y).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>x</dd>
<dt><strong><code>y</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>y</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="details">Details</h2>
<p>returns
atan2(x,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def atan2(y : SignalUserTemplate, x : SignalUserTemplate ):
    &#34;&#34;&#34;
        atan2

        This function returns atan2(x,y).

        Parameters
        ----------
        x : SignalUserTemplate
            x
        y : SignalUserTemplate
            y

        Returns
        -------
        SignalUserTemplate
            the output signal

        Details
        -------
        returns 
            atan2(x,y)

    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_2To1(dy.get_system_context(), y.unwrap, x.unwrap, &#39;atan2&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_and"><code class="name flex">
<span>def <span class="ident">bitwise_and</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>bitwise and</p>
<p>u1 &amp; u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_and(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        bitwise and

        u1 &amp; u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list([u1,u2]), operator=&#39; &amp; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_not"><code class="name flex">
<span>def <span class="ident">bitwise_not</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Bitwise not operator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the integer input signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the integer output signal</dd>
</dl>
<h2 id="details">Details</h2>
<p>returns
~u</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_not(u : SignalUserTemplate ):
    &#34;&#34;&#34;
    Bitwise not operator

    Parameters
    ----------
    u : SignalUserTemplate
        the integer input signal

    Returns
    -------
    SignalUserTemplate
        the integer output signal

    Details
    -------
    returns 
        ~u
    &#34;&#34;&#34;
    return wrap_signal( Operator0(dy.get_system_context(), u.unwrap, &#39;~&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_or"><code class="name flex">
<span>def <span class="ident">bitwise_or</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>bitwise or</p>
<p>u1 | u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_or(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        bitwise or
    
        u1 | u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; | &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_shift_left"><code class="name flex">
<span>def <span class="ident">bitwise_shift_left</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, shift: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical shift left</p>
<p>u &lt;&lt; shift</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_shift_left(u : SignalUserTemplate, shift : SignalUserTemplate):
    &#34;&#34;&#34;
        logical shift left
    
        u &lt;&lt; shift
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u,shift] ), operator=&#39; &lt;&lt; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.bitwise_shift_right"><code class="name flex">
<span>def <span class="ident">bitwise_shift_right</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, shift: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical shift left</p>
<p>u &gt;&gt; shift</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bitwise_shift_right(u : SignalUserTemplate, shift : SignalUserTemplate):
    &#34;&#34;&#34;
        logical shift left
    
        u &gt;&gt; shift
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u,shift] ), operator=&#39; &gt;&gt; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.boolean"><code class="name flex">
<span>def <span class="ident">boolean</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Cast anything to DataTypeBoolean</p>
<p>Convert the input value to a signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>, int</code></dt>
<dd>the signal or a constant value to convert to a signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the signal of type boolean</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boolean(value):
    &#34;&#34;&#34;Cast anything to DataTypeBoolean

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, int
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type boolean

    &#34;&#34;&#34;
    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeBoolean(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>clear the context</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear():
    &#34;&#34;&#34;
        clear the context
    &#34;&#34;&#34;
    init_simulation_context()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.comparison"><code class="name flex">
<span>def <span class="ident">comparison</span></span>(<span>left: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, right: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, operator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparison(left : SignalUserTemplate, right : SignalUserTemplate, operator : str ):
    return wrap_signal( ComparisionOperator(dy.get_system_context(), left.unwrap, right.unwrap, operator).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.compile_system"><code class="name flex">
<span>def <span class="ident">compile_system</span></span>(<span>system=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_system(system = None):

    if system is None:
        system = get_system_context() 

    system.propagate_datatypes()

    #
    # compile the diagram: turn the blocks and signals into a tree-structure of commands to execute
    # at runtime.
    #

    compiler = dc.CompileDiagram()
    compile_results = compiler.compile( system )

    #
    return compile_results</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.conditional_overwrite"><code class="name flex">
<span>def <span class="ident">conditional_overwrite</span></span>(<span>signal: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, condition: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, new_value)</span>
</code></dt>
<dd>
<div class="desc"><p>Overwrite the input signal by a given value in case a condition is true</p>
<p>The output is given by</p>
<pre><code>signal     for condition==false
new_value  for condition==true
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>signal</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal</dd>
<dt><strong><code>condition</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the boolean condition for when to overwrite signal</dd>
<dt><strong><code>new_value</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>, float, int</code></dt>
<dd>the value with is used to replace the input in case the condition is true</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conditional_overwrite(signal : SignalUserTemplate, condition : SignalUserTemplate, new_value ):
    &#34;&#34;&#34;
    Overwrite the input signal by a given value in case a condition is true

    The output is given by

        signal     for condition==false
        new_value  for condition==true

    Parameters
    ----------
    signal : SignalUserTemplate
        the input signal
    condition : SignalUserTemplate
        the boolean condition for when to overwrite signal
    new_value : SignalUserTemplate, float, int
        the value with is used to replace the input in case the condition is true

    Returns
    -------
    SignalUserTemplate
        the output signal
    &#34;&#34;&#34;

    if isinstance(new_value, SignalUserTemplate):
        new_value = new_value.unwrap

    return wrap_signal( ConditionalOverwrite(dy.get_system_context(), signal.unwrap, condition.unwrap, new_value).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.const"><code class="name flex">
<span>def <span class="ident">const</span></span>(<span>constant, datatype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def const(constant, datatype ):
    return wrap_signal( Const(dy.get_system_context(), constant, datatype).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.convert"><code class="name flex">
<span>def <span class="ident">convert</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, target_type: <a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Datatype conversion</p>
<p>The input is converted to the given datatype</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal</dd>
<dt><strong><code>target_type</code></strong></dt>
<dd>the datatype to convert the signal to</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal with the given type</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert(u : SignalUserTemplate, target_type : dt.DataType ):
    &#34;&#34;&#34;
    Datatype conversion

    The input is converted to the given datatype

    Parameters
    ----------
    u : SignalUserTemplate
        the input signal
    target_type
        the datatype to convert the signal to

    Returns
    -------
    SignalUserTemplate
        the output signal with the given type
    &#34;&#34;&#34;
    return wrap_signal( ConvertDatatype(dy.get_system_context(), u.unwrap, target_type).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.cos"><code class="name flex">
<span>def <span class="ident">cos</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cos(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;cos&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.counter"><code class="name flex">
<span>def <span class="ident">counter</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic counter - the sampling index k</p>
<p>The integer output is increasing with each sampling instant by 1.
Counting starts at zero.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the integer output signal describing the sampling index k</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counter():
    &#34;&#34;&#34;Basic counter - the sampling index k

    The integer output is increasing with each sampling instant by 1.
    Counting starts at zero.

    Returns
    -------
    SignalUserTemplate
        the integer output signal describing the sampling index k

    &#34;&#34;&#34;

    if not &#39;counter&#39; in dy.get_system_context().components:
        # no counter has been defined in this system so far. Hence, create one.

        increase = dy.const(1, dy.DataTypeInt32(1) )
        cnt = dy.signal()
        tmp = dy.delay(cnt + increase)
        cnt &lt;&lt; tmp 

        tmp.set_name(&#39;shared_counter&#39;)

        # store the output signal of the counter as it might be used again. 
        dy.get_system_context().components[&#39;counter&#39;] = __Counter(tmp)

    else:
        # use the output of an already created counter
        tmp = dy.get_system_context().components[&#39;counter&#39;].output

    return tmp</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.counter_triggered"><code class="name flex">
<span>def <span class="ident">counter_triggered</span></span>(<span>upper_limit, stepwidth=None, initial_state=0, reset=None, reset_on_limit: bool = False, start_trigger=None, pause_trigger=None, auto_start: bool = True, no_delay: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic counter</p>
<p>Features:
- upper limit
- triggerable start/pause
- resetable
- dynamic adjustable step-size</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>upper_limit</code></strong> :&ensp;<code>int</code></dt>
<dd>the upper limit of the counter</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>int</code></dt>
<dd>the state after reset</dd>
<dt><strong><code>reset</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>reset the counter</dd>
<dt><strong><code>reset_on_limit</code></strong> :&ensp;<code>bool</code></dt>
<dd>reset counter once the upper limit is reached</dd>
<dt><strong><code>start_trigger</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>event to start counting</dd>
<dt><strong><code>pause_trigger</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>event to pause counting</dd>
<dt><strong><code>auto_start</code></strong> :&ensp;<code>bool</code></dt>
<dd>start counting automatically</dd>
<dt><strong><code>no_delay</code></strong> :&ensp;<code>bool</code></dt>
<dd>when True the new value of the counter is returned without delay</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the boolean output signal</dd>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>event that fires when the upper limit of the counter is reached</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counter_triggered( upper_limit, stepwidth=None, initial_state = 0, reset=None, reset_on_limit:bool=False, start_trigger=None, pause_trigger=None, auto_start:bool=True, no_delay:bool=False ):
    &#34;&#34;&#34;A generic counter

    Features:
    - upper limit
    - triggerable start/pause
    - resetable
    - dynamic adjustable step-size

    Parameters
    ----------

    upper_limit : int
        the upper limit of the counter
    initial_state : int
        the state after reset
    reset : SignalUserTemplate
        reset the counter
    reset_on_limit : bool
        reset counter once the upper limit is reached
    start_trigger : SignalUserTemplate
        event to start counting
    pause_trigger : SignalUserTemplate
        event to pause counting
    auto_start : bool
        start counting automatically
    no_delay : bool
        when True the new value of the counter is returned without delay 

    Returns
    -------
    SignalUserTemplate
        the boolean output signal 
    SignalUserTemplate
        event that fires when the upper limit of the counter is reached 
        
    &#34;&#34;&#34;

    if stepwidth is None:
        stepwidth = dy.int32(1)

    counter = dy.signal()

    reached_upper_limit = counter &gt;= dy.int32(upper_limit)

    if start_trigger is None:
        start_trigger = dy.boolean(0)

    # 
    if pause_trigger is not None: 
        activate_trigger = dy.logic_or(reached_upper_limit, pause_trigger)
    else:
        if not auto_start:
            activate_trigger = reached_upper_limit
        else:
            # when auto_start is active, continue counting after reset on reached_upper_limit
            activate_trigger = dy.boolean(0)


    # state for pause/counting
    paused =  dy.flipflop(activate_trigger=activate_trigger, disable_trigger=start_trigger, initial_state = not auto_start, no_delay=True).set_name(&#39;paused&#39;)

    # prevent counter increase
    stepwidth = dy.conditional_overwrite(stepwidth, paused, 0).set_name(&#39;stepwidth&#39;)

    # increase the counter until the end is reached
    new_counter = counter + dy.conditional_overwrite(stepwidth, reached_upper_limit, 0)

    if reset is not None:
        # reset in case this is requested
        new_counter = dy.conditional_overwrite(new_counter, reset, initial_state)

    if reset_on_limit:
        new_counter = dy.conditional_overwrite(new_counter, reached_upper_limit, initial_state)

    # introduce a state variable for the counter
    counter &lt;&lt; dy.delay( new_counter, initial_state=initial_state )

    if not no_delay:
        return counter, reached_upper_limit
    else:
        return new_counter, reached_upper_limit</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.cpp_allocate_class"><code class="name flex">
<span>def <span class="ident">cpp_allocate_class</span></span>(<span>datatype, code_constructor_call)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a pointer signal pointing to a class instance initialized by code_constructor_call</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ptr_signal</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.DataTypePointer" href="#openrtdynamics2.lang.DataTypePointer">DataTypePointer</a></code></dt>
<dd>the datatype of the pointer to use</dd>
<dt><strong><code>code_constructor_call</code></strong> :&ensp;<code>str</code></dt>
<dd>the code to initialize the class instance</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cpp_allocate_class(datatype, code_constructor_call):
    &#34;&#34;&#34;
        Return a pointer signal pointing to a class instance initialized by code_constructor_call

        Parameters
        ----------
        ptr_signal : DataTypePointer
            the datatype of the pointer to use
        code_constructor_call : str
            the code to initialize the class instance

    &#34;&#34;&#34;
    return wrap_signal( AllocateClass(dy.get_system_context(), datatype, code_constructor_call).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.cpp_call_class_member_function"><code class="name flex">
<span>def <span class="ident">cpp_call_class_member_function</span></span>(<span>ptr_signal: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, input_signals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], input_types, output_types, member_function_name_to_calc_outputs: str = None, member_function_name_to_update_states: str = None, member_function_name_to_reset_states: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Call member functions of a c++ class</p>
<p>This function calls member functions of a class instance given by a pointer to an instance.
In- and outputs are passed as parameters to the member function given by
'member_function_name_to_calc_outputs'. Herein, the output signals are the first parameters
and the input signals then follow.</p>
<p>On an optional state update call, the member function 'member_function_name_to_update_states'
is called and the parameters are the input signals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ptr_signal</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the pointer to the class instance as generated by cpp_allocate_class()</dd>
<dt><strong><code>input_signals</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>a list of input signals that are passed to the called member functions via the parameters</dd>
<dt><strong><code>input_types</code></strong> :&ensp;<code>List[ Datatype ]</code></dt>
<dd>the datatypes of the inputs</dd>
<dt><strong><code>output_types</code></strong> :&ensp;<code>List[ Datatype ]</code></dt>
<dd>the datatypes of the outputs</dd>
<dt><strong><code>member_function_name_to_calc_outputs</code></strong> :&ensp;<code>str</code></dt>
<dd>the name of the member function to call to compute the output signals</dd>
<dt><strong><code>member_function_name_to_update_states</code></strong> :&ensp;<code>str</code></dt>
<dd>optional: the name of the member function to call to update the states</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[SignalUserTemplate|</code></dt>
<dd>the output signals</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cpp_call_class_member_function(
    ptr_signal : SignalUserTemplate, 
        
    input_signals : List[SignalUserTemplate], input_types, 
    output_types,

    member_function_name_to_calc_outputs : str = None,
    member_function_name_to_update_states : str = None,
    member_function_name_to_reset_states : str = None

):
    &#34;&#34;&#34;
        Call member functions of a c++ class

        This function calls member functions of a class instance given by a pointer to an instance.
        In- and outputs are passed as parameters to the member function given by
        &#39;member_function_name_to_calc_outputs&#39;. Herein, the output signals are the first parameters
        and the input signals then follow.

        On an optional state update call, the member function &#39;member_function_name_to_update_states&#39;
        is called and the parameters are the input signals.

        Parameters
        ----------
        ptr_signal : SignalUserTemplate
            the pointer to the class instance as generated by cpp_allocate_class()
        input_signals : SignalUserTemplate
            a list of input signals that are passed to the called member functions via the parameters
        input_types : List[ Datatype ]
            the datatypes of the inputs
        output_types : List[ Datatype ]
            the datatypes of the outputs
        member_function_name_to_calc_outputs : str
            the name of the member function to call to compute the output signals
        member_function_name_to_update_states : str
            optional: the name of the member function to call to update the states

        Returns
        -------
        List[SignalUserTemplate|
            the output signals

    &#34;&#34;&#34;
    bp = CallClassMemberFunction(
        dy.get_system_context(), 
        unwrap_list(input_signals), 
        input_types, 
        output_types, 
        ptr_signal = ptr_signal.unwrap,

        member_function_name_to_calc_outputs  = member_function_name_to_calc_outputs,
        member_function_name_to_update_states = member_function_name_to_update_states,
        member_function_name_to_reset_states  = member_function_name_to_reset_states
    )
    return wrap_signal_list( bp.outputs )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>u, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unit delay</p>
<p>Delay the input u by one sampling instant:</p>
<pre><code>y[k+1] = u[k], y[0] = initial_state
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal to delay</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the initial state (signal or constant value)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the one-step delayed input</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay(u , initial_state = None):
    &#34;&#34;&#34;Unit delay

    Delay the input u by one sampling instant:

        y[k+1] = u[k], y[0] = initial_state

    Parameters
    ----------
    u : SignalUserTemplate
        the input signal to delay
    initial_state : SignalUserTemplate
        the initial state (signal or constant value)

    Returns
    -------
    SignalUserTemplate
        the one-step delayed input   

    &#34;&#34;&#34;

    if not isinstance( initial_state, SignalUserTemplate ):
        return dy.delay__( u, initial_state )

    else:

        event_on_first_sample = initial_event()

        delayed_input = dy.delay__( u, None )
        delayed_input = dy.conditional_overwrite( delayed_input, event_on_first_sample, initial_state )

        return delayed_input</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.delay__"><code class="name flex">
<span>def <span class="ident">delay__</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay__(u : SignalUserTemplate, initial_state = None):
    return wrap_signal( Delay(dy.get_system_context(), u.unwrap, initial_state ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Discrete difference</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>float, <a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the initial state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<p>y = u[k] - u[k-1] </p>
<p>initial state</p>
<p>u[0] = initial_state
in case initial_state is not None
u[0] = 0
otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(u : SignalUserTemplate, initial_state = None):
    &#34;&#34;&#34;Discrete difference

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    y = u[k] - u[k-1] 

    initial state

    u[0] = initial_state   in case initial_state is not None
    u[0] = 0               otherwise
    &#34;&#34;&#34;

    i = dy.delay( u, initial_state )
    y = dy.add( [ i, u ], [ -1, 1 ] )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.dtf_lowpass_1_order"><code class="name flex">
<span>def <span class="ident">dtf_lowpass_1_order</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, z_infinity)</span>
</code></dt>
<dd>
<div class="desc"><p>First-order discrete-time low pass filter</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<pre><code>            1 - z_infinity
    H (z) =  --------------
            z - z_infinity
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dtf_lowpass_1_order(u : SignalUserTemplate, z_infinity):
    &#34;&#34;&#34;First-order discrete-time low pass filter

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

                    1 - z_infinity
            H (z) =  --------------
                    z - z_infinity
    &#34;&#34;&#34;

    zinf = dy.float64( z_infinity )
    zinf_ = dy.float64( 1 ) - zinf

    y_delayed = dy.signal()
    y =  zinf * y_delayed + zinf_ * u

    y_delayed &lt;&lt; dy.delay(y)
    
    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.enter_system"><code class="name flex">
<span>def <span class="ident">enter_system</span></span>(<span>name: str = 'simulation', upper_level_system=None)</span>
</code></dt>
<dd>
<div class="desc"><p>create a new system and activate it in the context</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enter_system(name : str = &#39;simulation&#39;, upper_level_system = None):
    &#34;&#34;&#34;
        create a new system and activate it in the context
    &#34;&#34;&#34;
    # new simulation
    system = System(upper_level_system, name)

    # register this subsystem to the parent system
    if get_system_context() is not None:
        get_system_context().append_subsystem( system )

    push_simulation_context(system)

    return system</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.euler_integrator"><code class="name flex">
<span>def <span class="ident">euler_integrator</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, Ts, initial_state=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Euler (forward) integrator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal</dd>
<dt><strong><code>Ts</code></strong> :&ensp;<code>float</code></dt>
<dd>the sampling time</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>float, <a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the initial state of the integrator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<pre><code>y[k+1] = y[k] + Ts * u[k]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euler_integrator( u : SignalUserTemplate, Ts, initial_state = 0.0):
    &#34;&#34;&#34;Euler (forward) integrator

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    Ts : float
        the sampling time
    initial_state : float, SignalUserTemplate
        the initial state of the integrator

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

        y[k+1] = y[k] + Ts * u[k]
    &#34;&#34;&#34;

    yFb = dy.signal()

    if not isinstance( Ts, SignalUserTemplate ): 
        i = dy.add( [ yFb, u ], [ 1, Ts ] )
    else:
        i = yFb + Ts * u

    y = dy.delay( i, initial_state )

    yFb &lt;&lt; y

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.export_graph"><code class="name flex">
<span>def <span class="ident">export_graph</span></span>(<span>filename, system=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_graph(filename, system = None):

    if system is None:
        system = get_system_context() 

    graph = system.exportGraph()

    with open( os.path.join(  filename ), &#39;w&#39;) as outfile:  
        json.dump(graph, outfile)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.flipflop"><code class="name flex">
<span>def <span class="ident">flipflop</span></span>(<span>activate_trigger: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, disable_trigger: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=False, no_delay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Flipflop logic element</p>
<p>The block has a state that can be activated or deactivated by the external boolean events 'activate_trigger'
and 'disable_trigger', respectively.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>activate_trigger</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>
</code></dt>
<dd>the event to activate the state</dd>
<dt><strong><code>disable_trigger</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>
</code></dt>
<dd>the event to deactivate the state</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>bool
</code></dt>
<dd>the initial state</dd>
<dt><strong><code>no_delay</code></strong> :&ensp;<code>bool</code></dt>
<dd>return the state change without a delay</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the state</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flipflop(activate_trigger : SignalUserTemplate, disable_trigger : SignalUserTemplate, initial_state = False, no_delay = False):
    &#34;&#34;&#34;Flipflop logic element

    The block has a state that can be activated or deactivated by the external boolean events &#39;activate_trigger&#39;
    and &#39;disable_trigger&#39;, respectively.

    Parameters
    ----------
    activate_trigger : SignalUserTemplate       
        the event to activate the state
    disable_trigger : SignalUserTemplate       
        the event to deactivate the state
    initial_state : bool       
        the initial state
    no_delay : bool
        return the state change without a delay 

    Returns
    -------
    SignalUserTemplate
        the state

    &#34;&#34;&#34;
    
    return wrap_signal( Flipflop(dy.get_system_context(), activate_trigger.unwrap, disable_trigger.unwrap, initial_state = initial_state, no_delay=no_delay ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.float64"><code class="name flex">
<span>def <span class="ident">float64</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Cast anything to DataTypeFloat64</p>
<p>Convert the input value to a signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>, float</code></dt>
<dd>the signal or a constant value to convert to a signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the signal of type float64</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def float64(value):
    &#34;&#34;&#34;Cast anything to DataTypeFloat64

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, float
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type float64

    &#34;&#34;&#34;
    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeFloat64(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.fmod"><code class="name flex">
<span>def <span class="ident">fmod</span></span>(<span>x: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, y: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Modulo function for floating point values</p>
<p>This function returns the remainder of dividing x/y.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>x</dd>
<dt><strong><code>y</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>y</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="details">Details</h2>
<pre><code>returns fmod(x,y)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fmod(x : SignalUserTemplate, y : SignalUserTemplate ):
    &#34;&#34;&#34;
        Modulo function for floating point values

        This function returns the remainder of dividing x/y.

        Parameters
        ----------
        x : SignalUserTemplate
            x
        y : SignalUserTemplate
            y

        Returns
        -------
        SignalUserTemplate
            the output signal

        Details
        -------
            returns fmod(x,y)

    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_2To1(dy.get_system_context(), x.unwrap, y.unwrap, &#39;fmod&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.gain"><code class="name flex">
<span>def <span class="ident">gain</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, gain: float)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gain(u : SignalUserTemplate, gain : float ):
    return wrap_signal( Gain(dy.get_system_context(), u.unwrap, gain).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.generate_code"><code class="name flex">
<span>def <span class="ident">generate_code</span></span>(<span>template: <a title="openrtdynamics2.lang.code_generation_templates.TargetGenericCpp" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetGenericCpp">TargetGenericCpp</a>, folder=None, build=False, include_code_list: List[str] = [])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code(template : TargetGenericCpp, folder=None, build=False, include_code_list : t.List[str] = [] ):

    template.add_code_to_include(include_code_list)

    # Compile system (propagate datatypes)
    compile_results = compile_system()

    # Build an executable based on a template
    template.set_compile_results( compile_results )
    code_gen_results = template.code_gen()

    if folder is not None:

        # check of path exists - in case no, create it
        pl.Path(folder).mkdir(parents=True, exist_ok=True)

        print(&#34;Generated code will be written to &#34; + str(folder) + &#39; .&#39;)

        # write generated code into a folder and build
        template.write_code(folder)

        if build:
            template.build()


    return code_gen_results</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.generic_cpp_static"><code class="name flex">
<span>def <span class="ident">generic_cpp_static</span></span>(<span>input_signals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], input_names: List[str], input_types, output_names, output_types, cpp_source_code: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Embed C/C++ source code (stateless code only)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>input_signals</code></strong> :&ensp;<code>List[<a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>]</code></dt>
<dd>the list of input signals</dd>
<dt><strong><code>input_names</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>the list of the names of the input signals to be used as variable names for the c++ code</dd>
<dt><strong><code>input_types</code></strong> :&ensp;<code>List[Datatype]</code></dt>
<dd>the list of the datatypes of the input signals (must be fixed)</dd>
<dt><strong><code>output_types</code></strong> :&ensp;<code>List[Datatype]</code></dt>
<dd>the list of the datatypes of the output signals (must be fixed)</dd>
<dt><strong><code>output_names</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>the list of the names of the output signals to be used as variable names for the c++ code</dd>
<dt><strong><code>cpp_source_code</code></strong> :&ensp;<code>str</code></dt>
<dd>the code to embed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>]</code></dt>
<dd>the output signals</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>source_code = """

    // This is c++ code
    output1 = value;
    if (someinput &gt; value) {
        output2 = value;
    } else {
        output2 = someinput;
    }
    output3 = 0.0;

"""

outputs = dy.generic_cpp_static(
    input_signals=[ someinput, value ], input_names=[ 'someinput', 'value' ], 
    input_types=[ dy.DataTypeFloat64(1), dy.DataTypeFloat64(1) ], 
    output_names=['output1', 'output2', 'output3'],
    output_types=[ dy.DataTypeFloat64(1), dy.DataTypeFloat64(1), dy.DataTypeFloat64(1) ],
    cpp_source_code = source_code
)

output1 = outputs[0]
output2 = outputs[1]
output3 = outputs[2]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_cpp_static(
    input_signals : List[SignalUserTemplate], input_names : List [str], input_types, 
    output_names, output_types, 
    cpp_source_code : str
):
    &#34;&#34;&#34;
    Embed C/C++ source code (stateless code only)

    Parameters
    ----------
    input_signals : List[SignalUserTemplate]
        the list of input signals
    input_names : List[str]
        the list of the names of the input signals to be used as variable names for the c++ code
    input_types : List[Datatype]
        the list of the datatypes of the input signals (must be fixed)
    output_types : List[Datatype]
        the list of the datatypes of the output signals (must be fixed)
    output_names : List[str]
        the list of the names of the output signals to be used as variable names for the c++ code
    cpp_source_code : str
        the code to embed

    Returns
    -------
    List[SignalUserTemplate]
        the output signals

    Example
    -------

        source_code = \&#34;\&#34;\&#34;

            // This is c++ code
            output1 = value;
            if (someinput &gt; value) {
                output2 = value;
            } else {
                output2 = someinput;
            }
            output3 = 0.0;

        \&#34;\&#34;\&#34;

        outputs = dy.generic_cpp_static(
            input_signals=[ someinput, value ], input_names=[ &#39;someinput&#39;, &#39;value&#39; ], 
            input_types=[ dy.DataTypeFloat64(1), dy.DataTypeFloat64(1) ], 
            output_names=[&#39;output1&#39;, &#39;output2&#39;, &#39;output3&#39;],
            output_types=[ dy.DataTypeFloat64(1), dy.DataTypeFloat64(1), dy.DataTypeFloat64(1) ],
            cpp_source_code = source_code
        )

        output1 = outputs[0]
        output2 = outputs[1]
        output3 = outputs[2]
    &#34;&#34;&#34;
    return wrap_signal_list( GenericCppStatic(dy.get_system_context(), unwrap_list(input_signals), input_names, input_types, output_names, output_types, cpp_source_code  ).outputs )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.generic_subsystem"><code class="name flex">
<span>def <span class="ident">generic_subsystem</span></span>(<span>manifest, inputSignals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generic_subsystem( manifest, inputSignals : List[SignalUserTemplate] ):
    return wrap_signal_list( GenericSubsystem(dy.get_system_context(), manifest, unwrap_hash(inputSignals) ).outputSignals )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.get_system_context"><code class="name flex">
<span>def <span class="ident">get_system_context</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_context():
    global current_simulation_context
    return current_simulation_context</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>autoreset=False, convert=None, strip=None, wrap=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(autoreset=False, convert=None, strip=None, wrap=True):

    if not wrap and any([autoreset, convert, strip]):
        raise ValueError(&#39;wrap=False conflicts with any other arg=True&#39;)

    global wrapped_stdout, wrapped_stderr
    global orig_stdout, orig_stderr

    orig_stdout = sys.stdout
    orig_stderr = sys.stderr

    if sys.stdout is None:
        wrapped_stdout = None
    else:
        sys.stdout = wrapped_stdout = \
            wrap_stream(orig_stdout, convert, strip, autoreset, wrap)
    if sys.stderr is None:
        wrapped_stderr = None
    else:
        sys.stderr = wrapped_stderr = \
            wrap_stream(orig_stderr, convert, strip, autoreset, wrap)

    global atexit_done
    if not atexit_done:
        atexit.register(reset_all)
        atexit_done = True</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.init_simulation_context"><code class="name flex">
<span>def <span class="ident">init_simulation_context</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_simulation_context():
    global simulation_stack
    global current_simulation_context
    global counter_of_created_systems

    current_simulation_context = None
    simulation_stack = []
    counter_of_created_systems = 1000</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.initial_event"><code class="name flex">
<span>def <span class="ident">initial_event</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Emits an event on the first sampling instant after the reset of the system</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the signal of type boolean containing the event</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initial_event():
    &#34;&#34;&#34;Emits an event on the first sampling instant after the reset of the system

    Returns
    -------
    SignalUserTemplate
        the signal of type boolean containing the event
    &#34;&#34;&#34;

    # TODO: introduce caching like done for counter()

    return dy.counter() == int32(0)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.int32"><code class="name flex">
<span>def <span class="ident">int32</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Cast anything to DataTypeInt32</p>
<p>Convert the input value to a signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>, int</code></dt>
<dd>the signal or a constant value to convert to a signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the signal of type int32</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int32(value):
    &#34;&#34;&#34;Cast anything to DataTypeInt32

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, int
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type int32

    &#34;&#34;&#34;

    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeInt32(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.leave_system"><code class="name flex">
<span>def <span class="ident">leave_system</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def leave_system():
    return pop_simulation_context()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.logic_and"><code class="name flex">
<span>def <span class="ident">logic_and</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical and</p>
<p>u1 &amp;&amp; u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_and(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        logical and

        u1 &amp;&amp; u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list([u1,u2]), operator=&#39; &amp;&amp; &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.logic_not"><code class="name flex">
<span>def <span class="ident">logic_not</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Logic negation</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the boolean input signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the boolean output signal</dd>
</dl>
<h2 id="details">Details</h2>
<p>returns
!u</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_not(u : SignalUserTemplate ):
    &#34;&#34;&#34;
    Logic negation

    Parameters
    ----------
    u : SignalUserTemplate
        the boolean input signal

    Returns
    -------
    SignalUserTemplate
        the boolean output signal

    Details
    -------
    returns 
        !u
    &#34;&#34;&#34;
    return wrap_signal( Operator0(dy.get_system_context(), u.unwrap, &#39;!&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.logic_or"><code class="name flex">
<span>def <span class="ident">logic_or</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>logical or</p>
<p>u1 || u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_or(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        logical or
    
        u1 || u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; || &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.logic_xor"><code class="name flex">
<span>def <span class="ident">logic_xor</span></span>(<span>u1: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, u2: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>exclusive logical or (xor)</p>
<p>u1 ^ u2</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def logic_xor(u1 : SignalUserTemplate, u2 : SignalUserTemplate):
    &#34;&#34;&#34;
        exclusive logical or (xor)
    
        u1 ^ u2
    &#34;&#34;&#34;

    return wrap_signal( Operator1(dy.get_system_context(), inputSignals=unwrap_list( [u1,u2] ), operator=&#39; ^ &#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.memory"><code class="name flex">
<span>def <span class="ident">memory</span></span>(<span>datatype, constant_array, write_index: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a> = None, value: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Define an array for storing and reading values</p>
<p>Allocates static memory for an array of elements given a datatype.
During each sampling instant, one element can be (over)written. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>datatype</code></strong> :&ensp;<code>Datatype
</code></dt>
<dd>the datatype of the array elements</dd>
<dt><strong><code>constant_array</code></strong> :&ensp;<code>List[float], List[int]</code></dt>
<dd>list of constants that contain the data to initialize the array</dd>
<dt><strong><code>write_index</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the array index (integer signal) of the element to replace by value (optional)</dd>
<dt><strong><code>value</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the value to write into the array at write_index (optional)</dd>
</dl>
<p>returns a reference to the memory segment which is accessible by memory_read()</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>]</code></dt>
<dd>a reference to the memory segment which is accessible by memory_read()</dd>
</dl>
<h2 id="limitations">Limitations</h2>
<p>currently the memory is not reset on subsystem reset. This will change.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory(datatype, constant_array, write_index : SignalUserTemplate = None, value : SignalUserTemplate = None):
    &#34;&#34;&#34;
    Define an array for storing and reading values

    Allocates static memory for an array of elements given a datatype.
    During each sampling instant, one element can be (over)written. 

    Parameters
    ----------
    datatype : Datatype       
        the datatype of the array elements
    constant_array : List[float], List[int]
        list of constants that contain the data to initialize the array
    write_index : SignalUserTemplate
        the array index (integer signal) of the element to replace by value (optional)
    value : SignalUserTemplate
        the value to write into the array at write_index (optional)

    returns a reference to the memory segment which is accessible by memory_read()

    Returns
    -------
    List[SignalUserTemplate]
        a reference to the memory segment which is accessible by memory_read()


    Limitations
    -----------
    currently the memory is not reset on subsystem reset. This will change.
    &#34;&#34;&#34;

    if write_index is not None and value is not None:
        return wrap_signal( Memory(dy.get_system_context(), datatype, constant_array, write_index.unwrap, value.unwrap).outputs[0] )
    elif write_index is None and value is None:
        return wrap_signal( Memory(dy.get_system_context(), datatype, constant_array).outputs[0] )
    else:
        raise BaseException(&#39;memory: write_index and value were not properly defined&#39;)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.memory_read"><code class="name flex">
<span>def <span class="ident">memory_read</span></span>(<span>memory: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, index: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Read an element from an array defined by memory()</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>memory</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the memory as returned by memory()</dd>
<dt><strong><code>index</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the index indicating the element to read</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[<a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>]</code></dt>
<dd>returns the value of the element</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def memory_read( memory : SignalUserTemplate, index : SignalUserTemplate ):
    &#34;&#34;&#34;
    Read an element from an array defined by memory()

    Parameters
    ----------
    memory : SignalUserTemplate
        the memory as returned by memory()
    index : SignalUserTemplate
        the index indicating the element to read

    Returns
    -------
    List[SignalUserTemplate]
        returns the value of the element
    &#34;&#34;&#34;
    return wrap_signal( MemoryRead(dy.get_system_context(), memory.unwrap, index.unwrap ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.operator1"><code class="name flex">
<span>def <span class="ident">operator1</span></span>(<span>inputSignals: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>], operator: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operator1(inputSignals : List[SignalUserTemplate], operator : str ):
    return wrap_signal( Operator1(dy.get_system_context(), unwrap_list( inputSignals ), operator).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>sequence_array, stepwidth=None, initial_state=0, reset=None, reset_on_end: bool = False, start_trigger=None, pause_trigger=None, auto_start: bool = True, no_delay: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Play a given sequence of samples</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sequence_array</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>the sequence given as a list of values</dd>
<dt><strong><code>reset</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>reset playback and start from the beginning</dd>
<dt><strong><code>reset_on_end</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>reset playback once the end is reached (repetitive playback)</dd>
<dt><strong><code>start_trigger</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>event to start playback</dd>
<dt><strong><code>pause_trigger</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>event to pause playback</dd>
<dt><strong><code>auto_start</code></strong> :&ensp;<code>bool</code></dt>
<dd>start playback automatically</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the value obtained from sequence_array</dd>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the current position of playback (index of the currently issued sequence element)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play( sequence_array,  stepwidth=None, initial_state = 0, reset=None, reset_on_end:bool=False, start_trigger=None, pause_trigger=None, auto_start:bool=True, no_delay:bool=False ):
    &#34;&#34;&#34;Play a given sequence of samples

    Parameters
    ----------

    sequence_array : list[float]
        the sequence given as a list of values
    reset : SignalUserTemplate
        reset playback and start from the beginning
    reset_on_end : SignalUserTemplate
        reset playback once the end is reached (repetitive playback)
    start_trigger : SignalUserTemplate
        event to start playback
    pause_trigger : SignalUserTemplate
        event to pause playback
    auto_start : bool
        start playback automatically 


    Returns
    -------
    SignalUserTemplate
        the value obtained from sequence_array
    SignalUserTemplate
        the current position of playback (index of the currently issued sequence element)


    &#34;&#34;&#34;

    sequence_array_storage = dy.memory(datatype=dy.DataTypeFloat64(1), constant_array=sequence_array )

    # if prevent_initial_playback:
    #     initial_counter_state = np.size(sequence_array)
    # else:
        

    playback_index, _ = counter_triggered(
        upper_limit=np.size(sequence_array)-1, 
        stepwidth=stepwidth, initial_state=initial_state, 
        reset=reset, reset_on_limit=reset_on_end, 
        start_trigger=start_trigger, pause_trigger=pause_trigger, 
        auto_start=auto_start,
        no_delay=no_delay
    )

    # sample the given data
    sample = dy.memory_read(sequence_array_storage, playback_index)

    return sample, playback_index</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.pow"><code class="name flex">
<span>def <span class="ident">pow</span></span>(<span>x: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, y: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Power function for floating point values</p>
<p>This function returns the x to the power of y (x^y).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>x</dd>
<dt><strong><code>y</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>y</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="details">Details</h2>
<pre><code>returns pow(x,y)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pow(x : SignalUserTemplate, y : SignalUserTemplate ):
    &#34;&#34;&#34;
        Power function for floating point values

        This function returns the x to the power of y (x^y).

        Parameters
        ----------
        x : SignalUserTemplate
            x
        y : SignalUserTemplate
            y

        Returns
        -------
        SignalUserTemplate
            the output signal

        Details
        -------
            returns pow(x,y)

    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_2To1(dy.get_system_context(), x.unwrap, y.unwrap, &#39;pow&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.rate_limit"><code class="name flex">
<span>def <span class="ident">rate_limit</span></span>(<span>u, Ts, lower_limit, upper_limit, initial_state=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Rate limiter</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Ts</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>sampling time (constant)</dd>
<dt><strong><code>lower_limit</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>lower rate limit</dd>
<dt><strong><code>upper_limit</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>upper rate limit</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rate_limit( u, Ts, lower_limit, upper_limit, initial_state = 0 ):
    &#34;&#34;&#34;Rate limiter

    Parameters
    ----------

    Ts : SignalUserTemplate
        sampling time (constant)
    lower_limit : SignalUserTemplate
        lower rate limit
    upper_limit : SignalUserTemplate
        upper rate limit

    Returns
    -------
    SignalUserTemplate
        the output signal    

    &#34;&#34;&#34;

    Ts_ = float64(Ts)

    y = dy.signal()

    omega = u - y
    omega_sat = saturate(omega, float64(lower_limit) * Ts_, float64(upper_limit) * Ts_)
    y &lt;&lt; euler_integrator( omega_sat, 1, initial_state=initial_state)

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sample_and_hold"><code class="name flex">
<span>def <span class="ident">sample_and_hold</span></span>(<span>u, event, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample &amp; hold</p>
<p>Samples the input when event is true and hold this value for the proceeding time instants. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input to sample</dd>
<dt><strong><code>event</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the event on which sampling of the input is performed</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the initial output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the sampled input</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_and_hold(u, event, initial_state = None):
    &#34;&#34;&#34;Sample &amp; hold

    Samples the input when event is true and hold this value for the proceeding time instants. 

    Parameters
    ----------
    u : SignalUserTemplate
        the input to sample
    event : SignalUserTemplate
        the event on which sampling of the input is performed
    initial_state : SignalUserTemplate
        the initial output

    Returns
    -------
    SignalUserTemplate
        the sampled input   

    &#34;&#34;&#34;

    # NOTE: this could be implemented in a more comp. efficient way directly in C in block_prototypes.py

    y = dy.signal()

    delayed_y = delay( y, initial_state )
    y &lt;&lt; dy.conditional_overwrite( delayed_y, event, u )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.saturate"><code class="name flex">
<span>def <span class="ident">saturate</span></span>(<span>u, lower_limit=None, upper_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Saturation</p>
<p>The output is the saturated input</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lower_limit</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>lower bound for the output</dd>
<dt><strong><code>upper_limit</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>upper bound for the output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the integer output signal</dd>
</dl>
<h2 id="details">Details</h2>
<pre><code>    { lower_limit   for u &lt; lower_limit
y = { u             otherwise
    { upper_limit  for u &gt; upper_limit
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saturate(u, lower_limit = None, upper_limit = None):
    &#34;&#34;&#34;Saturation

    The output is the saturated input

    Parameters
    ----------

    lower_limit : SignalUserTemplate
        lower bound for the output 
    upper_limit : SignalUserTemplate
        upper bound for the output

    Returns
    -------
    SignalUserTemplate
        the integer output signal 

    Details
    -------
            { lower_limit   for u &lt; lower_limit
        y = { u             otherwise
            { upper_limit  for u &gt; upper_limit
    &#34;&#34;&#34;

    y = u

    if lower_limit is not None:
        y = dy.conditional_overwrite( y, y &lt; float64(lower_limit), lower_limit )
    
    if upper_limit is not None:
        y = dy.conditional_overwrite( y, y &gt; float64(upper_limit), upper_limit )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.set_primary_outputs"><code class="name flex">
<span>def <span class="ident">set_primary_outputs</span></span>(<span>output_signals, names=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_primary_outputs(output_signals, names = None):

    if names is not None:
        for i in range(0,len(names)):
            output_signals[i].set_name_raw( names[i] )

    get_system_context().set_primary_outputs( si.unwrap_list( output_signals ) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.show_blocks"><code class="name flex">
<span>def <span class="ident">show_blocks</span></span>(<span>system=None)</span>
</code></dt>
<dd>
<div class="desc"><p>List all blocks in the current or given system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_blocks(system = None):
    &#34;&#34;&#34;
        List all blocks in the current or given system
    &#34;&#34;&#34;

    if system is None:
        system = get_system_context() 

    print()
    print(Style.BRIGHT + &#34;-------- list of blocks --------&#34;)
    print()

    system.ShowBlocks()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.show_execution_lines"><code class="name flex">
<span>def <span class="ident">show_execution_lines</span></span>(<span>compile_results)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_execution_lines(compile_results):

    print()
    print(Style.BRIGHT + &#34;-------- List all execution lines and commands  --------&#34;)
    print()

    compile_results.command_to_execute.print_execution()</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal"><code class="name flex">
<span>def <span class="ident">signal</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new signal for defining a closed-loop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal():
    &#34;&#34;&#34;
        Create a new signal for defining a closed-loop
    &#34;&#34;&#34;

    # return an anonymous signal
    return si.SignalUser(get_system_context())</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_impulse"><code class="name flex">
<span>def <span class="ident">signal_impulse</span></span>(<span>k_event)</span>
</code></dt>
<dd>
<div class="desc"><p>Pulse signal generator</p>
<p>Generates a unique pulse at the sampling index k_event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k_event</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the sampling index at which the pulse appears</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_impulse(k_event):
    &#34;&#34;&#34;Pulse signal generator

    Generates a unique pulse at the sampling index k_event.

    Parameters
    ----------
    k_event : SignalUserTemplate
        the sampling index at which the pulse appears


    Returns
    -------
    SignalUserTemplate
        the output signal
    &#34;&#34;&#34;

    if k_event &lt; 0:
        raise BaseException(&#39;The sampling index for the event is invalid (k_event &lt; 0)&#39;)

    k = dy.counter()
    pulse_signal = dy.int32(k_event) == k

    return pulse_signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_periodic_impulse"><code class="name flex">
<span>def <span class="ident">signal_periodic_impulse</span></span>(<span>period, phase)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for periodic pulses</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>singal or constant describing the period in samples at which the pulses are generated</dd>
<dt><strong><code>phase</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>singal or constant describing the phase in samples at which the pulses are generated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_periodic_impulse(period, phase):
    &#34;&#34;&#34;Signal generator for periodic pulses

    Parameters
    ----------

    period : SignalUserTemplate
        singal or constant describing the period in samples at which the pulses are generated
    phase : SignalUserTemplate
        singal or constant describing the phase in samples at which the pulses are generated

    Returns
    -------
    SignalUserTemplate
        the output signal

    &#34;&#34;&#34;

    k, trigger = counter_triggered( upper_limit=dy.int32(period) - dy.int32(1), reset_on_limit=True )
    pulse_signal = dy.int32(phase) == k

    return pulse_signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_ramp"><code class="name flex">
<span>def <span class="ident">signal_ramp</span></span>(<span>k_start)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for a ramp signal</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k_start</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the sampling index as returned by counter() at which the ramp starts increasing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="details">Details</h2>
<pre><code>y[k] = { 0           for k &lt;  k_start
       { k-k_start   for k &gt;= k_start
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_ramp(k_start):
    &#34;&#34;&#34;Signal generator for a ramp signal

    Parameters
    ----------
    k_start : SignalUserTemplate
        the sampling index as returned by counter() at which the ramp starts increasing.

    Returns
    -------
    SignalUserTemplate
        the output signal

    Details
    -------

        y[k] = { 0           for k &lt;  k_start
               { k-k_start   for k &gt;= k_start
    &#34;&#34;&#34;
    k = dy.counter()
    active = dy.int32(k_start) &lt;= k

    linearRise = dy.convert( (k - dy.int32(k_start) ), dy.DataTypeFloat64(1) )
    activation = dy.convert( active, dy.DataTypeFloat64(1) )

    return activation * linearRise</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_sinus"><code class="name flex">
<span>def <span class="ident">signal_sinus</span></span>(<span>N_period: int = 100, phi=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sine wave generator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N_period</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>period in sampling instants (type: constant integer)</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>phase shift (signal)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="details">Details</h2>
<p>The output is computed as follows:</p>
<p>y = sin( k * (1 / N_period * 2 * pi) + phi )</p>
<p>k - is the sampling index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_sinus(N_period : int = 100, phi = None):
    &#34;&#34;&#34;Sine wave generator

    Parameters
    ----------
    N_period : SignalUserTemplate
        period in sampling instants (type: constant integer)
    phi : SignalUserTemplate
        phase shift (signal)

    Returns
    -------
    SignalUserTemplate
        the output signal

    Details
    -------
    The output is computed as follows:

    y = sin( k * (1 / N_period * 2 * pi) + phi )

    k - is the sampling index

    &#34;&#34;&#34;

    if N_period &lt;= 0:
        raise BaseException(&#39;N_period &lt;= 0&#39;)

    if phi is None:
        phi = dy.float64(0.0)

    i, _ = dy.counter_triggered( upper_limit=N_period-1, reset_on_limit=True )
    y = dy.sin( i * dy.float64(1/N_period * 2*math.pi) + phi )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_square"><code class="name flex">
<span>def <span class="ident">signal_square</span></span>(<span>period, phase)</span>
</code></dt>
<dd>
<div class="desc"><p>Square wave signal generator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>singal or constant describing the period in samples at which the edges of the square are placed</dd>
<dt><strong><code>phase</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>singal or constant describing the phase in samples at which the edges of the square are placed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_square(period, phase):
    &#34;&#34;&#34;Square wave signal generator

    Parameters
    ----------

    period : SignalUserTemplate
        singal or constant describing the period in samples at which the edges of the square are placed
    phase : SignalUserTemplate
        singal or constant describing the phase in samples at which the edges of the square are placed

    Returns
    -------
    SignalUserTemplate
        the output signal

    &#34;&#34;&#34;
    trigger = signal_periodic_impulse(period, phase)


    # k, trigger = counter_triggered( upper_limit=dy.int32(period) - dy.int32(1), reset_on_limit=True )

    state, activate, deactivate = toggle(trigger, no_delay=True)

    return state, activate, deactivate</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_step"><code class="name flex">
<span>def <span class="ident">signal_step</span></span>(<span>k_step)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for a step signal</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k_step</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the sampling index as returned by counter() at which the step appears.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_step(k_step):
    &#34;&#34;&#34;Signal generator for a step signal

    Parameters
    ----------
    k_step : SignalUserTemplate
        the sampling index as returned by counter() at which the step appears.

    Returns
    -------
    SignalUserTemplate
        the output signal
    &#34;&#34;&#34;
    k = dy.counter()
    y = dy.int32(k_step) &lt;= k

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.signal_step_wise_sequence"><code class="name flex">
<span>def <span class="ident">signal_step_wise_sequence</span></span>(<span>time_instance_indices, values, time_scale=None, counter=None, reset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for a step-wise changeing signal</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time_instance_indices</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>an array of sampling instants at which the signal changes its values</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>List[float]</code></dt>
<dd>an array of values; must have one more element than time_instance_indices</dd>
<dt><strong><code>time_scale</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>multiplies all elements of time_instance_indices by the given factor (optional)</dd>
<dt><strong><code>counter</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>an alternative sample counter (optional), default: counter=dy.counter()</dd>
<dt><strong><code>reset</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>boolean signal to reset the sequence (optional)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>time_instance_indices = [      50, 100, 150, 250, 300, 350, 400,  450, 500  ]
values                = [ 0, -1.0,   0, 1.0,  0, -1.0, 0,   0.2, -0.2, 0   ]

v = step_wise_sequence( time_instance_indices, values )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_step_wise_sequence( time_instance_indices, values, time_scale=None, counter=None, reset=None ):
    &#34;&#34;&#34;Signal generator for a step-wise changeing signal

    Parameters
    ----------

    time_instance_indices : List[int]
        an array of sampling instants at which the signal changes its values
    values : List[float]
        an array of values; must have one more element than time_instance_indices
    time_scale : SignalUserTemplate
        multiplies all elements of time_instance_indices by the given factor (optional)
    counter : SignalUserTemplate
        an alternative sample counter (optional), default: counter=dy.counter()
    reset : SignalUserTemplate
        boolean signal to reset the sequence (optional)

    Returns
    -------
    SignalUserTemplate
        the output signal

    Example
    -------

        time_instance_indices = [      50, 100, 150, 250, 300, 350, 400,  450, 500  ]
        values                = [ 0, -1.0,   0, 1.0,  0, -1.0, 0,   0.2, -0.2, 0   ]

        v = step_wise_sequence( time_instance_indices, values )
    &#34;&#34;&#34;
    
    if len(values) - 1 != len(time_instance_indices):
        raise BaseException( &#34;len(values) - 1 != len(time_instance_indices)&#34; )

    if counter is None:
        counter = dy.counter()

    indices_mem = dy.memory(datatype=dy.DataTypeInt32(1),   constant_array=time_instance_indices )
    values_mem  = dy.memory(datatype=dy.DataTypeFloat64(1), constant_array=values )

    current_index = dy.signal()

    current_time_index_to_check = dy.memory_read( indices_mem, current_index )

    # scale time
    if time_scale is not None:
        index_to_check = time_scale * current_time_index_to_check
    else:
        index_to_check = current_time_index_to_check

    # check wether to step to the next sample
    increase_index = dy.int32(0)
    increase_index = dy.conditional_overwrite(increase_index, counter &gt;= index_to_check, dy.int32(1) )

    cnt_, _ = dy.counter_triggered(upper_limit=len(time_instance_indices), stepwidth=increase_index, reset=reset )
    current_index &lt;&lt; cnt_
    val = dy.memory_read(values_mem, current_index)

    return val</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sin"><code class="name flex">
<span>def <span class="ident">sin</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sin(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;sin&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sqrt"><code class="name flex">
<span>def <span class="ident">sqrt</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Square root</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sqrt(u : SignalUserTemplate ):
    &#34;&#34;&#34;
    Square root
    &#34;&#34;&#34;
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;sqrt&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=0, no_delay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulative sum</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>float, <a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the initial state</dd>
<dt><strong><code>no_delay</code></strong> :&ensp;<code>bool</code></dt>
<dd>when true the output is not delayed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<p>The difference equation</p>
<pre><code>y[k+1] = y[k] + u[k]
</code></pre>
<p>is evaluated. The return value is either</p>
<pre><code>y[k]   by default or when no_delay == False
</code></pre>
<p>or</p>
<pre><code>y[k+1] in case no_delay == True .
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(u : SignalUserTemplate, initial_state=0, no_delay=False):
    &#34;&#34;&#34;Accumulative sum

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state
    no_delay : bool
        when true the output is not delayed

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    The difference equation

        y[k+1] = y[k] + u[k]

    is evaluated. The return value is either

        y[k]   by default or when no_delay == False
    or

        y[k+1] in case no_delay == True .
    &#34;&#34;&#34;

    y_k = dy.signal()
    
    y_kp1 = y_k + u

    y_k &lt;&lt; dy.delay(y_kp1, initial_state=initial_state)

    if no_delay:
        return y_kp1
    else:
        return y_k</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sum2"><code class="name flex">
<span>def <span class="ident">sum2</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulative sum</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>float, <a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the initial state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<p>The difference equation</p>
<pre><code>y[k+1] = y[k] + u[k]
</code></pre>
<p>is evaluated. The return values are</p>
<pre><code>y[k], y[k+1]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum2(u : SignalUserTemplate, initial_state=0):
    &#34;&#34;&#34;Accumulative sum

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    The difference equation

        y[k+1] = y[k] + u[k]

    is evaluated. The return values are

        y[k], y[k+1]
    &#34;&#34;&#34;

    y_k = dy.signal()
    
    y_kp1 = y_k + u

    y_k &lt;&lt; dy.delay(y_kp1, initial_state=initial_state)

    return y_k, y_kp1</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.switchNto1"><code class="name flex">
<span>def <span class="ident">switchNto1</span></span>(<span>state: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, inputs: List[<a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>N to one signal switch</p>
<p>returns </p>
<pre><code>inputs[0]  for state == 1
inputs[1]  for state == 2
inputs[2]  for state == 3
   ...
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>state</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the state of the switch</dd>
<dt><strong><code>inputs</code></strong> :&ensp;<code>List[<a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a>]</code></dt>
<dd>the input signals among which to switch</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal of the switch</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def switchNto1( state : SignalUserTemplate, inputs : List[SignalUserTemplate] ):
    &#34;&#34;&#34;N to one signal switch

    returns 

        inputs[0]  for state == 1
        inputs[1]  for state == 2
        inputs[2]  for state == 3
           ...

    Parameters
    ----------
    state : SignalUserTemplate
        the state of the switch  
    inputs : List[SignalUserTemplate]
        the input signals among which to switch

    Returns
    -------
    SignalUserTemplate
        the output signal of the switch
    &#34;&#34;&#34;
    return wrap_signal( SwitchNto1(dy.get_system_context(), state.unwrap, unwrap_list(inputs) ).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.system_input"><code class="name flex">
<span>def <span class="ident">system_input</span></span>(<span>datatype, name: str = None, default_value=None, value_range=None, title: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Introduce a new system input signal</p>
<p>datatype
- the datatype of the signal
name
- the name of the signal
default_value - the default value the will be applied to the system input by default
value_range
- the available numeric range for the signal the form [min, max]<br>
title
- the description of the signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def system_input(datatype, name : str = None, default_value=None, value_range=None, title : str = &#34;&#34;):
    &#34;&#34;&#34;
        Introduce a new system input signal

        datatype      - the datatype of the signal
        name          - the name of the signal
        default_value - the default value the will be applied to the system input by default
        value_range   - the available numeric range for the signal the form [min, max]  
        title         - the description of the signal
    &#34;&#34;&#34;

    signal = si.SimulationInputSignalUser(get_system_context(), datatype)

    if name is not None:
        signal.set_name(name)

    properties = {}

    if default_value is not None:
        properties[&#39;default_value&#39;] = default_value

    if value_range is not None:
        properties[&#39;range&#39;] = value_range

    if title is not None:
        properties[&#39;title&#39;] = title

    signal.set_properties(properties)

    return signal </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.tan"><code class="name flex">
<span>def <span class="ident">tan</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tan(u : SignalUserTemplate ):
    return wrap_signal( StaticFnByName_1To1(dy.get_system_context(), u.unwrap, &#39;tan&#39;).outputs[0] )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.toggle"><code class="name flex">
<span>def <span class="ident">toggle</span></span>(<span>trigger, initial_state=False, no_delay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle a state based on an event</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the signal to trigger a state change</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>int</code></dt>
<dd>the initial state</dd>
<dt><strong><code>no_delay</code></strong> :&ensp;<code>bool</code></dt>
<dd>when true the toggle immediately reacts to a trigger (default: false)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the boolean state signal</dd>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the event for activation</dd>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the event for deactivation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle(trigger, initial_state=False, no_delay=False):
    &#34;&#34;&#34;Toggle a state based on an event

    Parameters
    ----------

    period : SignalUserTemplate
        the signal to trigger a state change
    initial_state : int
        the initial state
    no_delay : bool
        when true the toggle immediately reacts to a trigger (default: false)

    Returns
    -------
    SignalUserTemplate
        the boolean state signal

    SignalUserTemplate
        the event for activation
    SignalUserTemplate
        the event for deactivation

    

    &#34;&#34;&#34;

    state = dy.signal()

    activate   = dy.logic_and( dy.logic_not( state ), trigger )
    deactivate = dy.logic_and( trigger , state)

    state_ = dy.flipflop( activate, deactivate, 
                            initial_state = 0, 
                            no_delay=no_delay )

    if not no_delay:
        state &lt;&lt; state_
    else:
        state &lt;&lt; dy.delay(state_)


    return state_, activate, deactivate</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.transfer_function_discrete"><code class="name flex">
<span>def <span class="ident">transfer_function_discrete</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, num_coeff: List[float], den_coeff: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>Discrete time transfer function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal</dd>
<dt><strong><code>num_coeff</code></strong> :&ensp;<code>List[float]</code></dt>
<dd>a list of numerator coefficients of the transfer function</dd>
<dt><strong><code>den_coeff</code></strong> :&ensp;<code>List[float]</code></dt>
<dd>a list of denominator coefficients of the transfer function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<p>This filter realizes a discrete-time transfer function by using 'direct form II'
c.f. <a href="https://en.wikipedia.org/wiki/Digital_filter">https://en.wikipedia.org/wiki/Digital_filter</a> .</p>
<pre><code>        b0 + b1 z^-1 + b2 z^-2 + ... + bN z^-N
H(z) = ----------------------------------------
        1 + a1 z^-1 + a2 z^-2 + ... + aM z^-M
</code></pre>
<p>The coefficient vectors num_coeff and den_coeff describe the numerator and
denominator polynomials, respectively, and are defined as follows:</p>
<pre><code>num_coeff = [b0, b1, .., bN]
den_coeff = [a1, a2, ... aM] .
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_function_discrete(u : SignalUserTemplate, num_coeff : t.List[float], den_coeff : t.List[float] ):

    &#34;&#34;&#34;Discrete time transfer function

    Parameters
    ----------
    u : SignalUserTemplate
        the input signal
    num_coeff : List[float]
        a list of numerator coefficients of the transfer function
    den_coeff : List[float]
        a list of denominator coefficients of the transfer function

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    This filter realizes a discrete-time transfer function by using &#39;direct form II&#39;
    c.f. https://en.wikipedia.org/wiki/Digital_filter .

                b0 + b1 z^-1 + b2 z^-2 + ... + bN z^-N
        H(z) = ----------------------------------------
                1 + a1 z^-1 + a2 z^-2 + ... + aM z^-M

    The coefficient vectors num_coeff and den_coeff describe the numerator and 
    denominator polynomials, respectively, and are defined as follows:

        num_coeff = [b0, b1, .., bN]
        den_coeff = [a1, a2, ... aM] .
        
    &#34;&#34;&#34;


    # get filter order
    N = len(num_coeff)-1

    # feedback start signal
    z_pre = dy.signal()

    # array to store state signals
    z_ = []

    # create delay chain
    z_iterate = z_pre
    for i in range(0,N):

        z_iterate = dy.delay( z_iterate ) .extend_name(&#39;_z&#39; + str(i) )
        z_.append( z_iterate ) 


    # build feedback path
    #
    # a1 = den_coeff[0]
    # a2 = den_coeff[1]
    # a3 = den_coeff[2]
    #        ...
    sum_feedback = u
    for i in range(0,N):

        a_ip1 = dy.float64( den_coeff[i] ).extend_name(&#39;_a&#39; + str(i+1) )

        sum_feedback = sum_feedback - a_ip1 * z_[i]

    sum_feedback.extend_name(&#39;_i&#39;)


    # close the feedback loop
    z_pre &lt;&lt; sum_feedback

    # build output path
    #
    # b0 = num_coeff[0]
    # b1 = num_coeff[1]
    # b2 = num_coeff[2]
    #        ...    
    for i in range(0,N+1):
        
        b_i = dy.float64( num_coeff[i] ).extend_name(&#39;_b&#39; + str(i) )

        if i==0:
            y = b_i * sum_feedback
        else:
            y = y + b_i * z_[i-1]

    # y is the filter output   
    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.unwrap_angle"><code class="name flex">
<span>def <span class="ident">unwrap_angle</span></span>(<span>angle, normalize_around_zero=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unwrap an angle</p>
<p>Unwrap and normalize the input angle to the range </p>
<pre><code>   [0, 2*pi[     in case normalize_around_zero == false
or [-pi, pi]     in case normalize_around_zero == true
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the input signal (angle in radians)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_angle(angle, normalize_around_zero = False):
    &#34;&#34;&#34;Unwrap an angle

    Unwrap and normalize the input angle to the range 

           [0, 2*pi[     in case normalize_around_zero == false
        or [-pi, pi]     in case normalize_around_zero == true


    Parameters
    ----------

    angle : SignalUserTemplate
        the input signal (angle in radians)

    Returns
    -------
    SignalUserTemplate
        the output signal   

    &#34;&#34;&#34;

    def normalize_around_zero(angle):
        &#34;&#34;&#34;
            Normalize an angle

            Normalize an angle to a range [-pi, pi]

            Important: the assumed range for the input is - 2*pi &lt;= angle &lt;= 2*p
        &#34;&#34;&#34;

        tmp = angle            + dy.conditional_overwrite( dy.float64(0), angle &lt;= float64(-math.pi), 2*math.pi )
        normalized_angle = tmp + dy.conditional_overwrite( dy.float64(0), angle &gt; float64(math.pi), -2*math.pi )

        return normalized_angle

    #
    #
    angle_ = dy.fmod(angle, dy.float64(2*math.pi) )

    unwrapped_angle = angle_ + dy.conditional_overwrite( dy.float64(0), angle_ &lt; float64(0), 2*math.pi )

    if normalize_around_zero:
        return normalize_around_zero(unwrapped_angle)
    else:
        return unwrapped_angle</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="openrtdynamics2.lang.DataTypeArray"><code class="flex name class">
<span>class <span class="ident">DataTypeArray</span></span>
<span>(</span><span>length: int, datatype: <a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeArray(DataType):

    def __init__(self, length : int, datatype : DataType ):
        DataType.__init__(self, type_id=None, size=1)

        self._array_element_datatype = datatype
        self._length    = length

    @property
    def cpp_datatype_string(self):
        return self._array_element_datatype.cpp_datatype_string + &#39; [&#39; + str(self._length) + &#39;]&#39;
    
    @property
    def datatype_of_elements(self):
        return self._array_element_datatype

    def cpp_define_variable(self, variable_name, make_a_reference = False):

        if make_a_reference:
            variable_name_ = &#39; (&amp;&#39; + variable_name + &#39;)&#39;
        else:
            variable_name_ = variable_name

        return self._array_element_datatype.cpp_datatype_string + &#39; &#39; + variable_name_ + &#39;[&#39; + str(self._length) + &#39;]&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeArray.cpp_datatype_string"><code class="name">var <span class="ident">cpp_datatype_string</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_datatype_string(self):
    return self._array_element_datatype.cpp_datatype_string + &#39; [&#39; + str(self._length) + &#39;]&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeArray.datatype_of_elements"><code class="name">var <span class="ident">datatype_of_elements</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def datatype_of_elements(self):
    return self._array_element_datatype</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeArray.cpp_define_variable"><code class="name flex">
<span>def <span class="ident">cpp_define_variable</span></span>(<span>self, variable_name, make_a_reference=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cpp_define_variable(self, variable_name, make_a_reference = False):

    if make_a_reference:
        variable_name_ = &#39; (&amp;&#39; + variable_name + &#39;)&#39;
    else:
        variable_name_ = variable_name

    return self._array_element_datatype.cpp_datatype_string + &#39; &#39; + variable_name_ + &#39;[&#39; + str(self._length) + &#39;]&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.DataTypeBoolean"><code class="flex name class">
<span>class <span class="ident">DataTypeBoolean</span></span>
<span>(</span><span>size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeBoolean(DataType):

    def __init__(self, size : int):
        DataType.__init__(self, type_id=ORTD_DATATYPE_BOOLEAN, size=size)

    @property
    def cpp_datatype_string(self):
        return &#39;bool&#39;

    @property
    def cpp_printf_pattern(self):
        return &#39;%d&#39;

    @property
    def cpp_zero_element(self):
        return &#39;false&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeBoolean.cpp_datatype_string"><code class="name">var <span class="ident">cpp_datatype_string</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_datatype_string(self):
    return &#39;bool&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeBoolean.cpp_printf_pattern"><code class="name">var <span class="ident">cpp_printf_pattern</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_printf_pattern(self):
    return &#39;%d&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeBoolean.cpp_zero_element"><code class="name">var <span class="ident">cpp_zero_element</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_zero_element(self):
    return &#39;false&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.DataTypeFloat64"><code class="flex name class">
<span>class <span class="ident">DataTypeFloat64</span></span>
<span>(</span><span>size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeFloat64(DataTypeNumeric):

    def __init__(self, size : int):
        DataType.__init__(self, type_id=ORTD_DATATYPE_FLOAT, size=size)

    @property
    def cpp_datatype_string(self):
        return &#39;double&#39;

    @property
    def cpp_printf_pattern(self):
        return &#39;%f&#39;

    @property
    def cpp_zero_element(self):
        return &#39;0.0&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeNumeric" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeNumeric">DataTypeNumeric</a></li>
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeFloat64.cpp_datatype_string"><code class="name">var <span class="ident">cpp_datatype_string</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_datatype_string(self):
    return &#39;double&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeFloat64.cpp_printf_pattern"><code class="name">var <span class="ident">cpp_printf_pattern</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_printf_pattern(self):
    return &#39;%f&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeFloat64.cpp_zero_element"><code class="name">var <span class="ident">cpp_zero_element</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_zero_element(self):
    return &#39;0.0&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.DataTypeInt32"><code class="flex name class">
<span>class <span class="ident">DataTypeInt32</span></span>
<span>(</span><span>size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeInt32(DataTypeNumeric):

    def __init__(self, size : int):

        DataType.__init__(self, type_id=ORTD_DATATYPE_INT32, size=size)

    @property
    def cpp_datatype_string(self):
        return &#39;int32_t&#39;

    @property
    def cpp_printf_pattern(self):
        return &#39;%d&#39;

    @property
    def cpp_zero_element(self):
        return &#39;0&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeNumeric" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeNumeric">DataTypeNumeric</a></li>
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypeInt32.cpp_datatype_string"><code class="name">var <span class="ident">cpp_datatype_string</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_datatype_string(self):
    return &#39;int32_t&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeInt32.cpp_printf_pattern"><code class="name">var <span class="ident">cpp_printf_pattern</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_printf_pattern(self):
    return &#39;%d&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypeInt32.cpp_zero_element"><code class="name">var <span class="ident">cpp_zero_element</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_zero_element(self):
    return &#39;0&#39;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.DataTypeNumeric"><code class="flex name class">
<span>class <span class="ident">DataTypeNumeric</span></span>
<span>(</span><span>size: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypeNumeric(DataType):
    def __init__(self, size : int):
        DataType.__init__(self, type_id=ORTD_DATATYPE_FLOAT, size=size)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeFloat64" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeFloat64">DataTypeFloat64</a></li>
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeInt32" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataTypeInt32">DataTypeInt32</a></li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.DataTypePointer"><code class="flex name class">
<span>class <span class="ident">DataTypePointer</span></span>
<span>(</span><span>cpp_type_name_class: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a pointer pointing to an instance of a given class</p>
<h2 id="example">Example:</h2>
<pre><code>cpp_type_name_class = 'SomeClass'
</code></pre>
<p>In the source code of the class, the following definition is required</p>
<pre><code>typedef SomeClass *SomeClassPtr
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataTypePointer(DataType):
    &#34;&#34;&#34;
    Create a pointer pointing to an instance of a given class

    Example:
    --------

        cpp_type_name_class = &#39;SomeClass&#39; 

    In the source code of the class, the following definition is required

        typedef SomeClass *SomeClassPtr

    &#34;&#34;&#34;

    def __init__(self, cpp_type_name_class : str ):
        DataType.__init__(self, type_id=None, size=1)

        self._cpp_ptr_type_name   = cpp_type_name_class + &#39;Ptr&#39; # cpp_ptr_type_name
        self._cpp_type_name_class = cpp_type_name_class

    @property
    def cpp_datatype_string(self):
        &#34;&#34;&#34;
        return the c++ datatype string of the pointer to the class instance 
        &#34;&#34;&#34;
        return self._cpp_ptr_type_name

    @property
    def cpp_datatype_string_class(self):
        &#34;&#34;&#34;
        return the c++ datatype string of the class
        &#34;&#34;&#34;
        return self._cpp_type_name_class

    def is_equal_to(self, other_type):

        result = DataType.is_equal_to(self, other_type)

        if result == 1:
            if self._cpp_ptr_type_name == other_type._cpp_ptr_type_name:
                return 1
        else:
            return result</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypePointer.cpp_datatype_string"><code class="name">var <span class="ident">cpp_datatype_string</span></code></dt>
<dd>
<div class="desc"><p>return the c++ datatype string of the pointer to the class instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_datatype_string(self):
    &#34;&#34;&#34;
    return the c++ datatype string of the pointer to the class instance 
    &#34;&#34;&#34;
    return self._cpp_ptr_type_name</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.DataTypePointer.cpp_datatype_string_class"><code class="name">var <span class="ident">cpp_datatype_string_class</span></code></dt>
<dd>
<div class="desc"><p>return the c++ datatype string of the class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def cpp_datatype_string_class(self):
    &#34;&#34;&#34;
    return the c++ datatype string of the class
    &#34;&#34;&#34;
    return self._cpp_type_name_class</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.DataTypePointer.is_equal_to"><code class="name flex">
<span>def <span class="ident">is_equal_to</span></span>(<span>self, other_type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_equal_to(self, other_type):

    result = DataType.is_equal_to(self, other_type)

    if result == 1:
        if self._cpp_ptr_type_name == other_type._cpp_ptr_type_name:
            return 1
    else:
        return result</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate"><code class="flex name class">
<span>class <span class="ident">SignalUserTemplate</span></span>
<span>(</span><span>system, wrapped_signal: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SignalUserTemplate(object):
    def __init__(self, system, wrapped_signal : Signal):

        self._system = system
        self._wrapped_signal = wrapped_signal

    def __hash__(self):
        return id(self)

    @property
    def unwrap(self):
        &#34;&#34;&#34;
        Get the library-internal representation of a signal (internal use only)
        &#34;&#34;&#34;
        return self._wrapped_signal

    @property
    def name(self):
        &#34;&#34;&#34;
        the identifier of the signal
        &#34;&#34;&#34;
        return self._wrapped_signal.name

    @property
    def properties(self):
        &#34;&#34;&#34;
        A hash array of properties
        &#34;&#34;&#34;
        return self._wrapped_signal.properties

    def set_properties(self, p):
        &#34;&#34;&#34;
        Set the properties of the signal
        &#34;&#34;&#34;
        self._wrapped_signal.set_properties(p)
        return self

    def set_datatype(self, datatype):
        # call setDatatype_nonotitication to prevent the (untested) automatic update of the datatypes
        self._wrapped_signal.setDatatype_nonotitication(datatype)
        return self

    def set_name(self, name):
        &#34;&#34;&#34;
        Set the signals identifier. Must be a string without spaces and alphanumerical characters only. 
        &#34;&#34;&#34;
        self._wrapped_signal.set_name(name)
        return self

    def set_name_raw(self, name):
        self._wrapped_signal.set_name_raw(name)
        return self


    def extend_name(self, name):
        &#34;&#34;&#34;
        Extand the current signal identifier by appending characters at the end of the string
        &#34;&#34;&#34;
        self._wrapped_signal.set_name( self._wrapped_signal.name + name )
        return self

    def set_blockname(self, name):
        &#34;&#34;&#34;
        Set the name of the block that has the signal as one of its outputs
        &#34;&#34;&#34;
        self._wrapped_signal.set_blockname(name)
        return self

    # ...

    #
    # operator overloads
    #

    def __add__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;+&#39;).outputs[0] )

    def __radd__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;+&#39;).outputs[0] )


    def __sub__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;-&#39;).outputs[0] )

    def __rsub__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ other.unwrap, self.unwrap ], operator=&#39;-&#39;).outputs[0] )


    def __mul__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;*&#39;).outputs[0] )

    def __rmul__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;*&#39;).outputs[0] )


    def __truediv__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ self.unwrap, other.unwrap ], operator=&#39;/&#39;).outputs[0] )

    def __rtruediv__(self, other): 
        other = convert_python_constant_val_to_const_signal(other)
        return wrap_signal( block_prototypes.Operator1( dy.get_system_context(), inputSignals=[ other.unwrap, self.unwrap ], operator=&#39;/&#39;).outputs[0] )



    # _comparison operators
    def __le__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;&lt;=&#39; ) )

    def __rle__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = other, right = self, operator = &#39;&lt;=&#39; ) )



    def __ge__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;&gt;=&#39; ) )

    def __rge__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = other, right = self, operator = &#39;&gt;=&#39; ) )



    def __lt__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;&lt;&#39; ) )

    def __rlt__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = other, right = self, operator = &#39;&lt;&#39; ) )



    def __gt__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;&gt;&#39; ) )

    def __rgt__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = other, right = self, operator = &#39;&gt;&#39; ) )



    def __eq__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;==&#39; ) )

    def __req__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;==&#39; ) )

    def __ne__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;!=&#39; ) )

    def __rne__(self, other):
        other = convert_python_constant_val_to_const_signal(other)
        return ( _comparison(left = self, right = other, operator = &#39;!=&#39; ) )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.signal_interface.BlockOutputSignalUser" href="signal_interface.html#openrtdynamics2.lang.signal_interface.BlockOutputSignalUser">BlockOutputSignalUser</a></li>
<li><a title="openrtdynamics2.lang.signal_interface.SignalUser" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUser">SignalUser</a></li>
<li><a title="openrtdynamics2.lang.signal_interface.SimulationInputSignalUser" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SimulationInputSignalUser">SimulationInputSignalUser</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.SignalUserTemplate.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>the identifier of the signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;
    the identifier of the signal
    &#34;&#34;&#34;
    return self._wrapped_signal.name</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.properties"><code class="name">var <span class="ident">properties</span></code></dt>
<dd>
<div class="desc"><p>A hash array of properties</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def properties(self):
    &#34;&#34;&#34;
    A hash array of properties
    &#34;&#34;&#34;
    return self._wrapped_signal.properties</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.unwrap"><code class="name">var <span class="ident">unwrap</span></code></dt>
<dd>
<div class="desc"><p>Get the library-internal representation of a signal (internal use only)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unwrap(self):
    &#34;&#34;&#34;
    Get the library-internal representation of a signal (internal use only)
    &#34;&#34;&#34;
    return self._wrapped_signal</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.SignalUserTemplate.extend_name"><code class="name flex">
<span>def <span class="ident">extend_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Extand the current signal identifier by appending characters at the end of the string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extend_name(self, name):
    &#34;&#34;&#34;
    Extand the current signal identifier by appending characters at the end of the string
    &#34;&#34;&#34;
    self._wrapped_signal.set_name( self._wrapped_signal.name + name )
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_blockname"><code class="name flex">
<span>def <span class="ident">set_blockname</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the name of the block that has the signal as one of its outputs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_blockname(self, name):
    &#34;&#34;&#34;
    Set the name of the block that has the signal as one of its outputs
    &#34;&#34;&#34;
    self._wrapped_signal.set_blockname(name)
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_datatype"><code class="name flex">
<span>def <span class="ident">set_datatype</span></span>(<span>self, datatype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_datatype(self, datatype):
    # call setDatatype_nonotitication to prevent the (untested) automatic update of the datatypes
    self._wrapped_signal.setDatatype_nonotitication(datatype)
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_name"><code class="name flex">
<span>def <span class="ident">set_name</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the signals identifier. Must be a string without spaces and alphanumerical characters only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name(self, name):
    &#34;&#34;&#34;
    Set the signals identifier. Must be a string without spaces and alphanumerical characters only. 
    &#34;&#34;&#34;
    self._wrapped_signal.set_name(name)
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_name_raw"><code class="name flex">
<span>def <span class="ident">set_name_raw</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_name_raw(self, name):
    self._wrapped_signal.set_name_raw(name)
    return self</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.SignalUserTemplate.set_properties"><code class="name flex">
<span>def <span class="ident">set_properties</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the properties of the signal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_properties(self, p):
    &#34;&#34;&#34;
    Set the properties of the signal
    &#34;&#34;&#34;
    self._wrapped_signal.set_properties(p)
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.TargetBasicExecutable"><code class="flex name class">
<span>class <span class="ident">TargetBasicExecutable</span></span>
<span>(</span><span>i_max: int, input_signals_mapping={})</span>
</code></dt>
<dd>
<div class="desc"><p>generates code for the runtime environment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TargetBasicExecutable(TargetGenericCpp):
    &#34;&#34;&#34;
        generates code for the runtime environment
    &#34;&#34;&#34;

    def __init__(self, i_max : int, input_signals_mapping = {} ):

        self._i_max = i_max

        TargetGenericCpp.__init__(self)

        self.input_signals_mapping = input_signals_mapping
        self.initCodeTemplate()

        
    def code_gen(self):

        # call helper to fill in some generic elements into the template
        code_gen_results = TargetGenericCpp.code_gen(self)

        #
        # make strings 
        # 

        # constant inputs
        inputConstAssignments = []
        for signal, value in self.input_signals_mapping.items():
            inputConstAssignments.append( signal.name + &#39; = &#39; + str(value) )

        inputConstAssignment = &#39;; &#39;.join( inputConstAssignments ) + &#39;;&#39;

        self.sourceCode = Template(self.template).safe_substitute( iMax=self._i_max,
                                                                 inputConstAssignment=inputConstAssignment    ) 

        code_gen_results[&#39;sourcecode&#39;] = self.sourceCode
        return code_gen_results

    def write_code(self, folder):
        TargetGenericCpp.writeFiles(self, folder)

        self.codeFolder = folder

        f = open(os.path.join( folder + &#34;main.cpp&#34;), &#34;w&#34;)
        f.write( self.sourceCode )
        f.close()


    def build(self):
        os.system(&#34;c++ &#34; + self.codeFolder + &#34;main.cpp -o &#34; + self.codeFolder + &#34;main&#34;)


    def run(self):
        # run the generated executable
        p = subprocess.Popen(self.codeFolder + &#39;main&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        retval = p.wait()

        # parse csv data
        data = [ ]
        outputs = range(0, len(self.main_command.command_to_put_main_system.outputCommand.outputSignals) )

        for o in outputs:
            data.append( [] )

        for line in p.stdout.readlines():
            sample = line.decode(&#34;utf-8&#34;).split(&#39; &#39;)

            for o in outputs:
                data[ o ].append( float( sample[o] ) )

        # put data into a key-array
        dataStruct = { }
        o = 0
        for s in self.main_command.command_to_put_main_system.outputCommand.outputSignals:
            dataStruct[ s.name ] = data[o]

            o = o + 1

        return dataStruct


    def initCodeTemplate(self):

        #
        # template for main function in c++
        #

        self.template = &#34;&#34;&#34;
            
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

//
// implementation of $mainSimulationName
//

$algorithmCode

//
// main
//

int main () {

    // create an instance of the simulation
    $mainSimulationName simulation;

    // input signals
    $inputAll_NamesVarDef

    // output signals
    $outputNamesVarDef

    // const assignments of the input signals
    $inputConstAssignment

    // reset the simulation
    simulation.resetStates();

    // simulate
    int i;

    for (i=0; i&lt; $iMax; ++i) {
        simulation.calcResults_1( $calcOutputsArgs );
        simulation.updateStates(  $input2_NamesCSVList );

        printf(&#34;$outputPrinfPattern\\n&#34;, $outputNamesCSVList);
    }

}

            
        &#34;&#34;&#34;        </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.code_generation_templates.TargetGenericCpp" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetGenericCpp">TargetGenericCpp</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.TargetBasicExecutable.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self):
    os.system(&#34;c++ &#34; + self.codeFolder + &#34;main.cpp -o &#34; + self.codeFolder + &#34;main&#34;)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetBasicExecutable.code_gen"><code class="name flex">
<span>def <span class="ident">code_gen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_gen(self):

    # call helper to fill in some generic elements into the template
    code_gen_results = TargetGenericCpp.code_gen(self)

    #
    # make strings 
    # 

    # constant inputs
    inputConstAssignments = []
    for signal, value in self.input_signals_mapping.items():
        inputConstAssignments.append( signal.name + &#39; = &#39; + str(value) )

    inputConstAssignment = &#39;; &#39;.join( inputConstAssignments ) + &#39;;&#39;

    self.sourceCode = Template(self.template).safe_substitute( iMax=self._i_max,
                                                             inputConstAssignment=inputConstAssignment    ) 

    code_gen_results[&#39;sourcecode&#39;] = self.sourceCode
    return code_gen_results</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetBasicExecutable.initCodeTemplate"><code class="name flex">
<span>def <span class="ident">initCodeTemplate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def initCodeTemplate(self):

        #
        # template for main function in c++
        #

        self.template = &#34;&#34;&#34;
            
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;

//
// implementation of $mainSimulationName
//

$algorithmCode

//
// main
//

int main () {

    // create an instance of the simulation
    $mainSimulationName simulation;

    // input signals
    $inputAll_NamesVarDef

    // output signals
    $outputNamesVarDef

    // const assignments of the input signals
    $inputConstAssignment

    // reset the simulation
    simulation.resetStates();

    // simulate
    int i;

    for (i=0; i&lt; $iMax; ++i) {
        simulation.calcResults_1( $calcOutputsArgs );
        simulation.updateStates(  $input2_NamesCSVList );

        printf(&#34;$outputPrinfPattern\\n&#34;, $outputNamesCSVList);
    }

}

            
        &#34;&#34;&#34;        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetBasicExecutable.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    # run the generated executable
    p = subprocess.Popen(self.codeFolder + &#39;main&#39;, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    retval = p.wait()

    # parse csv data
    data = [ ]
    outputs = range(0, len(self.main_command.command_to_put_main_system.outputCommand.outputSignals) )

    for o in outputs:
        data.append( [] )

    for line in p.stdout.readlines():
        sample = line.decode(&#34;utf-8&#34;).split(&#39; &#39;)

        for o in outputs:
            data[ o ].append( float( sample[o] ) )

    # put data into a key-array
    dataStruct = { }
    o = 0
    for s in self.main_command.command_to_put_main_system.outputCommand.outputSignals:
        dataStruct[ s.name ] = data[o]

        o = o + 1

    return dataStruct</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetBasicExecutable.write_code"><code class="name flex">
<span>def <span class="ident">write_code</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_code(self, folder):
    TargetGenericCpp.writeFiles(self, folder)

    self.codeFolder = folder

    f = open(os.path.join( folder + &#34;main.cpp&#34;), &#34;w&#34;)
    f.write( self.sourceCode )
    f.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.code_generation_templates.TargetGenericCpp" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetGenericCpp">TargetGenericCpp</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.code_generation_templates.TargetGenericCpp.get_algorithm_code" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetGenericCpp.get_algorithm_code">get_algorithm_code</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.TargetGenericCpp"><code class="flex name class">
<span>class <span class="ident">TargetGenericCpp</span></span>
<span>(</span><span>enable_tracing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generates code for the runtime environment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TargetGenericCpp:
    &#34;&#34;&#34;
        generates code for the runtime environment
    &#34;&#34;&#34;

    def __init__(self, enable_tracing=False ):
        ExecutionCommand.__init__(self)  # TODO: what is this?

        # if compile_results is not None:
        #     self.compileResults = compile_results
        #     self.main_command = compile_results.command_to_execute

        # else:

        # those are set via set_compile_results after a system is compiled
        self.compileResults = None
        self.main_command = None
        self._include_code_list = None

        #
        self._algorithm_code = None

        # list of systems to include
        self._includedSystems = []

        self._enable_tracing = enable_tracing

    def set_compile_results(self, compile_results : CompileResults ):
        self.compileResults = compile_results
        self.main_command = compile_results.command_to_execute

    def include_systems(self, system : SystemLibraryEntry):
        self._includedSystems = system

    def add_code_to_include(self, include_code_list : List[str] = []):
        self._include_code_list = include_code_list

    def get_algorithm_code(self):
        &#34;&#34;&#34;
            Return only the code that implement the system and all sub systems
        &#34;&#34;&#34;
        return self._algorithm_code



    def code_gen(self):

        # generate code for the algorithm
        self.manifest, self._algorithm_code = _generate_algorithm_code(
            self.compileResults, 
            self._enable_tracing, 
            self._includedSystems, 
            self._include_code_list
        )

        
        # TODO: iterate over all functions present in the API of the system
        # NOTE: Currently only the main functions are used: output, update, and reset
        #
        API_functions = self.main_command.command_to_put_main_system.API_functions

        #
        # make strings 
        # 

        def makeStrings(signals):
            names_CSV_list = cgh.signal_list_to_names_string(signals)
            names_var_def = cgh.define_variable_list_string(signals)
            printf_pattern = cgh.signalListHelper_printfPattern_string(signals)

            return names_CSV_list, names_var_def, printf_pattern


        # for the output signals
        # input1_NamesCSVList; list of output signals. e.g. &#39;y1, y2, y3&#39; 
        outputNamesCSVList, outputNamesVarDef, outputPrinfPattern = makeStrings( self.main_command.command_to_put_main_system.outputCommand.outputSignals )

        # the inputs to the output command
        # input1_NamesCSVList: list of output signals. e.g. &#39;y1, y2, y3&#39; 
        input1_NamesCSVList, input1_NamesVarDef, input1PrinfPattern = makeStrings( self.main_command.command_to_put_main_system.outputCommand.inputSignals )

        # the inputs to the update command
        # input2_NamesCSVList list of output signals. e.g. &#39;u1, u2, u3&#39; 
        input2_NamesCSVList, input2_NamesVarDef, input2_PrinfPattern = makeStrings( self.main_command.command_to_put_main_system.updateCommand.inputSignals )

        # all inputs
        # merge the list of inputs for the calcoutput and stateupdate function
        allInputs = list(set(self.main_command.command_to_put_main_system.outputCommand.inputSignals + self.main_command.command_to_put_main_system.updateCommand.inputSignals))
        inputAll_NamesCSVList, inputAll_NamesVarDef, inputAll_PrinfPattern = makeStrings( allInputs )

        # the names of input and output signals of the outputCommand combined
        calcOutputsArgs = cgh.signal_list_to_name_list( self.main_command.command_to_put_main_system.outputCommand.outputSignals + self.main_command.command_to_put_main_system.outputCommand.inputSignals )

        # fill in template
        self.template = Template(self.template).safe_substitute(  
                                                    mainSimulationName = self.main_command.command_to_put_main_system.API_name,
                                                    algorithmCode=self._algorithm_code,

                                                    input1_NamesVarDef=input1_NamesVarDef,
                                                    input1_NamesCSVList=input1_NamesCSVList,

                                                    input2_NamesVarDef=input2_NamesVarDef,
                                                    input2_NamesCSVList=input2_NamesCSVList,

                                                    inputAll_NamesVarDef=inputAll_NamesVarDef,
                                                    inputAll_NamesCSVList=inputAll_NamesCSVList,

                                                    outputNamesCSVList=outputNamesCSVList, 
                                                    outputNamesVarDef=outputNamesVarDef,
                                                    outputPrinfPattern=outputPrinfPattern,
                                                    
                                                    calcOutputsArgs=calcOutputsArgs )


        return {&#39;sourcecode&#39; : self.template, &#39;manifest&#39; : self.manifest, &#39;algorithm_sourcecode&#39; : self._algorithm_code }

    def writeFiles(self, folder):

        with open( os.path.join( folder + &#39;//simulation_manifest.json&#39; ), &#39;w&#39;) as outfile:  
            json.dump(self.manifest, outfile)

    def build(self):
        pass

    def run(self):
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.code_generation_templates.TargetBasicExecutable" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetBasicExecutable">TargetBasicExecutable</a></li>
<li><a title="openrtdynamics2.lang.code_generation_templates.TargetWasm" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetWasm">TargetWasm</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.TargetGenericCpp.add_code_to_include"><code class="name flex">
<span>def <span class="ident">add_code_to_include</span></span>(<span>self, include_code_list: List[str] = [])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_code_to_include(self, include_code_list : List[str] = []):
    self._include_code_list = include_code_list</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetGenericCpp.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self):
    pass</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetGenericCpp.code_gen"><code class="name flex">
<span>def <span class="ident">code_gen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_gen(self):

    # generate code for the algorithm
    self.manifest, self._algorithm_code = _generate_algorithm_code(
        self.compileResults, 
        self._enable_tracing, 
        self._includedSystems, 
        self._include_code_list
    )

    
    # TODO: iterate over all functions present in the API of the system
    # NOTE: Currently only the main functions are used: output, update, and reset
    #
    API_functions = self.main_command.command_to_put_main_system.API_functions

    #
    # make strings 
    # 

    def makeStrings(signals):
        names_CSV_list = cgh.signal_list_to_names_string(signals)
        names_var_def = cgh.define_variable_list_string(signals)
        printf_pattern = cgh.signalListHelper_printfPattern_string(signals)

        return names_CSV_list, names_var_def, printf_pattern


    # for the output signals
    # input1_NamesCSVList; list of output signals. e.g. &#39;y1, y2, y3&#39; 
    outputNamesCSVList, outputNamesVarDef, outputPrinfPattern = makeStrings( self.main_command.command_to_put_main_system.outputCommand.outputSignals )

    # the inputs to the output command
    # input1_NamesCSVList: list of output signals. e.g. &#39;y1, y2, y3&#39; 
    input1_NamesCSVList, input1_NamesVarDef, input1PrinfPattern = makeStrings( self.main_command.command_to_put_main_system.outputCommand.inputSignals )

    # the inputs to the update command
    # input2_NamesCSVList list of output signals. e.g. &#39;u1, u2, u3&#39; 
    input2_NamesCSVList, input2_NamesVarDef, input2_PrinfPattern = makeStrings( self.main_command.command_to_put_main_system.updateCommand.inputSignals )

    # all inputs
    # merge the list of inputs for the calcoutput and stateupdate function
    allInputs = list(set(self.main_command.command_to_put_main_system.outputCommand.inputSignals + self.main_command.command_to_put_main_system.updateCommand.inputSignals))
    inputAll_NamesCSVList, inputAll_NamesVarDef, inputAll_PrinfPattern = makeStrings( allInputs )

    # the names of input and output signals of the outputCommand combined
    calcOutputsArgs = cgh.signal_list_to_name_list( self.main_command.command_to_put_main_system.outputCommand.outputSignals + self.main_command.command_to_put_main_system.outputCommand.inputSignals )

    # fill in template
    self.template = Template(self.template).safe_substitute(  
                                                mainSimulationName = self.main_command.command_to_put_main_system.API_name,
                                                algorithmCode=self._algorithm_code,

                                                input1_NamesVarDef=input1_NamesVarDef,
                                                input1_NamesCSVList=input1_NamesCSVList,

                                                input2_NamesVarDef=input2_NamesVarDef,
                                                input2_NamesCSVList=input2_NamesCSVList,

                                                inputAll_NamesVarDef=inputAll_NamesVarDef,
                                                inputAll_NamesCSVList=inputAll_NamesCSVList,

                                                outputNamesCSVList=outputNamesCSVList, 
                                                outputNamesVarDef=outputNamesVarDef,
                                                outputPrinfPattern=outputPrinfPattern,
                                                
                                                calcOutputsArgs=calcOutputsArgs )


    return {&#39;sourcecode&#39; : self.template, &#39;manifest&#39; : self.manifest, &#39;algorithm_sourcecode&#39; : self._algorithm_code }</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetGenericCpp.get_algorithm_code"><code class="name flex">
<span>def <span class="ident">get_algorithm_code</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return only the code that implement the system and all sub systems</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_algorithm_code(self):
    &#34;&#34;&#34;
        Return only the code that implement the system and all sub systems
    &#34;&#34;&#34;
    return self._algorithm_code</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetGenericCpp.include_systems"><code class="name flex">
<span>def <span class="ident">include_systems</span></span>(<span>self, system: <a title="openrtdynamics2.lang.libraries.SystemLibraryEntry" href="libraries.html#openrtdynamics2.lang.libraries.SystemLibraryEntry">SystemLibraryEntry</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def include_systems(self, system : SystemLibraryEntry):
    self._includedSystems = system</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetGenericCpp.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self):
    pass</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetGenericCpp.set_compile_results"><code class="name flex">
<span>def <span class="ident">set_compile_results</span></span>(<span>self, compile_results: <a title="openrtdynamics2.lang.diagram_core.diagram_compiler.CompileResults" href="diagram_core/diagram_compiler.html#openrtdynamics2.lang.diagram_core.diagram_compiler.CompileResults">CompileResults</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_compile_results(self, compile_results : CompileResults ):
    self.compileResults = compile_results
    self.main_command = compile_results.command_to_execute</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetGenericCpp.writeFiles"><code class="name flex">
<span>def <span class="ident">writeFiles</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeFiles(self, folder):

    with open( os.path.join( folder + &#39;//simulation_manifest.json&#39; ), &#39;w&#39;) as outfile:  
        json.dump(self.manifest, outfile)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.TargetWasm"><code class="flex name class">
<span>class <span class="ident">TargetWasm</span></span>
<span>(</span><span>enable_tracing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generates code for the Webassemble runtime environment</p>
<p><a href="https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html">https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TargetWasm(TargetGenericCpp):
    &#34;&#34;&#34;
        generates code for the Webassemble runtime environment

        https://emscripten.org/docs/porting/connecting_cpp_and_javascript/embind.html

    &#34;&#34;&#34;

    def __init__(self, enable_tracing = False ):

        TargetGenericCpp.__init__(self, enable_tracing=enable_tracing)

        self.initCodeTemplate()

        
    def code_gen(self):

        # build I/O structs
        ioExport = self.generate_code_writeIO(self.main_command.command_to_put_main_system.outputCommand)
        ioExport += self.generate_code_writeIO(self.main_command.command_to_put_main_system.updateCommand)

        ioExport += self.generate_code_writeIO(self.main_command.command_to_put_main_system.resetCommand)

        self.template = Template(self.template).safe_substitute( ioExport=ioExport,
                                                                 inputConstAssignment=&#39;&#39;    ) 

        # call helper to fill in some generic elements into the template
        code_gen_results = TargetGenericCpp.code_gen(self)

        self.sourceCode = self.template

        code_gen_results[&#39;sourcecode&#39;] = self.sourceCode
        return code_gen_results



    def generate_code_writeIO__(self, command_API, inputOutput : int):

        if inputOutput == 1:
            structPrefix = &#39;Inputs_&#39;
            signals = command_API.inputSignals

        elif inputOutput == 2:
            structPrefix = &#39;Outputs_&#39;
            signals = command_API.outputSignals

        mainSimulationName = self.main_command.command_to_put_main_system.API_name

        lines = &#39;&#39;

        # Inputs
        structname = structPrefix + command_API.API_name 

        lines += &#39;value_object&lt;&#39; + mainSimulationName + &#39;::&#39; + structname + &#39;&gt;(&#34;&#39; + mainSimulationName + &#39;__&#39; + structname + &#39;&#34;)\n&#39;

        for s in signals:
            fieldName = s.name

            lines += &#39;.field(&#34;&#39; + fieldName + &#39;&#34;, &amp;&#39; + mainSimulationName + &#39;::&#39; + structname + &#39;::&#39; + fieldName + &#39;)\n&#39;

        lines += &#39;;\n\n&#39;


        return lines

    def generate_code_writeIO(self, command_API):
        return self.generate_code_writeIO__(command_API, 1) + self.generate_code_writeIO__(command_API, 2)


    def write_code(self, folder):

        TargetGenericCpp.writeFiles(self, folder)

        self.codeFolder = folder

        f = open( Path( folder ) / &#34;main.cpp&#34;, &#34;w&#34;)
        f.write( self.sourceCode )
        f.close()


    def build(self):

        buildCommand = &#39;emcc --bind -s MODULARIZE=1 -s EXPORT_NAME=&#34;ORTD_simulator&#34; &#39;  + os.path.join(self.codeFolder , &#34;main.cpp&#34;) + &#34; -g4 -s -o &#34; + os.path.join( self.codeFolder , &#34;main.js&#34; )
        print(&#34;Running compiler: &#34; + buildCommand)

        returnCode = os.system(buildCommand)

        print( &#34;Compilation result: &#34;, returnCode )


    def initCodeTemplate(self):

        #
        # template for main function in c++
        #

        self.template = &#34;&#34;&#34;
            
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;emscripten/bind.h&gt;

using namespace emscripten;

//
// implementation of $mainSimulationName
//

$algorithmCode

// Binding code
EMSCRIPTEN_BINDINGS(my_class_example) {
  class_&lt;$mainSimulationName&gt;(&#34;$mainSimulationName&#34;)
    .constructor&lt;&gt;()
    .function(&#34;resetStates&#34;, &amp;$mainSimulationName::resetStates__)
    .function(&#34;calcResults_1&#34;, &amp;$mainSimulationName::calcResults_1__)
    .function(&#34;updateStates&#34;, &amp;$mainSimulationName::updateStates__)
    ;


// --------------------------------

$ioExport


}
            
        &#34;&#34;&#34;        </code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.code_generation_templates.TargetGenericCpp" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetGenericCpp">TargetGenericCpp</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.TargetWasm.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self):

    buildCommand = &#39;emcc --bind -s MODULARIZE=1 -s EXPORT_NAME=&#34;ORTD_simulator&#34; &#39;  + os.path.join(self.codeFolder , &#34;main.cpp&#34;) + &#34; -g4 -s -o &#34; + os.path.join( self.codeFolder , &#34;main.js&#34; )
    print(&#34;Running compiler: &#34; + buildCommand)

    returnCode = os.system(buildCommand)

    print( &#34;Compilation result: &#34;, returnCode )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetWasm.code_gen"><code class="name flex">
<span>def <span class="ident">code_gen</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def code_gen(self):

    # build I/O structs
    ioExport = self.generate_code_writeIO(self.main_command.command_to_put_main_system.outputCommand)
    ioExport += self.generate_code_writeIO(self.main_command.command_to_put_main_system.updateCommand)

    ioExport += self.generate_code_writeIO(self.main_command.command_to_put_main_system.resetCommand)

    self.template = Template(self.template).safe_substitute( ioExport=ioExport,
                                                             inputConstAssignment=&#39;&#39;    ) 

    # call helper to fill in some generic elements into the template
    code_gen_results = TargetGenericCpp.code_gen(self)

    self.sourceCode = self.template

    code_gen_results[&#39;sourcecode&#39;] = self.sourceCode
    return code_gen_results</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetWasm.generate_code_writeIO"><code class="name flex">
<span>def <span class="ident">generate_code_writeIO</span></span>(<span>self, command_API)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_writeIO(self, command_API):
    return self.generate_code_writeIO__(command_API, 1) + self.generate_code_writeIO__(command_API, 2)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetWasm.generate_code_writeIO__"><code class="name flex">
<span>def <span class="ident">generate_code_writeIO__</span></span>(<span>self, command_API, inputOutput: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_writeIO__(self, command_API, inputOutput : int):

    if inputOutput == 1:
        structPrefix = &#39;Inputs_&#39;
        signals = command_API.inputSignals

    elif inputOutput == 2:
        structPrefix = &#39;Outputs_&#39;
        signals = command_API.outputSignals

    mainSimulationName = self.main_command.command_to_put_main_system.API_name

    lines = &#39;&#39;

    # Inputs
    structname = structPrefix + command_API.API_name 

    lines += &#39;value_object&lt;&#39; + mainSimulationName + &#39;::&#39; + structname + &#39;&gt;(&#34;&#39; + mainSimulationName + &#39;__&#39; + structname + &#39;&#34;)\n&#39;

    for s in signals:
        fieldName = s.name

        lines += &#39;.field(&#34;&#39; + fieldName + &#39;&#34;, &amp;&#39; + mainSimulationName + &#39;::&#39; + structname + &#39;::&#39; + fieldName + &#39;)\n&#39;

    lines += &#39;;\n\n&#39;


    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetWasm.initCodeTemplate"><code class="name flex">
<span>def <span class="ident">initCodeTemplate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def initCodeTemplate(self):

        #
        # template for main function in c++
        #

        self.template = &#34;&#34;&#34;
            
#include &lt;math.h&gt;
#include &lt;stdio.h&gt;
#include &lt;emscripten/bind.h&gt;

using namespace emscripten;

//
// implementation of $mainSimulationName
//

$algorithmCode

// Binding code
EMSCRIPTEN_BINDINGS(my_class_example) {
  class_&lt;$mainSimulationName&gt;(&#34;$mainSimulationName&#34;)
    .constructor&lt;&gt;()
    .function(&#34;resetStates&#34;, &amp;$mainSimulationName::resetStates__)
    .function(&#34;calcResults_1&#34;, &amp;$mainSimulationName::calcResults_1__)
    .function(&#34;updateStates&#34;, &amp;$mainSimulationName::updateStates__)
    ;


// --------------------------------

$ioExport


}
            
        &#34;&#34;&#34;        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.TargetWasm.write_code"><code class="name flex">
<span>def <span class="ident">write_code</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_code(self, folder):

    TargetGenericCpp.writeFiles(self, folder)

    self.codeFolder = folder

    f = open( Path( folder ) / &#34;main.cpp&#34;, &#34;w&#34;)
    f.write( self.sourceCode )
    f.close()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.code_generation_templates.TargetGenericCpp" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetGenericCpp">TargetGenericCpp</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.code_generation_templates.TargetGenericCpp.get_algorithm_code" href="code_generation_templates.html#openrtdynamics2.lang.code_generation_templates.TargetGenericCpp.get_algorithm_code">get_algorithm_code</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.state_sub"><code class="flex name class">
<span>class <span class="ident">state_sub</span></span>
<span>(</span><span>subsystem_name=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A single subsystem as part of a state machine (implemented by sub_statemachine)</p>
<ul>
<li>methods to called by the user -</li>
</ul>
<p>set_switched_outputs(signals, state_signal)
- connect a list of signals to the output of the state machine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class state_sub(SwitchedSubsystemPrototype):
    &#34;&#34;&#34;
        A single subsystem as part of a state machine (implemented by sub_statemachine)

        - methods to called by the user -

        set_switched_outputs(signals, state_signal)  - connect a list of signals to the output of the state machine
    &#34;&#34;&#34;

    def __init__(self, subsystem_name = None ):
        SwitchedSubsystemPrototype.__init__(self, subsystem_name)

        self._output_signals = None
        self._state_signal = None


    def set_switched_outputs(self, signals, state_signal):
        &#34;&#34;&#34;
            set the output signals of a subsystem embedded into the state machine

            - signals      - normal system output that are forwarded using a switch
            - state_signal - control signal indicating the next state the state machine enters
        &#34;&#34;&#34;
        self._output_signals = signals
        self._state_signal = state_signal

        self.set_switched_outputs_prototype( signals +  [state_signal] )

    @property
    def state_control_output(self):
         return self._state_signal

    @property
    def subsystem_outputs(self):
        return self._output_signals</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype">SwitchedSubsystemPrototype</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.state_sub.state_control_output"><code class="name">var <span class="ident">state_control_output</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_control_output(self):
     return self._state_signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.state_sub.subsystem_outputs"><code class="name">var <span class="ident">subsystem_outputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def subsystem_outputs(self):
    return self._output_signals</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.state_sub.set_switched_outputs"><code class="name flex">
<span>def <span class="ident">set_switched_outputs</span></span>(<span>self, signals, state_signal)</span>
</code></dt>
<dd>
<div class="desc"><p>set the output signals of a subsystem embedded into the state machine</p>
<ul>
<li>signals
- normal system output that are forwarded using a switch</li>
<li>state_signal - control signal indicating the next state the state machine enters</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_switched_outputs(self, signals, state_signal):
    &#34;&#34;&#34;
        set the output signals of a subsystem embedded into the state machine

        - signals      - normal system output that are forwarded using a switch
        - state_signal - control signal indicating the next state the state machine enters
    &#34;&#34;&#34;
    self._output_signals = signals
    self._state_signal = state_signal

    self.set_switched_outputs_prototype( signals +  [state_signal] )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype">SwitchedSubsystemPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype.set_switched_outputs_prototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchedSubsystemPrototype.set_switched_outputs_prototype">set_switched_outputs_prototype</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.sub_if"><code class="flex name class">
<span>class <span class="ident">sub_if</span></span>
<span>(</span><span>condition_signal: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, subsystem_name=None, prevent_output_computation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>NOTE: in case the if condition is false, the outputs are hold. Eventally uninitialized.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sub_if:
    &#34;&#34;&#34;

        NOTE: in case the if condition is false, the outputs are hold. Eventally uninitialized.
    &#34;&#34;&#34;


    def __init__(self, condition_signal : dy.SignalUserTemplate, subsystem_name = None, prevent_output_computation = False ):

        if subsystem_name is not None:
            self._subsystem_name = subsystem_name
        else:
            self._subsystem_name = generate_subsystem_name()

        self._condition_signal = condition_signal
        self._prevent_output_computation = prevent_output_computation

        # 
        self._outputs_of_embeded_subsystem = []

        # outputs (links to the subsystem outputs) to be used by the user
        self._output_links = None


    def set_outputs(self, signals):
        self._outputs_of_embeded_subsystem = signals.copy()

    def __enter__(self):
        self._system = enter_subsystem(self._subsystem_name )

        return self


    def __exit__(self, type, value, traceback):

        embedded_subsystem = dy.get_system_context()

        # set the outputs of the system
        embedded_subsystem.set_primary_outputs( si.unwrap_list( self._outputs_of_embeded_subsystem ) )

        # create generic subsystem block prototype
        self._subsystem_block_prototype = bp.GenericSubsystem( sim=embedded_subsystem.upper_level_system, 
                                                    manifest=None, inputSignals=None, 
                                                    embedded_subsystem=embedded_subsystem,
                                                    N_outputs=len(self._outputs_of_embeded_subsystem) )

        # leave the context of the subsystem
        dy.leave_system()

        #
        # now in the system in which the embeder block (including the logic) shall be placed.
        #

        # create the embedder prototype
        embeddedingBlockPrototype = bp.TruggeredSubsystem( sim=dy.get_system_context(), 
                control_input=si.unwrap( self._condition_signal ), 
                subsystem_prototype=self._subsystem_block_prototype,
                prevent_output_computation = self._prevent_output_computation)


        # connect the normal outputs via links
        self._output_links = si.wrap_signal_list( embeddedingBlockPrototype.outputs )

        # connect the additional (control) outputs
        # self._state_output = si.wrap_signal( embeddedingBlockPrototype.state_output )

    @property
    def outputs(self):

        if self._output_links is None:
            BaseException(&#34;Please close the subsystem before querying its outputs&#34;)
        
        return self._output_links</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_if.outputs"><code class="name">var <span class="ident">outputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def outputs(self):

    if self._output_links is None:
        BaseException(&#34;Please close the subsystem before querying its outputs&#34;)
    
    return self._output_links</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_if.set_outputs"><code class="name flex">
<span>def <span class="ident">set_outputs</span></span>(<span>self, signals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_outputs(self, signals):
    self._outputs_of_embeded_subsystem = signals.copy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.sub_loop"><code class="flex name class">
<span>class <span class="ident">sub_loop</span></span>
<span>(</span><span>max_iterations: int, subsystem_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sub_loop:
    &#34;&#34;&#34;

    &#34;&#34;&#34;


    def __init__(self, max_iterations : int, subsystem_name = None ):

        if subsystem_name is not None:
            self._subsystem_name = subsystem_name
        else:
            self._subsystem_name = generate_subsystem_name()

        self._max_iterations = max_iterations

        # control outputs of the embedded subsystem
        self._until_signal = None
        self._yield_signal = None

        # 
        self._outputs_of_embeded_subsystem = []

        # outputs (links to the subsystem outputs) to be used by the user
        self._output_links = None


    def set_outputs(self, signals):
        self._outputs_of_embeded_subsystem = si.unwrap_list( signals.copy() )

    def loop_until(self, condition_signal):
        self._until_signal = condition_signal.unwrap

    def loop_yield(self, condition_signal):
        self._yield_signal = condition_signal.unwrap

    def __enter__(self):

        self._system = enter_subsystem(self._subsystem_name )

        return self


    def __exit__(self, type, value, traceback):

        embedded_subsystem = dy.get_system_context()

        # collect all outputs
        all_output_signals = []
        all_output_signals.extend(self._outputs_of_embeded_subsystem)
        if self._until_signal is not None:
            all_output_signals.append(self._until_signal)
        if self._yield_signal is not None:
            all_output_signals.append(self._yield_signal)

        # set the outputs of the system
        embedded_subsystem.set_primary_outputs(  all_output_signals  )

        # create generic subsystem block prototype
        self._subsystem_block_prototype = bp.GenericSubsystem( sim=embedded_subsystem.upper_level_system, 
                                                    manifest=None, inputSignals=None, 
                                                    embedded_subsystem=embedded_subsystem,
                                                    N_outputs=len(all_output_signals) )

        # leave the context of the subsystem
        dy.leave_system()

        #
        # now in the system in which the embeder block (including the logic) shall be placed.
        #

        # create the embeeder prototype
        embeddedingBlockPrototype = bp.LoopUntilSubsystem( sim=dy.get_system_context(), 
                max_iterations=self._max_iterations, 
                subsystem_prototype=self._subsystem_block_prototype,
                until_signal=self._until_signal,
                yield_signal=self._yield_signal)


                # subsystem_prototypes=subsystem_prototypes, 
                # reference_outputs=  si.unwrap_list( self._reference_outputs ) )

        # connect the normal outputs via links
        self._output_links = si.wrap_signal_list( embeddedingBlockPrototype.outputs )

        # connect the additional (control) outputs
        # self._state_output = si.wrap_signal( embeddedingBlockPrototype.state_output )

    @property
    def outputs(self):

        if self._output_links is None:
            BaseException(&#34;Please close the subsystem before querying its outputs&#34;)
        
        return self._output_links</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_loop.outputs"><code class="name">var <span class="ident">outputs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def outputs(self):

    if self._output_links is None:
        BaseException(&#34;Please close the subsystem before querying its outputs&#34;)
    
    return self._output_links</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_loop.loop_until"><code class="name flex">
<span>def <span class="ident">loop_until</span></span>(<span>self, condition_signal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_until(self, condition_signal):
    self._until_signal = condition_signal.unwrap</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sub_loop.loop_yield"><code class="name flex">
<span>def <span class="ident">loop_yield</span></span>(<span>self, condition_signal)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_yield(self, condition_signal):
    self._yield_signal = condition_signal.unwrap</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.sub_loop.set_outputs"><code class="name flex">
<span>def <span class="ident">set_outputs</span></span>(<span>self, signals)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_outputs(self, signals):
    self._outputs_of_embeded_subsystem = si.unwrap_list( signals.copy() )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="openrtdynamics2.lang.sub_statemachine"><code class="flex name class">
<span>class <span class="ident">sub_statemachine</span></span>
<span>(</span><span>switch_subsystem_name)</span>
</code></dt>
<dd>
<div class="desc"><p>A state machine subsystem</p>
<ul>
<li>properties -</li>
</ul>
<p>self.state - status signal of the state machine (available after 'with sub_statemachine' has findished)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sub_statemachine(SwitchPrototype):
    &#34;&#34;&#34;
        A state machine subsystem

        - properties -

        self.state - status signal of the state machine (available after &#39;with sub_statemachine&#39; has findished)
    &#34;&#34;&#34;
    def __init__(self, switch_subsystem_name):
        number_of_control_outputs = 1 # add one control output to inform about the current state

        SwitchPrototype.__init__(self, switch_subsystem_name, number_of_control_outputs )

        # state output signal undefined until defined by on_exit() 
        self._state_output = None

    @property
    def state(self):
        &#34;&#34;&#34;
            get the signal describing the current state
        &#34;&#34;&#34;
        return self._state_output

    def new_subsystem(self, subsystem_name = None):

        system = state_sub(subsystem_name=subsystem_name)
        self._subsystem_list.append(system)

        return system

    def on_exit(self, subsystem_prototypes):

        # create the embeeder prototype
        embeddedingBlockPrototype = bp.StatemachineSwitchSubsystems( sim=dy.get_system_context(), 
                subsystem_prototypes=subsystem_prototypes, 
                reference_outputs=  si.unwrap_list( self._reference_outputs ) )

        # connect the normal outputs via links
        self._switch_output_links = si.wrap_signal_list( embeddedingBlockPrototype.switched_normal_outputs )

        # connect the additional (control) outputs
        self._state_output = si.wrap_signal( embeddedingBlockPrototype.state_output )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.subsystems.SwitchPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype">SwitchPrototype</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_statemachine.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<div class="desc"><p>get the signal describing the current state</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self):
    &#34;&#34;&#34;
        get the signal describing the current state
    &#34;&#34;&#34;
    return self._state_output</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_statemachine.new_subsystem"><code class="name flex">
<span>def <span class="ident">new_subsystem</span></span>(<span>self, subsystem_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_subsystem(self, subsystem_name = None):

    system = state_sub(subsystem_name=subsystem_name)
    self._subsystem_list.append(system)

    return system</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.subsystems.SwitchPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype">SwitchPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.subsystems.SwitchPrototype.on_exit" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype.on_exit">on_exit</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.sub_switch"><code class="flex name class">
<span>class <span class="ident">sub_switch</span></span>
<span>(</span><span>switch_subsystem_name, select_signal: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>a switch for subsystems that are implemented by SwitchedSubsystemPrototype (class to be derived)</p>
<p>switch_subsystem_name
- the name of the switch
number_of_control_outputs - the number of system outputs in addition to the embedded systems outputs
i.e. control outputs of a switch/statemaching/&hellip;</p>
<ul>
<li>member variables -</li>
</ul>
<p>self._switch_output_links
- overwrite by derived class when calling on_exit()
self.outputs
- a list of output signals as defined by self._switch_output_links</p>
<ul>
<li>methods to be defined -</li>
</ul>
<p>on_exit(subsystem_prototypes)
- callback once all subsystems were defined
during this callback self._switch_output_links must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class sub_switch(SwitchPrototype):
    def __init__(self, switch_subsystem_name, select_signal : dy.SignalUserTemplate ):

        self._select_signal = select_signal
        SwitchPrototype.__init__(self, switch_subsystem_name, number_of_control_outputs=0)

    def new_subsystem(self, subsystem_name = None):

        system = SwitchedSubsystem(subsystem_name=subsystem_name)
        self._subsystem_list.append(system)

        return system


    def on_exit(self, subsystem_prototypes):

        # create the  embeeder prototype
        embeddedingBlockPrototype = bp.SwitchSubsystems( sim=dy.get_system_context(), 
                control_input=self._select_signal.unwrap, 
                subsystem_prototypes=subsystem_prototypes, 
                reference_outputs=  si.unwrap_list( self._reference_outputs ) )

        # connect the normal outputs via links
        self._switch_output_links = si.wrap_signal_list( embeddedingBlockPrototype.switched_normal_outputs )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.subsystems.SwitchPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype">SwitchPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.sub_switch.new_subsystem"><code class="name flex">
<span>def <span class="ident">new_subsystem</span></span>(<span>self, subsystem_name=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def new_subsystem(self, subsystem_name = None):

    system = SwitchedSubsystem(subsystem_name=subsystem_name)
    self._subsystem_list.append(system)

    return system</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.subsystems.SwitchPrototype" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype">SwitchPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.subsystems.SwitchPrototype.on_exit" href="subsystems.html#openrtdynamics2.lang.subsystems.SwitchPrototype.on_exit">on_exit</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openrtdynamics2" href="../index.html">openrtdynamics2</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="openrtdynamics2.lang.block_interface" href="block_interface.html">openrtdynamics2.lang.block_interface</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes" href="block_prototypes.html">openrtdynamics2.lang.block_prototypes</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem" href="block_prototypes_single_subsystem.html">openrtdynamics2.lang.block_prototypes_single_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems" href="block_prototypes_subsystems.html">openrtdynamics2.lang.block_prototypes_subsystems</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems" href="block_prototypes_switched_subsystems.html">openrtdynamics2.lang.block_prototypes_switched_subsystems</a></code></li>
<li><code><a title="openrtdynamics2.lang.code_generation_templates" href="code_generation_templates.html">openrtdynamics2.lang.code_generation_templates</a></code></li>
<li><code><a title="openrtdynamics2.lang.core_blocks" href="core_blocks.html">openrtdynamics2.lang.core_blocks</a></code></li>
<li><code><a title="openrtdynamics2.lang.diagram_core" href="diagram_core/index.html">openrtdynamics2.lang.diagram_core</a></code></li>
<li><code><a title="openrtdynamics2.lang.high_level_user_commands" href="high_level_user_commands.html">openrtdynamics2.lang.high_level_user_commands</a></code></li>
<li><code><a title="openrtdynamics2.lang.libraries" href="libraries.html">openrtdynamics2.lang.libraries</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_interface" href="signal_interface.html">openrtdynamics2.lang.signal_interface</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library" href="standard_library.html">openrtdynamics2.lang.standard_library</a></code></li>
<li><code><a title="openrtdynamics2.lang.subsystems" href="subsystems.html">openrtdynamics2.lang.subsystems</a></code></li>
<li><code><a title="openrtdynamics2.lang.system_context" href="system_context.html">openrtdynamics2.lang.system_context</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="openrtdynamics2.lang.PID_controller" href="#openrtdynamics2.lang.PID_controller">PID_controller</a></code></li>
<li><code><a title="openrtdynamics2.lang.abs" href="#openrtdynamics2.lang.abs">abs</a></code></li>
<li><code><a title="openrtdynamics2.lang.acos" href="#openrtdynamics2.lang.acos">acos</a></code></li>
<li><code><a title="openrtdynamics2.lang.add" href="#openrtdynamics2.lang.add">add</a></code></li>
<li><code><a title="openrtdynamics2.lang.append_primay_ouput" href="#openrtdynamics2.lang.append_primay_ouput">append_primay_ouput</a></code></li>
<li><code><a title="openrtdynamics2.lang.asin" href="#openrtdynamics2.lang.asin">asin</a></code></li>
<li><code><a title="openrtdynamics2.lang.atan" href="#openrtdynamics2.lang.atan">atan</a></code></li>
<li><code><a title="openrtdynamics2.lang.atan2" href="#openrtdynamics2.lang.atan2">atan2</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_and" href="#openrtdynamics2.lang.bitwise_and">bitwise_and</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_not" href="#openrtdynamics2.lang.bitwise_not">bitwise_not</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_or" href="#openrtdynamics2.lang.bitwise_or">bitwise_or</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_shift_left" href="#openrtdynamics2.lang.bitwise_shift_left">bitwise_shift_left</a></code></li>
<li><code><a title="openrtdynamics2.lang.bitwise_shift_right" href="#openrtdynamics2.lang.bitwise_shift_right">bitwise_shift_right</a></code></li>
<li><code><a title="openrtdynamics2.lang.boolean" href="#openrtdynamics2.lang.boolean">boolean</a></code></li>
<li><code><a title="openrtdynamics2.lang.clear" href="#openrtdynamics2.lang.clear">clear</a></code></li>
<li><code><a title="openrtdynamics2.lang.comparison" href="#openrtdynamics2.lang.comparison">comparison</a></code></li>
<li><code><a title="openrtdynamics2.lang.compile_system" href="#openrtdynamics2.lang.compile_system">compile_system</a></code></li>
<li><code><a title="openrtdynamics2.lang.conditional_overwrite" href="#openrtdynamics2.lang.conditional_overwrite">conditional_overwrite</a></code></li>
<li><code><a title="openrtdynamics2.lang.const" href="#openrtdynamics2.lang.const">const</a></code></li>
<li><code><a title="openrtdynamics2.lang.convert" href="#openrtdynamics2.lang.convert">convert</a></code></li>
<li><code><a title="openrtdynamics2.lang.cos" href="#openrtdynamics2.lang.cos">cos</a></code></li>
<li><code><a title="openrtdynamics2.lang.counter" href="#openrtdynamics2.lang.counter">counter</a></code></li>
<li><code><a title="openrtdynamics2.lang.counter_triggered" href="#openrtdynamics2.lang.counter_triggered">counter_triggered</a></code></li>
<li><code><a title="openrtdynamics2.lang.cpp_allocate_class" href="#openrtdynamics2.lang.cpp_allocate_class">cpp_allocate_class</a></code></li>
<li><code><a title="openrtdynamics2.lang.cpp_call_class_member_function" href="#openrtdynamics2.lang.cpp_call_class_member_function">cpp_call_class_member_function</a></code></li>
<li><code><a title="openrtdynamics2.lang.delay" href="#openrtdynamics2.lang.delay">delay</a></code></li>
<li><code><a title="openrtdynamics2.lang.delay__" href="#openrtdynamics2.lang.delay__">delay__</a></code></li>
<li><code><a title="openrtdynamics2.lang.diff" href="#openrtdynamics2.lang.diff">diff</a></code></li>
<li><code><a title="openrtdynamics2.lang.dtf_lowpass_1_order" href="#openrtdynamics2.lang.dtf_lowpass_1_order">dtf_lowpass_1_order</a></code></li>
<li><code><a title="openrtdynamics2.lang.enter_system" href="#openrtdynamics2.lang.enter_system">enter_system</a></code></li>
<li><code><a title="openrtdynamics2.lang.euler_integrator" href="#openrtdynamics2.lang.euler_integrator">euler_integrator</a></code></li>
<li><code><a title="openrtdynamics2.lang.export_graph" href="#openrtdynamics2.lang.export_graph">export_graph</a></code></li>
<li><code><a title="openrtdynamics2.lang.flipflop" href="#openrtdynamics2.lang.flipflop">flipflop</a></code></li>
<li><code><a title="openrtdynamics2.lang.float64" href="#openrtdynamics2.lang.float64">float64</a></code></li>
<li><code><a title="openrtdynamics2.lang.fmod" href="#openrtdynamics2.lang.fmod">fmod</a></code></li>
<li><code><a title="openrtdynamics2.lang.gain" href="#openrtdynamics2.lang.gain">gain</a></code></li>
<li><code><a title="openrtdynamics2.lang.generate_code" href="#openrtdynamics2.lang.generate_code">generate_code</a></code></li>
<li><code><a title="openrtdynamics2.lang.generic_cpp_static" href="#openrtdynamics2.lang.generic_cpp_static">generic_cpp_static</a></code></li>
<li><code><a title="openrtdynamics2.lang.generic_subsystem" href="#openrtdynamics2.lang.generic_subsystem">generic_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.lang.get_system_context" href="#openrtdynamics2.lang.get_system_context">get_system_context</a></code></li>
<li><code><a title="openrtdynamics2.lang.init" href="#openrtdynamics2.lang.init">init</a></code></li>
<li><code><a title="openrtdynamics2.lang.init_simulation_context" href="#openrtdynamics2.lang.init_simulation_context">init_simulation_context</a></code></li>
<li><code><a title="openrtdynamics2.lang.initial_event" href="#openrtdynamics2.lang.initial_event">initial_event</a></code></li>
<li><code><a title="openrtdynamics2.lang.int32" href="#openrtdynamics2.lang.int32">int32</a></code></li>
<li><code><a title="openrtdynamics2.lang.leave_system" href="#openrtdynamics2.lang.leave_system">leave_system</a></code></li>
<li><code><a title="openrtdynamics2.lang.logic_and" href="#openrtdynamics2.lang.logic_and">logic_and</a></code></li>
<li><code><a title="openrtdynamics2.lang.logic_not" href="#openrtdynamics2.lang.logic_not">logic_not</a></code></li>
<li><code><a title="openrtdynamics2.lang.logic_or" href="#openrtdynamics2.lang.logic_or">logic_or</a></code></li>
<li><code><a title="openrtdynamics2.lang.logic_xor" href="#openrtdynamics2.lang.logic_xor">logic_xor</a></code></li>
<li><code><a title="openrtdynamics2.lang.memory" href="#openrtdynamics2.lang.memory">memory</a></code></li>
<li><code><a title="openrtdynamics2.lang.memory_read" href="#openrtdynamics2.lang.memory_read">memory_read</a></code></li>
<li><code><a title="openrtdynamics2.lang.operator1" href="#openrtdynamics2.lang.operator1">operator1</a></code></li>
<li><code><a title="openrtdynamics2.lang.play" href="#openrtdynamics2.lang.play">play</a></code></li>
<li><code><a title="openrtdynamics2.lang.pow" href="#openrtdynamics2.lang.pow">pow</a></code></li>
<li><code><a title="openrtdynamics2.lang.rate_limit" href="#openrtdynamics2.lang.rate_limit">rate_limit</a></code></li>
<li><code><a title="openrtdynamics2.lang.sample_and_hold" href="#openrtdynamics2.lang.sample_and_hold">sample_and_hold</a></code></li>
<li><code><a title="openrtdynamics2.lang.saturate" href="#openrtdynamics2.lang.saturate">saturate</a></code></li>
<li><code><a title="openrtdynamics2.lang.set_primary_outputs" href="#openrtdynamics2.lang.set_primary_outputs">set_primary_outputs</a></code></li>
<li><code><a title="openrtdynamics2.lang.show_blocks" href="#openrtdynamics2.lang.show_blocks">show_blocks</a></code></li>
<li><code><a title="openrtdynamics2.lang.show_execution_lines" href="#openrtdynamics2.lang.show_execution_lines">show_execution_lines</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal" href="#openrtdynamics2.lang.signal">signal</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_impulse" href="#openrtdynamics2.lang.signal_impulse">signal_impulse</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_periodic_impulse" href="#openrtdynamics2.lang.signal_periodic_impulse">signal_periodic_impulse</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_ramp" href="#openrtdynamics2.lang.signal_ramp">signal_ramp</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_sinus" href="#openrtdynamics2.lang.signal_sinus">signal_sinus</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_square" href="#openrtdynamics2.lang.signal_square">signal_square</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_step" href="#openrtdynamics2.lang.signal_step">signal_step</a></code></li>
<li><code><a title="openrtdynamics2.lang.signal_step_wise_sequence" href="#openrtdynamics2.lang.signal_step_wise_sequence">signal_step_wise_sequence</a></code></li>
<li><code><a title="openrtdynamics2.lang.sin" href="#openrtdynamics2.lang.sin">sin</a></code></li>
<li><code><a title="openrtdynamics2.lang.sqrt" href="#openrtdynamics2.lang.sqrt">sqrt</a></code></li>
<li><code><a title="openrtdynamics2.lang.sum" href="#openrtdynamics2.lang.sum">sum</a></code></li>
<li><code><a title="openrtdynamics2.lang.sum2" href="#openrtdynamics2.lang.sum2">sum2</a></code></li>
<li><code><a title="openrtdynamics2.lang.switchNto1" href="#openrtdynamics2.lang.switchNto1">switchNto1</a></code></li>
<li><code><a title="openrtdynamics2.lang.system_input" href="#openrtdynamics2.lang.system_input">system_input</a></code></li>
<li><code><a title="openrtdynamics2.lang.tan" href="#openrtdynamics2.lang.tan">tan</a></code></li>
<li><code><a title="openrtdynamics2.lang.toggle" href="#openrtdynamics2.lang.toggle">toggle</a></code></li>
<li><code><a title="openrtdynamics2.lang.transfer_function_discrete" href="#openrtdynamics2.lang.transfer_function_discrete">transfer_function_discrete</a></code></li>
<li><code><a title="openrtdynamics2.lang.unwrap_angle" href="#openrtdynamics2.lang.unwrap_angle">unwrap_angle</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeArray" href="#openrtdynamics2.lang.DataTypeArray">DataTypeArray</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypeArray.cpp_datatype_string" href="#openrtdynamics2.lang.DataTypeArray.cpp_datatype_string">cpp_datatype_string</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeArray.cpp_define_variable" href="#openrtdynamics2.lang.DataTypeArray.cpp_define_variable">cpp_define_variable</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeArray.datatype_of_elements" href="#openrtdynamics2.lang.DataTypeArray.datatype_of_elements">datatype_of_elements</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeBoolean" href="#openrtdynamics2.lang.DataTypeBoolean">DataTypeBoolean</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypeBoolean.cpp_datatype_string" href="#openrtdynamics2.lang.DataTypeBoolean.cpp_datatype_string">cpp_datatype_string</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeBoolean.cpp_printf_pattern" href="#openrtdynamics2.lang.DataTypeBoolean.cpp_printf_pattern">cpp_printf_pattern</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeBoolean.cpp_zero_element" href="#openrtdynamics2.lang.DataTypeBoolean.cpp_zero_element">cpp_zero_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeFloat64" href="#openrtdynamics2.lang.DataTypeFloat64">DataTypeFloat64</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypeFloat64.cpp_datatype_string" href="#openrtdynamics2.lang.DataTypeFloat64.cpp_datatype_string">cpp_datatype_string</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeFloat64.cpp_printf_pattern" href="#openrtdynamics2.lang.DataTypeFloat64.cpp_printf_pattern">cpp_printf_pattern</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeFloat64.cpp_zero_element" href="#openrtdynamics2.lang.DataTypeFloat64.cpp_zero_element">cpp_zero_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeInt32" href="#openrtdynamics2.lang.DataTypeInt32">DataTypeInt32</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypeInt32.cpp_datatype_string" href="#openrtdynamics2.lang.DataTypeInt32.cpp_datatype_string">cpp_datatype_string</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeInt32.cpp_printf_pattern" href="#openrtdynamics2.lang.DataTypeInt32.cpp_printf_pattern">cpp_printf_pattern</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypeInt32.cpp_zero_element" href="#openrtdynamics2.lang.DataTypeInt32.cpp_zero_element">cpp_zero_element</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypeNumeric" href="#openrtdynamics2.lang.DataTypeNumeric">DataTypeNumeric</a></code></h4>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.DataTypePointer" href="#openrtdynamics2.lang.DataTypePointer">DataTypePointer</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.DataTypePointer.cpp_datatype_string" href="#openrtdynamics2.lang.DataTypePointer.cpp_datatype_string">cpp_datatype_string</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypePointer.cpp_datatype_string_class" href="#openrtdynamics2.lang.DataTypePointer.cpp_datatype_string_class">cpp_datatype_string_class</a></code></li>
<li><code><a title="openrtdynamics2.lang.DataTypePointer.is_equal_to" href="#openrtdynamics2.lang.DataTypePointer.is_equal_to">is_equal_to</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.SignalUserTemplate" href="#openrtdynamics2.lang.SignalUserTemplate">SignalUserTemplate</a></code></h4>
<ul class="two-column">
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.extend_name" href="#openrtdynamics2.lang.SignalUserTemplate.extend_name">extend_name</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.name" href="#openrtdynamics2.lang.SignalUserTemplate.name">name</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.properties" href="#openrtdynamics2.lang.SignalUserTemplate.properties">properties</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_blockname" href="#openrtdynamics2.lang.SignalUserTemplate.set_blockname">set_blockname</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_datatype" href="#openrtdynamics2.lang.SignalUserTemplate.set_datatype">set_datatype</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_name" href="#openrtdynamics2.lang.SignalUserTemplate.set_name">set_name</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_name_raw" href="#openrtdynamics2.lang.SignalUserTemplate.set_name_raw">set_name_raw</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.set_properties" href="#openrtdynamics2.lang.SignalUserTemplate.set_properties">set_properties</a></code></li>
<li><code><a title="openrtdynamics2.lang.SignalUserTemplate.unwrap" href="#openrtdynamics2.lang.SignalUserTemplate.unwrap">unwrap</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.TargetBasicExecutable" href="#openrtdynamics2.lang.TargetBasicExecutable">TargetBasicExecutable</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.TargetBasicExecutable.build" href="#openrtdynamics2.lang.TargetBasicExecutable.build">build</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetBasicExecutable.code_gen" href="#openrtdynamics2.lang.TargetBasicExecutable.code_gen">code_gen</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetBasicExecutable.initCodeTemplate" href="#openrtdynamics2.lang.TargetBasicExecutable.initCodeTemplate">initCodeTemplate</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetBasicExecutable.run" href="#openrtdynamics2.lang.TargetBasicExecutable.run">run</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetBasicExecutable.write_code" href="#openrtdynamics2.lang.TargetBasicExecutable.write_code">write_code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.TargetGenericCpp" href="#openrtdynamics2.lang.TargetGenericCpp">TargetGenericCpp</a></code></h4>
<ul class="two-column">
<li><code><a title="openrtdynamics2.lang.TargetGenericCpp.add_code_to_include" href="#openrtdynamics2.lang.TargetGenericCpp.add_code_to_include">add_code_to_include</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetGenericCpp.build" href="#openrtdynamics2.lang.TargetGenericCpp.build">build</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetGenericCpp.code_gen" href="#openrtdynamics2.lang.TargetGenericCpp.code_gen">code_gen</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetGenericCpp.get_algorithm_code" href="#openrtdynamics2.lang.TargetGenericCpp.get_algorithm_code">get_algorithm_code</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetGenericCpp.include_systems" href="#openrtdynamics2.lang.TargetGenericCpp.include_systems">include_systems</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetGenericCpp.run" href="#openrtdynamics2.lang.TargetGenericCpp.run">run</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetGenericCpp.set_compile_results" href="#openrtdynamics2.lang.TargetGenericCpp.set_compile_results">set_compile_results</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetGenericCpp.writeFiles" href="#openrtdynamics2.lang.TargetGenericCpp.writeFiles">writeFiles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.TargetWasm" href="#openrtdynamics2.lang.TargetWasm">TargetWasm</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.TargetWasm.build" href="#openrtdynamics2.lang.TargetWasm.build">build</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetWasm.code_gen" href="#openrtdynamics2.lang.TargetWasm.code_gen">code_gen</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetWasm.generate_code_writeIO" href="#openrtdynamics2.lang.TargetWasm.generate_code_writeIO">generate_code_writeIO</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetWasm.generate_code_writeIO__" href="#openrtdynamics2.lang.TargetWasm.generate_code_writeIO__">generate_code_writeIO__</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetWasm.initCodeTemplate" href="#openrtdynamics2.lang.TargetWasm.initCodeTemplate">initCodeTemplate</a></code></li>
<li><code><a title="openrtdynamics2.lang.TargetWasm.write_code" href="#openrtdynamics2.lang.TargetWasm.write_code">write_code</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.state_sub" href="#openrtdynamics2.lang.state_sub">state_sub</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.state_sub.set_switched_outputs" href="#openrtdynamics2.lang.state_sub.set_switched_outputs">set_switched_outputs</a></code></li>
<li><code><a title="openrtdynamics2.lang.state_sub.state_control_output" href="#openrtdynamics2.lang.state_sub.state_control_output">state_control_output</a></code></li>
<li><code><a title="openrtdynamics2.lang.state_sub.subsystem_outputs" href="#openrtdynamics2.lang.state_sub.subsystem_outputs">subsystem_outputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.sub_if" href="#openrtdynamics2.lang.sub_if">sub_if</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.sub_if.outputs" href="#openrtdynamics2.lang.sub_if.outputs">outputs</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_if.set_outputs" href="#openrtdynamics2.lang.sub_if.set_outputs">set_outputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.sub_loop" href="#openrtdynamics2.lang.sub_loop">sub_loop</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.sub_loop.loop_until" href="#openrtdynamics2.lang.sub_loop.loop_until">loop_until</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_loop.loop_yield" href="#openrtdynamics2.lang.sub_loop.loop_yield">loop_yield</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_loop.outputs" href="#openrtdynamics2.lang.sub_loop.outputs">outputs</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_loop.set_outputs" href="#openrtdynamics2.lang.sub_loop.set_outputs">set_outputs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.sub_statemachine" href="#openrtdynamics2.lang.sub_statemachine">sub_statemachine</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.sub_statemachine.new_subsystem" href="#openrtdynamics2.lang.sub_statemachine.new_subsystem">new_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.lang.sub_statemachine.state" href="#openrtdynamics2.lang.sub_statemachine.state">state</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.sub_switch" href="#openrtdynamics2.lang.sub_switch">sub_switch</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.sub_switch.new_subsystem" href="#openrtdynamics2.lang.sub_switch.new_subsystem">new_subsystem</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>