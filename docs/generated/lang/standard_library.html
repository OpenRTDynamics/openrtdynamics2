<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>openrtdynamics2.lang.standard_library API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openrtdynamics2.lang.standard_library</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math

import typing as t
from . import lang as dy
from .signal_interface import SignalUserTemplate
import numpy as np

from .core_blocks import generic_subsystem, const, gain, convert, add, operator1, logic_and, logic_or, logic_xor, bitwise_and, bitwise_or, bitwise_shift_left, bitwise_shift_right, comparison, switchNto1, conditional_overwrite, sqrt, sin, cos, tan, atan, asin, acos, abs, logic_not, bitwise_not, atan2, pow, fmod, generic_cpp_static, flipflop, memory, memory_read, delay__, cpp_allocate_class, cpp_call_class_member_function



#
# constants
#

def int32(value):
    &#34;&#34;&#34;Cast anything to DataTypeInt32

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, int
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type int32

    &#34;&#34;&#34;

    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeInt32(1) )

def float64(value):
    &#34;&#34;&#34;Cast anything to DataTypeFloat64

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, float
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type float64

    &#34;&#34;&#34;
    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeFloat64(1) )


def boolean(value):
    &#34;&#34;&#34;Cast anything to DataTypeBoolean

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, int
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type boolean

    &#34;&#34;&#34;
    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeBoolean(1) )



#
#
#

def initial_event():
    &#34;&#34;&#34;Emits an event on the first sampling instant after the reset of the system

    Returns
    -------
    SignalUserTemplate
        the signal of type boolean containing the event
    &#34;&#34;&#34;

    # TODO: introduce caching like done for counter()

    return dy.counter() == int32(0)


#
# Delay - the basis for all dynamic elements
#
def delay(u , initial_state = None):
    &#34;&#34;&#34;Unit delay

    Delay the input u by one sampling instant:

        y[k+1] = u[k], y[0] = initial_state

    Parameters
    ----------
    u : SignalUserTemplate
        the input signal to delay
    initial_state : SignalUserTemplate
        the initial state (signal or constant value)

    Returns
    -------
    SignalUserTemplate
        the one-step delayed input   

    &#34;&#34;&#34;

    if not isinstance( initial_state, SignalUserTemplate ):
        return dy.delay__( u, initial_state )

    else:

        event_on_first_sample = initial_event()

        delayed_input = dy.delay__( u, None )
        delayed_input = dy.conditional_overwrite( delayed_input, event_on_first_sample, initial_state )

        return delayed_input

def sample_and_hold(u, event, initial_state = None):
    &#34;&#34;&#34;Sample &amp; hold

    Samples the input when event is true and hold this value for the proceeding time instants. 

    Parameters
    ----------
    u : SignalUserTemplate
        the input to sample
    event : SignalUserTemplate
        the event on which sampling of the input is performed
    initial_state : SignalUserTemplate
        the initial output

    Returns
    -------
    SignalUserTemplate
        the sampled input   

    &#34;&#34;&#34;

    # NOTE: this could be implemented in a more comp. efficient way directly in C in block_prototypes.py

    y = dy.signal()

    delayed_y = delay( y, initial_state )
    y &lt;&lt; dy.conditional_overwrite( delayed_y, event, u )

    return y

#
# static functions
#

def unwrap_angle(angle, normalize_around_zero = False):
    &#34;&#34;&#34;Unwrap an angle

    Unwrap and normalize the input angle to the range 

           [0, 2*pi[     in case normalize_around_zero == false
        or [-pi, pi]     in case normalize_around_zero == true


    Parameters
    ----------

    angle : SignalUserTemplate
        the input signal (angle in radians)

    Returns
    -------
    SignalUserTemplate
        the output signal   

    &#34;&#34;&#34;

    def normalize_around_zero(angle):
        &#34;&#34;&#34;
            Normalize an angle

            Normalize an angle to a range [-pi, pi]

            Important: the assumed range for the input is - 2*pi &lt;= angle &lt;= 2*p
        &#34;&#34;&#34;

        tmp = angle            + dy.conditional_overwrite( dy.float64(0), angle &lt;= float64(-math.pi), 2*math.pi )
        normalized_angle = tmp + dy.conditional_overwrite( dy.float64(0), angle &gt; float64(math.pi), -2*math.pi )

        return normalized_angle

    #
    #
    angle_ = dy.fmod(angle, dy.float64(2*math.pi) )

    unwrapped_angle = angle_ + dy.conditional_overwrite( dy.float64(0), angle_ &lt; float64(0), 2*math.pi )

    if normalize_around_zero:
        return normalize_around_zero(unwrapped_angle)
    else:
        return unwrapped_angle





def saturate(u, lower_limit = None, upper_limit = None):
    &#34;&#34;&#34;Saturation

    The output is the saturated input

    Parameters
    ----------

    lower_limit : SignalUserTemplate
        lower bound for the output 
    upper_limit : SignalUserTemplate
        upper bound for the output

    Returns
    -------
    SignalUserTemplate
        the integer output signal 

    Details
    -------
            { lower_limit   for u &lt; lower_limit
        y = { u             otherwise
            { upper_limit  for u &gt; upper_limit
    &#34;&#34;&#34;

    y = u

    if lower_limit is not None:
        y = dy.conditional_overwrite( y, y &lt; float64(lower_limit), lower_limit )
    
    if upper_limit is not None:
        y = dy.conditional_overwrite( y, y &gt; float64(upper_limit), upper_limit )

    return y


def rate_limit( u, Ts, lower_limit, upper_limit, initial_state = 0 ):
    &#34;&#34;&#34;Rate limiter

    Parameters
    ----------

    Ts : SignalUserTemplate
        sampling time (constant)
    lower_limit : SignalUserTemplate
        lower rate limit
    upper_limit : SignalUserTemplate
        upper rate limit

    Returns
    -------
    SignalUserTemplate
        the output signal    

    &#34;&#34;&#34;

    Ts_ = float64(Ts)

    y = dy.signal()

    omega = u - y
    omega_sat = saturate(omega, float64(lower_limit) * Ts_, float64(upper_limit) * Ts_)
    y &lt;&lt; euler_integrator( omega_sat, 1, initial_state=initial_state)

    return y


#
# Counters
#

# TODO: mark as private
class __Counter():
    &#34;&#34;&#34;
        This class is meant to store the counter output signal as it might be used
        by more than one destination block. The instance of this class is per simulation
        and will be stored in the components property of the current get_system_context()
    &#34;&#34;&#34;
    def __init__(self, counter_signal : SignalUserTemplate):
        self.counter_signal_ = counter_signal
        self.hits = 0
    
    @property
    def output(self):
        self.hits += 1

        # print(&#34;counter cache hits ***: &#34; + str(self.hits) )
        return self.counter_signal_


#
# dynamic functions
#

def counter():
    &#34;&#34;&#34;Basic counter - the sampling index k

    The integer output is increasing with each sampling instant by 1.
    Counting starts at zero.

    Returns
    -------
    SignalUserTemplate
        the integer output signal describing the sampling index k

    &#34;&#34;&#34;

    if not &#39;counter&#39; in dy.get_system_context().components:
        # no counter has been defined in this system so far. Hence, create one.

        increase = dy.const(1, dy.DataTypeInt32(1) )
        cnt = dy.signal()
        tmp = dy.delay(cnt + increase)
        cnt &lt;&lt; tmp 

        tmp.set_name(&#39;shared_counter&#39;)

        # store the output signal of the counter as it might be used again. 
        dy.get_system_context().components[&#39;counter&#39;] = __Counter(tmp)

    else:
        # use the output of an already created counter
        tmp = dy.get_system_context().components[&#39;counter&#39;].output

    return tmp





def counter_triggered( upper_limit, stepwidth=None, initial_state = 0, reset=None, reset_on_limit:bool=False, start_trigger=None, pause_trigger=None, auto_start:bool=True, no_delay:bool=False ):
    &#34;&#34;&#34;A generic counter

    Features:
    - upper limit
    - triggerable start/pause
    - resetable
    - dynamic adjustable step-size

    Parameters
    ----------

    upper_limit : int
        the upper limit of the counter
    initial_state : int
        the state after reset
    reset : SignalUserTemplate
        reset the counter
    reset_on_limit : bool
        reset counter once the upper limit is reached
    start_trigger : SignalUserTemplate
        event to start counting
    pause_trigger : SignalUserTemplate
        event to pause counting
    auto_start : bool
        start counting automatically
    no_delay : bool
        when True the new value of the counter is returned without delay 

    Returns
    -------
    SignalUserTemplate
        the boolean output signal 
    SignalUserTemplate
        event that fires when the upper limit of the counter is reached 
        
    &#34;&#34;&#34;

    if stepwidth is None:
        stepwidth = dy.int32(1)

    counter = dy.signal()

    reached_upper_limit = counter &gt;= dy.int32(upper_limit)

    if start_trigger is None:
        start_trigger = dy.boolean(0)

    # 
    if pause_trigger is not None: 
        activate_trigger = dy.logic_or(reached_upper_limit, pause_trigger)
    else:
        if not auto_start:
            activate_trigger = reached_upper_limit
        else:
            # when auto_start is active, continue counting after reset on reached_upper_limit
            activate_trigger = dy.boolean(0)


    # state for pause/counting
    paused =  dy.flipflop(activate_trigger=activate_trigger, disable_trigger=start_trigger, initial_state = not auto_start, no_delay=True).set_name(&#39;paused&#39;)

    # prevent counter increase
    stepwidth = dy.conditional_overwrite(stepwidth, paused, 0).set_name(&#39;stepwidth&#39;)

    # increase the counter until the end is reached
    new_counter = counter + dy.conditional_overwrite(stepwidth, reached_upper_limit, 0)

    if reset is not None:
        # reset in case this is requested
        new_counter = dy.conditional_overwrite(new_counter, reset, initial_state)

    if reset_on_limit:
        new_counter = dy.conditional_overwrite(new_counter, reached_upper_limit, initial_state)

    # introduce a state variable for the counter
    counter &lt;&lt; dy.delay( new_counter, initial_state=initial_state )

    if not no_delay:
        return counter, reached_upper_limit
    else:
        return new_counter, reached_upper_limit





def toggle(trigger, initial_state=False, no_delay=False):
    &#34;&#34;&#34;Toggle a state based on an event

    Parameters
    ----------

    period : SignalUserTemplate
        the signal to trigger a state change
    initial_state : int
        the initial state
    no_delay : bool
        when true the toggle immediately reacts to a trigger (default: false)

    Returns
    -------
    SignalUserTemplate
        the boolean state signal

    SignalUserTemplate
        the event for activation
    SignalUserTemplate
        the event for deactivation

    

    &#34;&#34;&#34;

    state = dy.signal()

    activate   = dy.logic_and( dy.logic_not( state ), trigger )
    deactivate = dy.logic_and( trigger , state)

    state_ = dy.flipflop( activate, deactivate, 
                            initial_state = 0, 
                            no_delay=no_delay )

    if not no_delay:
        state &lt;&lt; state_
    else:
        state &lt;&lt; dy.delay(state_)


    return state_, activate, deactivate
    

#
# signal generators
#

def signal_square(period, phase):
    &#34;&#34;&#34;Square wave signal generator

    Parameters
    ----------

    period : SignalUserTemplate
        singal or constant describing the period in samples at which the edges of the square are placed
    phase : SignalUserTemplate
        singal or constant describing the phase in samples at which the edges of the square are placed

    Returns
    -------
    SignalUserTemplate
        the output signal

    &#34;&#34;&#34;
    trigger = signal_periodic_impulse(period, phase)


    # k, trigger = counter_triggered( upper_limit=dy.int32(period) - dy.int32(1), reset_on_limit=True )

    state, activate, deactivate = toggle(trigger, no_delay=True)

    return state, activate, deactivate


def signal_sinus(N_period : int = 100, phi = None):
    &#34;&#34;&#34;Sine wave generator

    Parameters
    ----------
    N_period : SignalUserTemplate
        period in sampling instants (type: constant integer)
    phi : SignalUserTemplate
        phase shift (signal)

    Returns
    -------
    SignalUserTemplate
        the output signal

    Details
    -------
    The output is computed as follows:

    y = sin( k * (1 / N_period * 2 * pi) + phi )

    k - is the sampling index

    &#34;&#34;&#34;

    if N_period &lt;= 0:
        raise BaseException(&#39;N_period &lt;= 0&#39;)

    if phi is None:
        phi = dy.float64(0.0)

    i, _ = dy.counter_triggered( upper_limit=N_period-1, reset_on_limit=True )
    y = dy.sin( i * dy.float64(1/N_period * 2*math.pi) + phi )

    return y

def signal_step(k_step):
    &#34;&#34;&#34;Signal generator for a step signal

    Parameters
    ----------
    k_step : SignalUserTemplate
        the sampling index as returned by counter() at which the step appears.

    Returns
    -------
    SignalUserTemplate
        the output signal
    &#34;&#34;&#34;
    k = dy.counter()
    y = dy.int32(k_step) &lt;= k

    return y

def signal_ramp(k_start):
    &#34;&#34;&#34;Signal generator for a ramp signal

    Parameters
    ----------
    k_start : SignalUserTemplate
        the sampling index as returned by counter() at which the ramp starts increasing.

    Returns
    -------
    SignalUserTemplate
        the output signal

    Details
    -------

        y[k] = { 0           for k &lt;  k_start
               { k-k_start   for k &gt;= k_start
    &#34;&#34;&#34;
    k = dy.counter()
    active = dy.int32(k_start) &lt;= k

    linearRise = dy.convert( (k - dy.int32(k_start) ), dy.DataTypeFloat64(1) )
    activation = dy.convert( active, dy.DataTypeFloat64(1) )

    return activation * linearRise


def signal_impulse(k_event):
    &#34;&#34;&#34;Pulse signal generator

    Generates a unique pulse at the sampling index k_event.

    Parameters
    ----------
    k_event : SignalUserTemplate
        the sampling index at which the pulse appears


    Returns
    -------
    SignalUserTemplate
        the output signal
    &#34;&#34;&#34;

    if k_event &lt; 0:
        raise BaseException(&#39;The sampling index for the event is invalid (k_event &lt; 0)&#39;)

    k = dy.counter()
    pulse_signal = dy.int32(k_event) == k

    return pulse_signal

def signal_periodic_impulse(period, phase):
    &#34;&#34;&#34;Signal generator for periodic pulses

    Parameters
    ----------

    period : SignalUserTemplate
        singal or constant describing the period in samples at which the pulses are generated
    phase : SignalUserTemplate
        singal or constant describing the phase in samples at which the pulses are generated

    Returns
    -------
    SignalUserTemplate
        the output signal

    &#34;&#34;&#34;

    k, trigger = counter_triggered( upper_limit=dy.int32(period) - dy.int32(1), reset_on_limit=True )
    pulse_signal = dy.int32(phase) == k

    return pulse_signal



def signal_step_wise_sequence( time_instance_indices, values, time_scale=None, counter=None, reset=None ):
    &#34;&#34;&#34;Signal generator for a step-wise changeing signal

    Parameters
    ----------

    time_instance_indices : List[int]
        an array of sampling instants at which the signal changes its values
    values : List[float]
        an array of values; must have one more element than time_instance_indices
    time_scale : SignalUserTemplate
        multiplies all elements of time_instance_indices by the given factor (optional)
    counter : SignalUserTemplate
        an alternative sample counter (optional), default: counter=dy.counter()
    reset : SignalUserTemplate
        boolean signal to reset the sequence (optional)

    Returns
    -------
    SignalUserTemplate
        the output signal

    Example
    -------

        time_instance_indices = [      50, 100, 150, 250, 300, 350, 400,  450, 500  ]
        values                = [ 0, -1.0,   0, 1.0,  0, -1.0, 0,   0.2, -0.2, 0   ]

        v = step_wise_sequence( time_instance_indices, values )
    &#34;&#34;&#34;
    
    if len(values) - 1 != len(time_instance_indices):
        raise BaseException( &#34;len(values) - 1 != len(time_instance_indices)&#34; )

    if counter is None:
        counter = dy.counter()

    indices_mem = dy.memory(datatype=dy.DataTypeInt32(1),   constant_array=time_instance_indices )
    values_mem  = dy.memory(datatype=dy.DataTypeFloat64(1), constant_array=values )

    current_index = dy.signal()

    current_time_index_to_check = dy.memory_read( indices_mem, current_index )

    # scale time
    if time_scale is not None:
        index_to_check = time_scale * current_time_index_to_check
    else:
        index_to_check = current_time_index_to_check

    # check wether to step to the next sample
    increase_index = dy.int32(0)
    increase_index = dy.conditional_overwrite(increase_index, counter &gt;= index_to_check, dy.int32(1) )

    cnt_, _ = dy.counter_triggered(upper_limit=len(time_instance_indices), stepwidth=increase_index, reset=reset )
    current_index &lt;&lt; cnt_
    val = dy.memory_read(values_mem, current_index)

    return val


def play( sequence_array,  stepwidth=None, initial_state = 0, reset=None, reset_on_end:bool=False, start_trigger=None, pause_trigger=None, auto_start:bool=True, no_delay:bool=False ):
    &#34;&#34;&#34;Play a given sequence of samples

    Parameters
    ----------

    sequence_array : list[float]
        the sequence given as a list of values
    reset : SignalUserTemplate
        reset playback and start from the beginning
    reset_on_end : SignalUserTemplate
        reset playback once the end is reached (repetitive playback)
    start_trigger : SignalUserTemplate
        event to start playback
    pause_trigger : SignalUserTemplate
        event to pause playback
    auto_start : bool
        start playback automatically 


    Returns
    -------
    SignalUserTemplate
        the value obtained from sequence_array
    SignalUserTemplate
        the current position of playback (index of the currently issued sequence element)


    &#34;&#34;&#34;

    sequence_array_storage = dy.memory(datatype=dy.DataTypeFloat64(1), constant_array=sequence_array )

    # if prevent_initial_playback:
    #     initial_counter_state = np.size(sequence_array)
    # else:
        

    playback_index, _ = counter_triggered(
        upper_limit=np.size(sequence_array)-1, 
        stepwidth=stepwidth, initial_state=initial_state, 
        reset=reset, reset_on_limit=reset_on_end, 
        start_trigger=start_trigger, pause_trigger=pause_trigger, 
        auto_start=auto_start,
        no_delay=no_delay
    )

    # sample the given data
    sample = dy.memory_read(sequence_array_storage, playback_index)

    return sample, playback_index




#
# Filters
#

def diff(u : SignalUserTemplate, initial_state = None):
    &#34;&#34;&#34;Discrete difference

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    y = u[k] - u[k-1] 

    initial state

    u[0] = initial_state   in case initial_state is not None
    u[0] = 0               otherwise
    &#34;&#34;&#34;

    i = dy.delay( u, initial_state )
    y = dy.add( [ i, u ], [ -1, 1 ] )

    return y

def sum(u : SignalUserTemplate, initial_state=0, no_delay=False):
    &#34;&#34;&#34;Accumulative sum

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state
    no_delay : bool
        when true the output is not delayed

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    The difference equation

        y[k+1] = y[k] + u[k]

    is evaluated. The return value is either

        y[k]   by default or when no_delay == False
    or

        y[k+1] in case no_delay == True .
    &#34;&#34;&#34;

    y_k = dy.signal()
    
    y_kp1 = y_k + u

    y_k &lt;&lt; dy.delay(y_kp1, initial_state=initial_state)

    if no_delay:
        return y_kp1
    else:
        return y_k

def sum2(u : SignalUserTemplate, initial_state=0):
    &#34;&#34;&#34;Accumulative sum

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    The difference equation

        y[k+1] = y[k] + u[k]

    is evaluated. The return values are

        y[k], y[k+1]
    &#34;&#34;&#34;

    y_k = dy.signal()
    
    y_kp1 = y_k + u

    y_k &lt;&lt; dy.delay(y_kp1, initial_state=initial_state)

    return y_k, y_kp1

def euler_integrator( u : SignalUserTemplate, Ts, initial_state = 0.0):
    &#34;&#34;&#34;Euler (forward) integrator

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    Ts : float
        the sampling time
    initial_state : float, SignalUserTemplate
        the initial state of the integrator

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

        y[k+1] = y[k] + Ts * u[k]
    &#34;&#34;&#34;

    yFb = dy.signal()

    if not isinstance( Ts, SignalUserTemplate ): 
        i = dy.add( [ yFb, u ], [ 1, Ts ] )
    else:
        i = yFb + Ts * u

    y = dy.delay( i, initial_state )

    yFb &lt;&lt; y

    return y



def dtf_lowpass_1_order(u : SignalUserTemplate, z_infinity):
    &#34;&#34;&#34;First-order discrete-time low pass filter

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

                    1 - z_infinity
            H (z) =  --------------
                    z - z_infinity
    &#34;&#34;&#34;

    zinf = dy.float64( z_infinity )
    zinf_ = dy.float64( 1 ) - zinf

    y_delayed = dy.signal()
    y =  zinf * y_delayed + zinf_ * u

    y_delayed &lt;&lt; dy.delay(y)
    
    return y

def transfer_function_discrete(u : SignalUserTemplate, num_coeff : t.List[float], den_coeff : t.List[float] ):

    &#34;&#34;&#34;Discrete time transfer function

    Parameters
    ----------
    u : SignalUserTemplate
        the input signal
    num_coeff : List[float]
        a list of numerator coefficients of the transfer function
    den_coeff : List[float]
        a list of denominator coefficients of the transfer function

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    This filter realizes a discrete-time transfer function by using &#39;direct form II&#39;
    c.f. https://en.wikipedia.org/wiki/Digital_filter .

                b0 + b1 z^-1 + b2 z^-2 + ... + bN z^-N
        H(z) = ----------------------------------------
                1 + a1 z^-1 + a2 z^-2 + ... + aM z^-M

    The coefficient vectors num_coeff and den_coeff describe the numerator and 
    denominator polynomials, respectively, and are defined as follows:

        num_coeff = [b0, b1, .., bN]
        den_coeff = [a1, a2, ... aM] .
        
    &#34;&#34;&#34;


    # get filter order
    N = len(num_coeff)-1

    # feedback start signal
    z_pre = dy.signal()

    # array to store state signals
    z_ = []

    # create delay chain
    z_iterate = z_pre
    for i in range(0,N):

        z_iterate = dy.delay( z_iterate ) .extend_name(&#39;_z&#39; + str(i) )
        z_.append( z_iterate ) 


    # build feedback path
    #
    # a1 = den_coeff[0]
    # a2 = den_coeff[1]
    # a3 = den_coeff[2]
    #        ...
    sum_feedback = u
    for i in range(0,N):

        a_ip1 = dy.float64( den_coeff[i] ).extend_name(&#39;_a&#39; + str(i+1) )

        sum_feedback = sum_feedback - a_ip1 * z_[i]

    sum_feedback.extend_name(&#39;_i&#39;)


    # close the feedback loop
    z_pre &lt;&lt; sum_feedback

    # build output path
    #
    # b0 = num_coeff[0]
    # b1 = num_coeff[1]
    # b2 = num_coeff[2]
    #        ...    
    for i in range(0,N+1):
        
        b_i = dy.float64( num_coeff[i] ).extend_name(&#39;_b&#39; + str(i) )

        if i==0:
            y = b_i * sum_feedback
        else:
            y = y + b_i * z_[i-1]

    # y is the filter output   
    return y



#
# Control
#

def PID_controller(r, y, Ts, kp, ki = None, kd = None):
    &#34;&#34;&#34;Discrete-time PID-controller

    Parameters
    ----------
    r : SignalUserTemplate
        the reference signal
    y : SignalUserTemplate
        the measured plant output
    Ts : float
        the sampleing time
    kp : float
        the parameter kp (proportional)
    ki : float
        the parameter ki (integral)
    kd : float
        the parameter kd (differential)

    Returns
    -------
    SignalUserTemplate
        the control variable u

    &#34;&#34;&#34;
    Ts = dy.float64(Ts)

    # control error
    e = r - y

    # P
    u = kp * e

    # D
    if kd is not None:
        u = u + dy.diff(e) * kd / Ts

    # I
    if ki is not None:
        u = u + dy.sum(e) * ki * Ts

    return u</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="openrtdynamics2.lang.standard_library.PID_controller"><code class="name flex">
<span>def <span class="ident">PID_controller</span></span>(<span>r, y, Ts, kp, ki=None, kd=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Discrete-time PID-controller</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>r</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the reference signal</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the measured plant output</dd>
<dt><strong><code>Ts</code></strong> :&ensp;<code>float</code></dt>
<dd>the sampleing time</dd>
<dt><strong><code>kp</code></strong> :&ensp;<code>float</code></dt>
<dd>the parameter kp (proportional)</dd>
<dt><strong><code>ki</code></strong> :&ensp;<code>float</code></dt>
<dd>the parameter ki (integral)</dd>
<dt><strong><code>kd</code></strong> :&ensp;<code>float</code></dt>
<dd>the parameter kd (differential)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the control variable u</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PID_controller(r, y, Ts, kp, ki = None, kd = None):
    &#34;&#34;&#34;Discrete-time PID-controller

    Parameters
    ----------
    r : SignalUserTemplate
        the reference signal
    y : SignalUserTemplate
        the measured plant output
    Ts : float
        the sampleing time
    kp : float
        the parameter kp (proportional)
    ki : float
        the parameter ki (integral)
    kd : float
        the parameter kd (differential)

    Returns
    -------
    SignalUserTemplate
        the control variable u

    &#34;&#34;&#34;
    Ts = dy.float64(Ts)

    # control error
    e = r - y

    # P
    u = kp * e

    # D
    if kd is not None:
        u = u + dy.diff(e) * kd / Ts

    # I
    if ki is not None:
        u = u + dy.sum(e) * ki * Ts

    return u</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.boolean"><code class="name flex">
<span>def <span class="ident">boolean</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Cast anything to DataTypeBoolean</p>
<p>Convert the input value to a signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>SignalUserTemplate, int</code></dt>
<dd>the signal or a constant value to convert to a signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the signal of type boolean</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boolean(value):
    &#34;&#34;&#34;Cast anything to DataTypeBoolean

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, int
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type boolean

    &#34;&#34;&#34;
    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeBoolean(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.counter"><code class="name flex">
<span>def <span class="ident">counter</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic counter - the sampling index k</p>
<p>The integer output is increasing with each sampling instant by 1.
Counting starts at zero.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the integer output signal describing the sampling index k</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counter():
    &#34;&#34;&#34;Basic counter - the sampling index k

    The integer output is increasing with each sampling instant by 1.
    Counting starts at zero.

    Returns
    -------
    SignalUserTemplate
        the integer output signal describing the sampling index k

    &#34;&#34;&#34;

    if not &#39;counter&#39; in dy.get_system_context().components:
        # no counter has been defined in this system so far. Hence, create one.

        increase = dy.const(1, dy.DataTypeInt32(1) )
        cnt = dy.signal()
        tmp = dy.delay(cnt + increase)
        cnt &lt;&lt; tmp 

        tmp.set_name(&#39;shared_counter&#39;)

        # store the output signal of the counter as it might be used again. 
        dy.get_system_context().components[&#39;counter&#39;] = __Counter(tmp)

    else:
        # use the output of an already created counter
        tmp = dy.get_system_context().components[&#39;counter&#39;].output

    return tmp</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.counter_triggered"><code class="name flex">
<span>def <span class="ident">counter_triggered</span></span>(<span>upper_limit, stepwidth=None, initial_state=0, reset=None, reset_on_limit: bool = False, start_trigger=None, pause_trigger=None, auto_start: bool = True, no_delay: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A generic counter</p>
<p>Features:
- upper limit
- triggerable start/pause
- resetable
- dynamic adjustable step-size</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>upper_limit</code></strong> :&ensp;<code>int</code></dt>
<dd>the upper limit of the counter</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>int</code></dt>
<dd>the state after reset</dd>
<dt><strong><code>reset</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>reset the counter</dd>
<dt><strong><code>reset_on_limit</code></strong> :&ensp;<code>bool</code></dt>
<dd>reset counter once the upper limit is reached</dd>
<dt><strong><code>start_trigger</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>event to start counting</dd>
<dt><strong><code>pause_trigger</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>event to pause counting</dd>
<dt><strong><code>auto_start</code></strong> :&ensp;<code>bool</code></dt>
<dd>start counting automatically</dd>
<dt><strong><code>no_delay</code></strong> :&ensp;<code>bool</code></dt>
<dd>when True the new value of the counter is returned without delay</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the boolean output signal</dd>
<dt><code>SignalUserTemplate</code></dt>
<dd>event that fires when the upper limit of the counter is reached</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def counter_triggered( upper_limit, stepwidth=None, initial_state = 0, reset=None, reset_on_limit:bool=False, start_trigger=None, pause_trigger=None, auto_start:bool=True, no_delay:bool=False ):
    &#34;&#34;&#34;A generic counter

    Features:
    - upper limit
    - triggerable start/pause
    - resetable
    - dynamic adjustable step-size

    Parameters
    ----------

    upper_limit : int
        the upper limit of the counter
    initial_state : int
        the state after reset
    reset : SignalUserTemplate
        reset the counter
    reset_on_limit : bool
        reset counter once the upper limit is reached
    start_trigger : SignalUserTemplate
        event to start counting
    pause_trigger : SignalUserTemplate
        event to pause counting
    auto_start : bool
        start counting automatically
    no_delay : bool
        when True the new value of the counter is returned without delay 

    Returns
    -------
    SignalUserTemplate
        the boolean output signal 
    SignalUserTemplate
        event that fires when the upper limit of the counter is reached 
        
    &#34;&#34;&#34;

    if stepwidth is None:
        stepwidth = dy.int32(1)

    counter = dy.signal()

    reached_upper_limit = counter &gt;= dy.int32(upper_limit)

    if start_trigger is None:
        start_trigger = dy.boolean(0)

    # 
    if pause_trigger is not None: 
        activate_trigger = dy.logic_or(reached_upper_limit, pause_trigger)
    else:
        if not auto_start:
            activate_trigger = reached_upper_limit
        else:
            # when auto_start is active, continue counting after reset on reached_upper_limit
            activate_trigger = dy.boolean(0)


    # state for pause/counting
    paused =  dy.flipflop(activate_trigger=activate_trigger, disable_trigger=start_trigger, initial_state = not auto_start, no_delay=True).set_name(&#39;paused&#39;)

    # prevent counter increase
    stepwidth = dy.conditional_overwrite(stepwidth, paused, 0).set_name(&#39;stepwidth&#39;)

    # increase the counter until the end is reached
    new_counter = counter + dy.conditional_overwrite(stepwidth, reached_upper_limit, 0)

    if reset is not None:
        # reset in case this is requested
        new_counter = dy.conditional_overwrite(new_counter, reset, initial_state)

    if reset_on_limit:
        new_counter = dy.conditional_overwrite(new_counter, reached_upper_limit, initial_state)

    # introduce a state variable for the counter
    counter &lt;&lt; dy.delay( new_counter, initial_state=initial_state )

    if not no_delay:
        return counter, reached_upper_limit
    else:
        return new_counter, reached_upper_limit</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.delay"><code class="name flex">
<span>def <span class="ident">delay</span></span>(<span>u, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unit delay</p>
<p>Delay the input u by one sampling instant:</p>
<pre><code>y[k+1] = u[k], y[0] = initial_state
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input signal to delay</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the initial state (signal or constant value)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the one-step delayed input</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delay(u , initial_state = None):
    &#34;&#34;&#34;Unit delay

    Delay the input u by one sampling instant:

        y[k+1] = u[k], y[0] = initial_state

    Parameters
    ----------
    u : SignalUserTemplate
        the input signal to delay
    initial_state : SignalUserTemplate
        the initial state (signal or constant value)

    Returns
    -------
    SignalUserTemplate
        the one-step delayed input   

    &#34;&#34;&#34;

    if not isinstance( initial_state, SignalUserTemplate ):
        return dy.delay__( u, initial_state )

    else:

        event_on_first_sample = initial_event()

        delayed_input = dy.delay__( u, None )
        delayed_input = dy.conditional_overwrite( delayed_input, event_on_first_sample, initial_state )

        return delayed_input</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.diff"><code class="name flex">
<span>def <span class="ident">diff</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Discrete difference</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input signal</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>float, SignalUserTemplate</code></dt>
<dd>the initial state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<p>y = u[k] - u[k-1] </p>
<p>initial state</p>
<p>u[0] = initial_state
in case initial_state is not None
u[0] = 0
otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def diff(u : SignalUserTemplate, initial_state = None):
    &#34;&#34;&#34;Discrete difference

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    y = u[k] - u[k-1] 

    initial state

    u[0] = initial_state   in case initial_state is not None
    u[0] = 0               otherwise
    &#34;&#34;&#34;

    i = dy.delay( u, initial_state )
    y = dy.add( [ i, u ], [ -1, 1 ] )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.dtf_lowpass_1_order"><code class="name flex">
<span>def <span class="ident">dtf_lowpass_1_order</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, z_infinity)</span>
</code></dt>
<dd>
<div class="desc"><p>First-order discrete-time low pass filter</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<pre><code>            1 - z_infinity
    H (z) =  --------------
            z - z_infinity
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dtf_lowpass_1_order(u : SignalUserTemplate, z_infinity):
    &#34;&#34;&#34;First-order discrete-time low pass filter

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

                    1 - z_infinity
            H (z) =  --------------
                    z - z_infinity
    &#34;&#34;&#34;

    zinf = dy.float64( z_infinity )
    zinf_ = dy.float64( 1 ) - zinf

    y_delayed = dy.signal()
    y =  zinf * y_delayed + zinf_ * u

    y_delayed &lt;&lt; dy.delay(y)
    
    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.euler_integrator"><code class="name flex">
<span>def <span class="ident">euler_integrator</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, Ts, initial_state=0.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Euler (forward) integrator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input signal</dd>
<dt><strong><code>Ts</code></strong> :&ensp;<code>float</code></dt>
<dd>the sampling time</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>float, SignalUserTemplate</code></dt>
<dd>the initial state of the integrator</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<pre><code>y[k+1] = y[k] + Ts * u[k]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euler_integrator( u : SignalUserTemplate, Ts, initial_state = 0.0):
    &#34;&#34;&#34;Euler (forward) integrator

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    Ts : float
        the sampling time
    initial_state : float, SignalUserTemplate
        the initial state of the integrator

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

        y[k+1] = y[k] + Ts * u[k]
    &#34;&#34;&#34;

    yFb = dy.signal()

    if not isinstance( Ts, SignalUserTemplate ): 
        i = dy.add( [ yFb, u ], [ 1, Ts ] )
    else:
        i = yFb + Ts * u

    y = dy.delay( i, initial_state )

    yFb &lt;&lt; y

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.float64"><code class="name flex">
<span>def <span class="ident">float64</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Cast anything to DataTypeFloat64</p>
<p>Convert the input value to a signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>SignalUserTemplate, float</code></dt>
<dd>the signal or a constant value to convert to a signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the signal of type float64</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def float64(value):
    &#34;&#34;&#34;Cast anything to DataTypeFloat64

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, float
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type float64

    &#34;&#34;&#34;
    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeFloat64(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.initial_event"><code class="name flex">
<span>def <span class="ident">initial_event</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Emits an event on the first sampling instant after the reset of the system</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the signal of type boolean containing the event</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initial_event():
    &#34;&#34;&#34;Emits an event on the first sampling instant after the reset of the system

    Returns
    -------
    SignalUserTemplate
        the signal of type boolean containing the event
    &#34;&#34;&#34;

    # TODO: introduce caching like done for counter()

    return dy.counter() == int32(0)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.int32"><code class="name flex">
<span>def <span class="ident">int32</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"><p>Cast anything to DataTypeInt32</p>
<p>Convert the input value to a signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>SignalUserTemplate, int</code></dt>
<dd>the signal or a constant value to convert to a signal</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the signal of type int32</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int32(value):
    &#34;&#34;&#34;Cast anything to DataTypeInt32

    Convert the input value to a signal.

    Parameters
    ----------
    value : SignalUserTemplate, int
        the signal or a constant value to convert to a signal

    Returns
    -------
    SignalUserTemplate
        the signal of type int32

    &#34;&#34;&#34;

    if isinstance(  value, SignalUserTemplate ):
        # already a singal
        return value
    else:
        # create a new constant
        return dy.const(value, dy.DataTypeInt32(1) )</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>sequence_array, stepwidth=None, initial_state=0, reset=None, reset_on_end: bool = False, start_trigger=None, pause_trigger=None, auto_start: bool = True, no_delay: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Play a given sequence of samples</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sequence_array</code></strong> :&ensp;<code>list[float]</code></dt>
<dd>the sequence given as a list of values</dd>
<dt><strong><code>reset</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>reset playback and start from the beginning</dd>
<dt><strong><code>reset_on_end</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>reset playback once the end is reached (repetitive playback)</dd>
<dt><strong><code>start_trigger</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>event to start playback</dd>
<dt><strong><code>pause_trigger</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>event to pause playback</dd>
<dt><strong><code>auto_start</code></strong> :&ensp;<code>bool</code></dt>
<dd>start playback automatically</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the value obtained from sequence_array</dd>
<dt><code>SignalUserTemplate</code></dt>
<dd>the current position of playback (index of the currently issued sequence element)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play( sequence_array,  stepwidth=None, initial_state = 0, reset=None, reset_on_end:bool=False, start_trigger=None, pause_trigger=None, auto_start:bool=True, no_delay:bool=False ):
    &#34;&#34;&#34;Play a given sequence of samples

    Parameters
    ----------

    sequence_array : list[float]
        the sequence given as a list of values
    reset : SignalUserTemplate
        reset playback and start from the beginning
    reset_on_end : SignalUserTemplate
        reset playback once the end is reached (repetitive playback)
    start_trigger : SignalUserTemplate
        event to start playback
    pause_trigger : SignalUserTemplate
        event to pause playback
    auto_start : bool
        start playback automatically 


    Returns
    -------
    SignalUserTemplate
        the value obtained from sequence_array
    SignalUserTemplate
        the current position of playback (index of the currently issued sequence element)


    &#34;&#34;&#34;

    sequence_array_storage = dy.memory(datatype=dy.DataTypeFloat64(1), constant_array=sequence_array )

    # if prevent_initial_playback:
    #     initial_counter_state = np.size(sequence_array)
    # else:
        

    playback_index, _ = counter_triggered(
        upper_limit=np.size(sequence_array)-1, 
        stepwidth=stepwidth, initial_state=initial_state, 
        reset=reset, reset_on_limit=reset_on_end, 
        start_trigger=start_trigger, pause_trigger=pause_trigger, 
        auto_start=auto_start,
        no_delay=no_delay
    )

    # sample the given data
    sample = dy.memory_read(sequence_array_storage, playback_index)

    return sample, playback_index</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.rate_limit"><code class="name flex">
<span>def <span class="ident">rate_limit</span></span>(<span>u, Ts, lower_limit, upper_limit, initial_state=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Rate limiter</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>Ts</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>sampling time (constant)</dd>
<dt><strong><code>lower_limit</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>lower rate limit</dd>
<dt><strong><code>upper_limit</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>upper rate limit</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rate_limit( u, Ts, lower_limit, upper_limit, initial_state = 0 ):
    &#34;&#34;&#34;Rate limiter

    Parameters
    ----------

    Ts : SignalUserTemplate
        sampling time (constant)
    lower_limit : SignalUserTemplate
        lower rate limit
    upper_limit : SignalUserTemplate
        upper rate limit

    Returns
    -------
    SignalUserTemplate
        the output signal    

    &#34;&#34;&#34;

    Ts_ = float64(Ts)

    y = dy.signal()

    omega = u - y
    omega_sat = saturate(omega, float64(lower_limit) * Ts_, float64(upper_limit) * Ts_)
    y &lt;&lt; euler_integrator( omega_sat, 1, initial_state=initial_state)

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.sample_and_hold"><code class="name flex">
<span>def <span class="ident">sample_and_hold</span></span>(<span>u, event, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sample &amp; hold</p>
<p>Samples the input when event is true and hold this value for the proceeding time instants. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input to sample</dd>
<dt><strong><code>event</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the event on which sampling of the input is performed</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the initial output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the sampled input</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_and_hold(u, event, initial_state = None):
    &#34;&#34;&#34;Sample &amp; hold

    Samples the input when event is true and hold this value for the proceeding time instants. 

    Parameters
    ----------
    u : SignalUserTemplate
        the input to sample
    event : SignalUserTemplate
        the event on which sampling of the input is performed
    initial_state : SignalUserTemplate
        the initial output

    Returns
    -------
    SignalUserTemplate
        the sampled input   

    &#34;&#34;&#34;

    # NOTE: this could be implemented in a more comp. efficient way directly in C in block_prototypes.py

    y = dy.signal()

    delayed_y = delay( y, initial_state )
    y &lt;&lt; dy.conditional_overwrite( delayed_y, event, u )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.saturate"><code class="name flex">
<span>def <span class="ident">saturate</span></span>(<span>u, lower_limit=None, upper_limit=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Saturation</p>
<p>The output is the saturated input</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>lower_limit</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>lower bound for the output</dd>
<dt><strong><code>upper_limit</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>upper bound for the output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the integer output signal</dd>
</dl>
<h2 id="details">Details</h2>
<pre><code>    { lower_limit   for u &lt; lower_limit
y = { u             otherwise
    { upper_limit  for u &gt; upper_limit
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def saturate(u, lower_limit = None, upper_limit = None):
    &#34;&#34;&#34;Saturation

    The output is the saturated input

    Parameters
    ----------

    lower_limit : SignalUserTemplate
        lower bound for the output 
    upper_limit : SignalUserTemplate
        upper bound for the output

    Returns
    -------
    SignalUserTemplate
        the integer output signal 

    Details
    -------
            { lower_limit   for u &lt; lower_limit
        y = { u             otherwise
            { upper_limit  for u &gt; upper_limit
    &#34;&#34;&#34;

    y = u

    if lower_limit is not None:
        y = dy.conditional_overwrite( y, y &lt; float64(lower_limit), lower_limit )
    
    if upper_limit is not None:
        y = dy.conditional_overwrite( y, y &gt; float64(upper_limit), upper_limit )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.signal_impulse"><code class="name flex">
<span>def <span class="ident">signal_impulse</span></span>(<span>k_event)</span>
</code></dt>
<dd>
<div class="desc"><p>Pulse signal generator</p>
<p>Generates a unique pulse at the sampling index k_event.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k_event</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the sampling index at which the pulse appears</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_impulse(k_event):
    &#34;&#34;&#34;Pulse signal generator

    Generates a unique pulse at the sampling index k_event.

    Parameters
    ----------
    k_event : SignalUserTemplate
        the sampling index at which the pulse appears


    Returns
    -------
    SignalUserTemplate
        the output signal
    &#34;&#34;&#34;

    if k_event &lt; 0:
        raise BaseException(&#39;The sampling index for the event is invalid (k_event &lt; 0)&#39;)

    k = dy.counter()
    pulse_signal = dy.int32(k_event) == k

    return pulse_signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.signal_periodic_impulse"><code class="name flex">
<span>def <span class="ident">signal_periodic_impulse</span></span>(<span>period, phase)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for periodic pulses</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>singal or constant describing the period in samples at which the pulses are generated</dd>
<dt><strong><code>phase</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>singal or constant describing the phase in samples at which the pulses are generated</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_periodic_impulse(period, phase):
    &#34;&#34;&#34;Signal generator for periodic pulses

    Parameters
    ----------

    period : SignalUserTemplate
        singal or constant describing the period in samples at which the pulses are generated
    phase : SignalUserTemplate
        singal or constant describing the phase in samples at which the pulses are generated

    Returns
    -------
    SignalUserTemplate
        the output signal

    &#34;&#34;&#34;

    k, trigger = counter_triggered( upper_limit=dy.int32(period) - dy.int32(1), reset_on_limit=True )
    pulse_signal = dy.int32(phase) == k

    return pulse_signal</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.signal_ramp"><code class="name flex">
<span>def <span class="ident">signal_ramp</span></span>(<span>k_start)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for a ramp signal</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k_start</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the sampling index as returned by counter() at which the ramp starts increasing.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="details">Details</h2>
<pre><code>y[k] = { 0           for k &lt;  k_start
       { k-k_start   for k &gt;= k_start
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_ramp(k_start):
    &#34;&#34;&#34;Signal generator for a ramp signal

    Parameters
    ----------
    k_start : SignalUserTemplate
        the sampling index as returned by counter() at which the ramp starts increasing.

    Returns
    -------
    SignalUserTemplate
        the output signal

    Details
    -------

        y[k] = { 0           for k &lt;  k_start
               { k-k_start   for k &gt;= k_start
    &#34;&#34;&#34;
    k = dy.counter()
    active = dy.int32(k_start) &lt;= k

    linearRise = dy.convert( (k - dy.int32(k_start) ), dy.DataTypeFloat64(1) )
    activation = dy.convert( active, dy.DataTypeFloat64(1) )

    return activation * linearRise</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.signal_sinus"><code class="name flex">
<span>def <span class="ident">signal_sinus</span></span>(<span>N_period: int = 100, phi=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Sine wave generator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>N_period</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>period in sampling instants (type: constant integer)</dd>
<dt><strong><code>phi</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>phase shift (signal)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="details">Details</h2>
<p>The output is computed as follows:</p>
<p>y = sin( k * (1 / N_period * 2 * pi) + phi )</p>
<p>k - is the sampling index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_sinus(N_period : int = 100, phi = None):
    &#34;&#34;&#34;Sine wave generator

    Parameters
    ----------
    N_period : SignalUserTemplate
        period in sampling instants (type: constant integer)
    phi : SignalUserTemplate
        phase shift (signal)

    Returns
    -------
    SignalUserTemplate
        the output signal

    Details
    -------
    The output is computed as follows:

    y = sin( k * (1 / N_period * 2 * pi) + phi )

    k - is the sampling index

    &#34;&#34;&#34;

    if N_period &lt;= 0:
        raise BaseException(&#39;N_period &lt;= 0&#39;)

    if phi is None:
        phi = dy.float64(0.0)

    i, _ = dy.counter_triggered( upper_limit=N_period-1, reset_on_limit=True )
    y = dy.sin( i * dy.float64(1/N_period * 2*math.pi) + phi )

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.signal_square"><code class="name flex">
<span>def <span class="ident">signal_square</span></span>(<span>period, phase)</span>
</code></dt>
<dd>
<div class="desc"><p>Square wave signal generator</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>singal or constant describing the period in samples at which the edges of the square are placed</dd>
<dt><strong><code>phase</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>singal or constant describing the phase in samples at which the edges of the square are placed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_square(period, phase):
    &#34;&#34;&#34;Square wave signal generator

    Parameters
    ----------

    period : SignalUserTemplate
        singal or constant describing the period in samples at which the edges of the square are placed
    phase : SignalUserTemplate
        singal or constant describing the phase in samples at which the edges of the square are placed

    Returns
    -------
    SignalUserTemplate
        the output signal

    &#34;&#34;&#34;
    trigger = signal_periodic_impulse(period, phase)


    # k, trigger = counter_triggered( upper_limit=dy.int32(period) - dy.int32(1), reset_on_limit=True )

    state, activate, deactivate = toggle(trigger, no_delay=True)

    return state, activate, deactivate</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.signal_step"><code class="name flex">
<span>def <span class="ident">signal_step</span></span>(<span>k_step)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for a step signal</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>k_step</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the sampling index as returned by counter() at which the step appears.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_step(k_step):
    &#34;&#34;&#34;Signal generator for a step signal

    Parameters
    ----------
    k_step : SignalUserTemplate
        the sampling index as returned by counter() at which the step appears.

    Returns
    -------
    SignalUserTemplate
        the output signal
    &#34;&#34;&#34;
    k = dy.counter()
    y = dy.int32(k_step) &lt;= k

    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.signal_step_wise_sequence"><code class="name flex">
<span>def <span class="ident">signal_step_wise_sequence</span></span>(<span>time_instance_indices, values, time_scale=None, counter=None, reset=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Signal generator for a step-wise changeing signal</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>time_instance_indices</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>an array of sampling instants at which the signal changes its values</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>List[float]</code></dt>
<dd>an array of values; must have one more element than time_instance_indices</dd>
<dt><strong><code>time_scale</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>multiplies all elements of time_instance_indices by the given factor (optional)</dd>
<dt><strong><code>counter</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>an alternative sample counter (optional), default: counter=dy.counter()</dd>
<dt><strong><code>reset</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>boolean signal to reset the sequence (optional)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code>time_instance_indices = [      50, 100, 150, 250, 300, 350, 400,  450, 500  ]
values                = [ 0, -1.0,   0, 1.0,  0, -1.0, 0,   0.2, -0.2, 0   ]

v = step_wise_sequence( time_instance_indices, values )
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_step_wise_sequence( time_instance_indices, values, time_scale=None, counter=None, reset=None ):
    &#34;&#34;&#34;Signal generator for a step-wise changeing signal

    Parameters
    ----------

    time_instance_indices : List[int]
        an array of sampling instants at which the signal changes its values
    values : List[float]
        an array of values; must have one more element than time_instance_indices
    time_scale : SignalUserTemplate
        multiplies all elements of time_instance_indices by the given factor (optional)
    counter : SignalUserTemplate
        an alternative sample counter (optional), default: counter=dy.counter()
    reset : SignalUserTemplate
        boolean signal to reset the sequence (optional)

    Returns
    -------
    SignalUserTemplate
        the output signal

    Example
    -------

        time_instance_indices = [      50, 100, 150, 250, 300, 350, 400,  450, 500  ]
        values                = [ 0, -1.0,   0, 1.0,  0, -1.0, 0,   0.2, -0.2, 0   ]

        v = step_wise_sequence( time_instance_indices, values )
    &#34;&#34;&#34;
    
    if len(values) - 1 != len(time_instance_indices):
        raise BaseException( &#34;len(values) - 1 != len(time_instance_indices)&#34; )

    if counter is None:
        counter = dy.counter()

    indices_mem = dy.memory(datatype=dy.DataTypeInt32(1),   constant_array=time_instance_indices )
    values_mem  = dy.memory(datatype=dy.DataTypeFloat64(1), constant_array=values )

    current_index = dy.signal()

    current_time_index_to_check = dy.memory_read( indices_mem, current_index )

    # scale time
    if time_scale is not None:
        index_to_check = time_scale * current_time_index_to_check
    else:
        index_to_check = current_time_index_to_check

    # check wether to step to the next sample
    increase_index = dy.int32(0)
    increase_index = dy.conditional_overwrite(increase_index, counter &gt;= index_to_check, dy.int32(1) )

    cnt_, _ = dy.counter_triggered(upper_limit=len(time_instance_indices), stepwidth=increase_index, reset=reset )
    current_index &lt;&lt; cnt_
    val = dy.memory_read(values_mem, current_index)

    return val</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.sum"><code class="name flex">
<span>def <span class="ident">sum</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=0, no_delay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulative sum</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input signal</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>float, SignalUserTemplate</code></dt>
<dd>the initial state</dd>
<dt><strong><code>no_delay</code></strong> :&ensp;<code>bool</code></dt>
<dd>when true the output is not delayed</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<p>The difference equation</p>
<pre><code>y[k+1] = y[k] + u[k]
</code></pre>
<p>is evaluated. The return value is either</p>
<pre><code>y[k]   by default or when no_delay == False
</code></pre>
<p>or</p>
<pre><code>y[k+1] in case no_delay == True .
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum(u : SignalUserTemplate, initial_state=0, no_delay=False):
    &#34;&#34;&#34;Accumulative sum

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state
    no_delay : bool
        when true the output is not delayed

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    The difference equation

        y[k+1] = y[k] + u[k]

    is evaluated. The return value is either

        y[k]   by default or when no_delay == False
    or

        y[k+1] in case no_delay == True .
    &#34;&#34;&#34;

    y_k = dy.signal()
    
    y_kp1 = y_k + u

    y_k &lt;&lt; dy.delay(y_kp1, initial_state=initial_state)

    if no_delay:
        return y_kp1
    else:
        return y_k</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.sum2"><code class="name flex">
<span>def <span class="ident">sum2</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, initial_state=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Accumulative sum</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input signal</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>float, SignalUserTemplate</code></dt>
<dd>the initial state</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<p>The difference equation</p>
<pre><code>y[k+1] = y[k] + u[k]
</code></pre>
<p>is evaluated. The return values are</p>
<pre><code>y[k], y[k+1]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sum2(u : SignalUserTemplate, initial_state=0):
    &#34;&#34;&#34;Accumulative sum

    Parameters
    ----------

    u : SignalUserTemplate
        the input signal
    initial_state : float, SignalUserTemplate
        the initial state

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    The difference equation

        y[k+1] = y[k] + u[k]

    is evaluated. The return values are

        y[k], y[k+1]
    &#34;&#34;&#34;

    y_k = dy.signal()
    
    y_kp1 = y_k + u

    y_k &lt;&lt; dy.delay(y_kp1, initial_state=initial_state)

    return y_k, y_kp1</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.toggle"><code class="name flex">
<span>def <span class="ident">toggle</span></span>(<span>trigger, initial_state=False, no_delay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Toggle a state based on an event</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>period</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the signal to trigger a state change</dd>
<dt><strong><code>initial_state</code></strong> :&ensp;<code>int</code></dt>
<dd>the initial state</dd>
<dt><strong><code>no_delay</code></strong> :&ensp;<code>bool</code></dt>
<dd>when true the toggle immediately reacts to a trigger (default: false)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the boolean state signal</dd>
<dt><code>SignalUserTemplate</code></dt>
<dd>the event for activation</dd>
<dt><code>SignalUserTemplate</code></dt>
<dd>the event for deactivation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle(trigger, initial_state=False, no_delay=False):
    &#34;&#34;&#34;Toggle a state based on an event

    Parameters
    ----------

    period : SignalUserTemplate
        the signal to trigger a state change
    initial_state : int
        the initial state
    no_delay : bool
        when true the toggle immediately reacts to a trigger (default: false)

    Returns
    -------
    SignalUserTemplate
        the boolean state signal

    SignalUserTemplate
        the event for activation
    SignalUserTemplate
        the event for deactivation

    

    &#34;&#34;&#34;

    state = dy.signal()

    activate   = dy.logic_and( dy.logic_not( state ), trigger )
    deactivate = dy.logic_and( trigger , state)

    state_ = dy.flipflop( activate, deactivate, 
                            initial_state = 0, 
                            no_delay=no_delay )

    if not no_delay:
        state &lt;&lt; state_
    else:
        state &lt;&lt; dy.delay(state_)


    return state_, activate, deactivate</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.transfer_function_discrete"><code class="name flex">
<span>def <span class="ident">transfer_function_discrete</span></span>(<span>u: <a title="openrtdynamics2.lang.signal_interface.SignalUserTemplate" href="signal_interface.html#openrtdynamics2.lang.signal_interface.SignalUserTemplate">SignalUserTemplate</a>, num_coeff: List[float], den_coeff: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>Discrete time transfer function</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>u</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input signal</dd>
<dt><strong><code>num_coeff</code></strong> :&ensp;<code>List[float]</code></dt>
<dd>a list of numerator coefficients of the transfer function</dd>
<dt><strong><code>den_coeff</code></strong> :&ensp;<code>List[float]</code></dt>
<dd>a list of denominator coefficients of the transfer function</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal of the filter</dd>
</dl>
<h2 id="details">Details:</h2>
<p>This filter realizes a discrete-time transfer function by using 'direct form II'
c.f. <a href="https://en.wikipedia.org/wiki/Digital_filter">https://en.wikipedia.org/wiki/Digital_filter</a> .</p>
<pre><code>        b0 + b1 z^-1 + b2 z^-2 + ... + bN z^-N
H(z) = ----------------------------------------
        1 + a1 z^-1 + a2 z^-2 + ... + aM z^-M
</code></pre>
<p>The coefficient vectors num_coeff and den_coeff describe the numerator and
denominator polynomials, respectively, and are defined as follows:</p>
<pre><code>num_coeff = [b0, b1, .., bN]
den_coeff = [a1, a2, ... aM] .
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_function_discrete(u : SignalUserTemplate, num_coeff : t.List[float], den_coeff : t.List[float] ):

    &#34;&#34;&#34;Discrete time transfer function

    Parameters
    ----------
    u : SignalUserTemplate
        the input signal
    num_coeff : List[float]
        a list of numerator coefficients of the transfer function
    den_coeff : List[float]
        a list of denominator coefficients of the transfer function

    Returns
    -------
    SignalUserTemplate
        the output signal of the filter

    Details:
    --------

    This filter realizes a discrete-time transfer function by using &#39;direct form II&#39;
    c.f. https://en.wikipedia.org/wiki/Digital_filter .

                b0 + b1 z^-1 + b2 z^-2 + ... + bN z^-N
        H(z) = ----------------------------------------
                1 + a1 z^-1 + a2 z^-2 + ... + aM z^-M

    The coefficient vectors num_coeff and den_coeff describe the numerator and 
    denominator polynomials, respectively, and are defined as follows:

        num_coeff = [b0, b1, .., bN]
        den_coeff = [a1, a2, ... aM] .
        
    &#34;&#34;&#34;


    # get filter order
    N = len(num_coeff)-1

    # feedback start signal
    z_pre = dy.signal()

    # array to store state signals
    z_ = []

    # create delay chain
    z_iterate = z_pre
    for i in range(0,N):

        z_iterate = dy.delay( z_iterate ) .extend_name(&#39;_z&#39; + str(i) )
        z_.append( z_iterate ) 


    # build feedback path
    #
    # a1 = den_coeff[0]
    # a2 = den_coeff[1]
    # a3 = den_coeff[2]
    #        ...
    sum_feedback = u
    for i in range(0,N):

        a_ip1 = dy.float64( den_coeff[i] ).extend_name(&#39;_a&#39; + str(i+1) )

        sum_feedback = sum_feedback - a_ip1 * z_[i]

    sum_feedback.extend_name(&#39;_i&#39;)


    # close the feedback loop
    z_pre &lt;&lt; sum_feedback

    # build output path
    #
    # b0 = num_coeff[0]
    # b1 = num_coeff[1]
    # b2 = num_coeff[2]
    #        ...    
    for i in range(0,N+1):
        
        b_i = dy.float64( num_coeff[i] ).extend_name(&#39;_b&#39; + str(i) )

        if i==0:
            y = b_i * sum_feedback
        else:
            y = y + b_i * z_[i-1]

    # y is the filter output   
    return y</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.standard_library.unwrap_angle"><code class="name flex">
<span>def <span class="ident">unwrap_angle</span></span>(<span>angle, normalize_around_zero=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unwrap an angle</p>
<p>Unwrap and normalize the input angle to the range </p>
<pre><code>   [0, 2*pi[     in case normalize_around_zero == false
or [-pi, pi]     in case normalize_around_zero == true
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>angle</code></strong> :&ensp;<code>SignalUserTemplate</code></dt>
<dd>the input signal (angle in radians)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SignalUserTemplate</code></dt>
<dd>the output signal</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unwrap_angle(angle, normalize_around_zero = False):
    &#34;&#34;&#34;Unwrap an angle

    Unwrap and normalize the input angle to the range 

           [0, 2*pi[     in case normalize_around_zero == false
        or [-pi, pi]     in case normalize_around_zero == true


    Parameters
    ----------

    angle : SignalUserTemplate
        the input signal (angle in radians)

    Returns
    -------
    SignalUserTemplate
        the output signal   

    &#34;&#34;&#34;

    def normalize_around_zero(angle):
        &#34;&#34;&#34;
            Normalize an angle

            Normalize an angle to a range [-pi, pi]

            Important: the assumed range for the input is - 2*pi &lt;= angle &lt;= 2*p
        &#34;&#34;&#34;

        tmp = angle            + dy.conditional_overwrite( dy.float64(0), angle &lt;= float64(-math.pi), 2*math.pi )
        normalized_angle = tmp + dy.conditional_overwrite( dy.float64(0), angle &gt; float64(math.pi), -2*math.pi )

        return normalized_angle

    #
    #
    angle_ = dy.fmod(angle, dy.float64(2*math.pi) )

    unwrapped_angle = angle_ + dy.conditional_overwrite( dy.float64(0), angle_ &lt; float64(0), 2*math.pi )

    if normalize_around_zero:
        return normalize_around_zero(unwrapped_angle)
    else:
        return unwrapped_angle</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openrtdynamics2.lang" href="index.html">openrtdynamics2.lang</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="openrtdynamics2.lang.standard_library.PID_controller" href="#openrtdynamics2.lang.standard_library.PID_controller">PID_controller</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.boolean" href="#openrtdynamics2.lang.standard_library.boolean">boolean</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.counter" href="#openrtdynamics2.lang.standard_library.counter">counter</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.counter_triggered" href="#openrtdynamics2.lang.standard_library.counter_triggered">counter_triggered</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.delay" href="#openrtdynamics2.lang.standard_library.delay">delay</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.diff" href="#openrtdynamics2.lang.standard_library.diff">diff</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.dtf_lowpass_1_order" href="#openrtdynamics2.lang.standard_library.dtf_lowpass_1_order">dtf_lowpass_1_order</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.euler_integrator" href="#openrtdynamics2.lang.standard_library.euler_integrator">euler_integrator</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.float64" href="#openrtdynamics2.lang.standard_library.float64">float64</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.initial_event" href="#openrtdynamics2.lang.standard_library.initial_event">initial_event</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.int32" href="#openrtdynamics2.lang.standard_library.int32">int32</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.play" href="#openrtdynamics2.lang.standard_library.play">play</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.rate_limit" href="#openrtdynamics2.lang.standard_library.rate_limit">rate_limit</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.sample_and_hold" href="#openrtdynamics2.lang.standard_library.sample_and_hold">sample_and_hold</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.saturate" href="#openrtdynamics2.lang.standard_library.saturate">saturate</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.signal_impulse" href="#openrtdynamics2.lang.standard_library.signal_impulse">signal_impulse</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.signal_periodic_impulse" href="#openrtdynamics2.lang.standard_library.signal_periodic_impulse">signal_periodic_impulse</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.signal_ramp" href="#openrtdynamics2.lang.standard_library.signal_ramp">signal_ramp</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.signal_sinus" href="#openrtdynamics2.lang.standard_library.signal_sinus">signal_sinus</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.signal_square" href="#openrtdynamics2.lang.standard_library.signal_square">signal_square</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.signal_step" href="#openrtdynamics2.lang.standard_library.signal_step">signal_step</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.signal_step_wise_sequence" href="#openrtdynamics2.lang.standard_library.signal_step_wise_sequence">signal_step_wise_sequence</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.sum" href="#openrtdynamics2.lang.standard_library.sum">sum</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.sum2" href="#openrtdynamics2.lang.standard_library.sum2">sum2</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.toggle" href="#openrtdynamics2.lang.standard_library.toggle">toggle</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.transfer_function_discrete" href="#openrtdynamics2.lang.standard_library.transfer_function_discrete">transfer_function_discrete</a></code></li>
<li><code><a title="openrtdynamics2.lang.standard_library.unwrap_angle" href="#openrtdynamics2.lang.standard_library.unwrap_angle">unwrap_angle</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>