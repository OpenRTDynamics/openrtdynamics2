<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>openrtdynamics2.lang.block_prototypes_subsystems API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openrtdynamics2.lang.block_prototypes_subsystems</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .diagram_core.system import System
from .diagram_core import datatypes as dt
from .diagram_core.signal_network.signals import Signal
from .diagram_core import code_generation_helper as cgh
from . import block_interface as bi

from typing import Dict, List





#
# Subsystem prototypes
#

class GenericSubsystem(bi.BlockPrototype):
    &#34;&#34;&#34;
        Include a sub-system by passing a manifest

        - sim - the simulation this block is embedded into

        parameters required only in case the subsystem is already defined (e.g. loaded from a library):

        - manifest           - the manifest of the subsystem to include (optional, might be handed over by init())
        - inputSignals       - the inputs to the subsystem 
        - N_outputs          - prepare a number of nOutputs (optional in case a manifest is given)
        - embedded_subsystem - the system to embed (optional in case a manifest to an already compiled subsystem is given, NOT IMPLEMENTED)

        Note: the number of outputs must be defined either by N_outputs or by a manifest

    &#34;&#34;&#34;
    def __init__(self, sim : System = None, manifest=None, inputSignals=None, N_outputs = None, embedded_subsystem=None ):

        self.manifest = manifest
        self.inputSignals = inputSignals
        self.sim = sim
        self.Noutputs = N_outputs
        self._embedded_subsystem = embedded_subsystem

        if manifest is not None:
            if N_outputs is None:
                self.Noutputs = self.manifest.number_of_default_ouputs
            else:
                raise BaseException(&#34;N_outputs and a manifest specified at the same time&#34;)

        # output signals that were created by sth. ourside of this prototype
        # and that need to be connected to the actual outputs when init() is called.
        self.anonymous_output_signals = None

        # optional (in case this block is in charge of putting the code for the subsystem)
        self.compileResult = None

        # init super class
        bi.BlockPrototype.__init__(self, self.sim, N_outputs = self.Noutputs)

        # Note: the inputSignals are not defined when subsystems are pre-defined in the code
        # but are automatically placed and connected by the compiler during compilation

        # check if it is already possible to init this prototype
        # (in case all requred information is available)
        if inputSignals is not None and manifest is not None:
            self.init()

        # configure datatype inheritance for the outputs signals
        for i in range(0, len( embedded_subsystem.primary_outputs )):

            output_signal_of_embedding_block = self.outputs[i]
            output_signal_of_subsystem = embedded_subsystem.primary_outputs[i]

            output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

    @property
    def embedded_subsystem(self):
        &#34;&#34;&#34;
            Return the system that is embedded (in case it was provided, returns None otherwise)
        &#34;&#34;&#34;

        return self._embedded_subsystem

    def set_anonymous_output_signal_to_connect(self, anonymous_output_signals):
        &#34;&#34;&#34;
            store a list of anonymous signals to connect to the outputs of the subsystems
            after running the post_compile_callback
        &#34;&#34;&#34;
        # List of raw signals 
        self.anonymous_output_signals = anonymous_output_signals

    def compile_callback_all_subsystems_compiled(self):

        embedded_system = self._embedded_subsystem
        #
        # continue init as now all subsystems are compiled and the compile results and the manifest of
        # the system to compile is available.
        #
        self.init(embedded_system.compile_result.manifest, embedded_system.compile_result, embedded_system.compile_result.inputSignals)

    # post_compile_callback (called after the subsystem to embed was compiled)
    def init(self, manifest, compileResult, inputSignals):
        &#34;&#34;&#34;
            This is a second phase initialization of this subsystem block 
            (to be called by compile_callback_all_subsystems_compiled())

            This function shall be called when the subsystem to embed is compiled
            after the instance of &#39;GenericSubsystem&#39; is created. This way, it is possible
            to add blocks embeddeding sub-systems without haveing these subsystems to be
            already compiled.

            Optionally, the system this block belongs to can be set.

            manifest       - the system manifest of the subsystem to embed
            compileResults - the compile results of the subsystem to embed
            inputSignals   - input signals to the subsystem to embed (links comming from an upper-level subsystem)

        &#34;&#34;&#34;        

        #
        #    set the manifest of the subsystem
        #
        if self.manifest is not None:
            raise BaseException(&#34;cannot call this function as the subsystem&#39;s manifest was already defined in the constructor.&#34;)

        self.manifest = manifest

        #
        #    Set the compilation result of the embedded system (if available)
        #
        self.compileResult = compileResult

        #
        #    connect the inputs (coming from the upper-level system)
        #

        if self.inputSignals is not None:
            raise BaseException(&#34;The subsystem&#39;s inputSignals were already specified in the constructor.&#34;)

        self.inputSignals = inputSignals



        def collectDependingSignals(signals, manifestFunctionInputs):
            # collect all depending input signals (that are needed to calculate the output) in a list
            # MOVE TO A FUNCTION. MAYBE MOVE TO MANIFEST.PY
            dependingInputs = []
            for i in range( len(manifestFunctionInputs[&#39;names&#39;]) ):

                dependingInput_name = manifestFunctionInputs[&#39;names&#39;][i]
                dependingInput_type = manifestFunctionInputs[&#39;types&#39;][i]
                dependingInput_cpptype = manifestFunctionInputs[&#39;cpptypes&#39;][i]

                # TODO: CHECK FOR FAILING LOOKUP
                signal = signals[ dependingInput_name ]

                # check datatype
                if not signal.getDatatype().cpp_datatype_string == dependingInput_cpptype:
                    raise BaseException(&#39;datatype does not match the one specified in the manifest. (&#39; + (dependingInput_cpptype) + &#39; is required in the manifest)&#39; )

                # append signal
                dependingInputs.append( signal ) 

            return dependingInputs



        # verify the number of outputs of the embedded system
        number_of_outputs_as_described_by_manifest = self.manifest.number_of_default_ouputs

        if not number_of_outputs_as_described_by_manifest == self.Noutputs:
            BaseException(&#34;missmatch in the number of outputs&#34;)

        # get the output datatypes of the embedded system
        self.outputTypes = self.manifest.io_outputs[&#39;calculate_output&#39;][&#39;types&#39;]  


        if self.compileResult is None:
            # collect all depending input signals (that are needed to calculate the output) in a list
            self.inputsToCalculateOutputs = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;calculate_output&#39;] )

            # collect all inputs required to perform the state update
            self.inputsToUpdateStates = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;state_update&#39;] )

        else:
            # use the available compile results to get the I/O signals
            # in this case, self.inputSignals shall be a list of signals. The order
            # shall match the signal order in self.compileResults.inputSignals

            self.inputsToCalculateOutputs = self.compileResult.simulationInputSignalsToCalculateOutputs
            self.inputsToUpdateStates = self.compileResult.simulationInputSignalsToUpdateStates

            

        # combine all inputs to a list
        self.allInputs = list()

        self.allInputs.extend( self.inputsToCalculateOutputs )
        self.allInputs.extend( self.inputsToUpdateStates )

        #
        # now initialize the propotype
        #

        # define the inputs
        self.update_input_config( self.allInputs )

        # connect the outputs signals
        if self.anonymous_output_signals is not None:

            print(&#34; -- Nesting block: connecting anonymous signals -- &#34;)

            Ns = len(self.outputSignals)

            if not Ns == len(  self.anonymous_output_signals ):
                raise BaseException(&#34; missmatch in the number of output signals&#34;)

            for i in range(0,Ns):
                
                s_ananon = self.anonymous_output_signals[i]
                s_source = self.outputSignals[i]

                print(&#34;connecting the output &#34; + s_ananon.toStr() + &#34; of the embedding block&#34;)
                s_ananon.setequal( s_source )



        # for code generation
        self.instanceVarname = self.getUniqueVarnamePrefix() + &#39;_subsystem_&#39; + self.manifest.API_name


    def config_request_define_output_types(self, inputTypes):

        # the datatypes are fixed in the manifest 
        return self.outputTypes        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):

        # NOTE: This is a simplified veriant so far.. no dependence on the given &#39;outputSignal&#39;
        #       (Every output depends on every signal in self.inputsToCalculateOutputs)

        # TODO: 6.10.19 implement this in a more granular way.
        # also use self.compileResults to get those information

        return self.inputsToCalculateOutputs

    def config_request_define_state_update_input_dependencies(self, outputSignal):
 
        # return a list of input signals that are required to update the states
        return self.inputsToUpdateStates



    def codegen_addToNamespace(self, language):
        lines = &#39;&#39;

        # putting code for subsystems is performed using execution commands

        return lines

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            lines = &#39;// instance of &#39; + self.manifest.API_name + &#39;\n&#39;
            lines += self.manifest.API_name + &#39; &#39; + self.instanceVarname + &#39;;\n&#39;

            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:
            return self.instanceVarname + &#39;.&#39; + self.manifest.getAPIFunctionName(&#39;reset&#39;) +  &#39;();\n&#39;


    def generate_code_init(self, language):
        pass


    def generate_code_destruct(self, language):
        pass


    # helper fn to build code
    def generate_code_call_OutputFunction(self, instanceVarname, manifest, language):
        return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;calculate_output&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.outputs + self.inputsToCalculateOutputs) + &#39;);\n&#39;

    # helper fn to build code
    def generate_code_call_UpdateFunction(self, instanceVarname, manifest, language):
        return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;state_update&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.inputsToUpdateStates) + &#39;);\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = &#39;&#39;
            
            #
            # TODO: 2.5.2020: concept: how to compute only the nescessary signals?
            #








            #
            # REWORK: introduce call to fn(Inputs &amp; inputs, Outputs &amp; outputs)
            # and remove the prev. style
            #

            for s in self.outputs: # for each output of the subsystem reservate a variable
                lines += cgh.define_variable_line( s ) 

                if s not in signals:
                    lines += &#39;// NOTE: unused output signal&#39; + s.name + &#39;\n&#39;
                else:
                    lines += &#39;&#39;                

            lines += self.generate_code_call_OutputFunction(self.instanceVarname, self.manifest, language)

        return lines

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            # input to this call are the signals in self.inputsToUpdateStates
            return self.generate_code_call_UpdateFunction(self.instanceVarname, self.manifest, language)

















#
# helper functions for both SingleSubsystemEmbedder and XX
#

def setup_output_datatype_inheritance( normal_outputs_of_embedding_block, subsystem_prototype ):
    # inherit output datatypes of this block from the embedded subsystem described by subsystem_prototype

    for i in range(0, len(normal_outputs_of_embedding_block) ):

        output_signal_of_embedding_block = normal_outputs_of_embedding_block[i]
        output_signal_of_subsystem = subsystem_prototype.outputs[i]
        output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

    return


class OutputMapEmbeddingBlockToSubsystem():

    def __init__(self, normal_outputs_of_embedding_block, subsystem_prototype):

        self._output_signal_mapping, self._output_signal_index_mapping = self.create_output_mapping_table(normal_outputs_of_embedding_block, subsystem_prototype )


    def create_output_mapping_table(self, normal_outputs_of_embedding_block, subsystem_prototype ):
        # output signal mapping: map each output of SingleSubsystemEmbedder to an output of the subsystem
        output_signal_mapping = {}

        # map output signal of embedding block to output index of the embedded block
        output_signal_index_mapping = {}

        for i in range(0, len(normal_outputs_of_embedding_block) ):
            # fill in mapping table
            output_signal_mapping[ normal_outputs_of_embedding_block[i] ] = subsystem_prototype.outputs[i]
            output_signal_index_mapping[ normal_outputs_of_embedding_block[i] ] = i



        return output_signal_mapping, output_signal_index_mapping


    def map(self, output_signals_of_embedding_block):
        &#34;&#34;&#34;

            given the signals to calculate (variable signals) in the callbacks 

                def generate_code_output_list(self, language, signals : List [ Signal ] ): 

            resolve the mapping to the embedded subsystems output signals

        &#34;&#34;&#34;

        mapped_subsystem_output_signals = []
        for s in output_signals_of_embedding_block:
            mapped_subsystem_output_signals.append( self._output_signal_mapping[s] )

        return mapped_subsystem_output_signals
    


    def map_to_output_index(self, output_signals_of_embedding_block):
        &#34;&#34;&#34;
            return a mapping to indices of the block outputs:

            e.g. [sig0, sig1, sig2, sig4] --&gt; [0, 1, 2, 4]
        &#34;&#34;&#34;

        mapped_subsystem_output_signals = []
        for s in output_signals_of_embedding_block:
            mapped_subsystem_output_signals.append( self._output_signal_index_mapping[s] )

        return mapped_subsystem_output_signals
    








    # def helper_get_output_signal_mapping_to_subsystem(self, signals_to_calculate):
    #     &#34;&#34;&#34;

    #         given the signals to calculate (variable signals) in the callbacks 

    #             def generate_code_output_list(self, language, signals : List [ Signal ] ): 

    #         resolve the mapping to the embedded subsystems output signals

    #     &#34;&#34;&#34;

    #     return self.outputs_map_from_embedding_block_to_subsystem.map( signals_to_calculate )

    #     # mapped_subsystem_output_signals = []
    #     # for s in signals_to_calculate:
    #     #     mapped_subsystem_output_signals.append( self._output_signal_mapping[s] )

    #     # return mapped_subsystem_output_signals
    
















# helper fn for classes that are derived from SingleSubsystemEmbedder and XX
def embed_subsystem3(language, subsystem_prototype, assign_to_signals=None, ouput_signals_of_subsystem=None, calculate_outputs = True, update_states = False, reset_states=False ):
    &#34;&#34;&#34;  
        generate code to call a subsystem

        - subsystem_prototype - the block prototype including the subsystem - type: : dy.GenericSubsystem
        - assign_to_signals   - list of signals to which the output signals of the subsystem are assigned to
        
        - ouput_signal_of_subsystem - the output signals of the embedded subsystem

        - calculate_outputs   - generate a call to the output computation API function of the subsystem
        - update_states       - generate a call to the state update API function of the subsystem
    &#34;&#34;&#34;


    lines = &#39;{ // subsystem &#39; + subsystem_prototype.embedded_subsystem.name + &#39;\n&#39;

    innerLines = &#39;&#39;

    #
    # system_prototype is of type GenericSubsystem. call the code generation routine of the subsystem
    #

    if reset_states:
        innerLines += subsystem_prototype.generate_code_reset(language)


    # generate code for calculating the outputs 
    if calculate_outputs:

        # extract the signals names
        assign_to_signals_names = cgh.signal_list_to_name_list(assign_to_signals)
        ouput_signal_names_of_subsystem = cgh.signal_list_to_name_list(ouput_signals_of_subsystem)


        innerLines += subsystem_prototype.generate_code_output_list(language, subsystem_prototype.outputs)

        if len(ouput_signal_names_of_subsystem) != len(assign_to_signals_names):
            raise BaseException(&#39;len(ouput_signal_names_of_subsystem) != len(ouput_signals_name)&#39;)




        #
        # REWORK: read out the outputs.* structure
        #



        for i in range( 0, len( assign_to_signals_names ) ):
            innerLines += cgh.asign( ouput_signal_names_of_subsystem[i], assign_to_signals_names[i] )

    # generate code for updating the states
    if update_states:
        innerLines += subsystem_prototype.generate_code_update(language)


    lines += cgh.indent(innerLines)
    lines += &#39;}\n&#39;

    return lines








































# REMOVE
def embed_subsystem2(language, subsystem_prototype, ouput_signals_name=None, ouput_signal_names_of_subsystem=None, calculate_outputs = True, update_states = False, reset_states=False ):
    &#34;&#34;&#34;  
        generate code to call a subsystem

        - subsystem_prototype - the block prototype including the subsystem - type: : dy.GenericSubsystem
        - ouput_signals_name  - list of variable names to which the output signals of the subsystem are assigned to
        
        - ouput_signal_names_of_subsystem - ....

        - calculate_outputs   - generate a call to the output computation API function of the subsystem
        - update_states       - generate a call to the state update API function of the subsystem
    &#34;&#34;&#34;


    lines = &#39;{ // subsystem &#39; + subsystem_prototype.embedded_subsystem.name + &#39;\n&#39;

    innerLines = &#39;&#39;

    #
    # system_prototype is of type GenericSubsystem. call the code generation routine of the subsystem
    #

    if reset_states:
        innerLines += subsystem_prototype.generate_code_reset(language)


    # generate code for calculating the outputs 
    if calculate_outputs:

        innerLines += subsystem_prototype.generate_code_output_list(language, subsystem_prototype.outputs)

        if len(ouput_signal_names_of_subsystem) != len(ouput_signals_name):
            raise BaseException(&#39;len(ouput_signal_names_of_subsystem) != len(ouput_signals_name)&#39;)

        #
        # REWORK: read out the outputs.* structure
        #

        for i in range( 0, len( ouput_signals_name ) ):  # NOTE: this might mix the output signals!
            innerLines += cgh.asign( ouput_signal_names_of_subsystem[i], ouput_signals_name[i] )

    # generate code for updating the states
    if update_states:
        innerLines += subsystem_prototype.generate_code_update(language)


    lines += cgh.indent(innerLines)
    lines += &#39;}\n&#39;

    return lines</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.embed_subsystem2"><code class="name flex">
<span>def <span class="ident">embed_subsystem2</span></span>(<span>language, subsystem_prototype, ouput_signals_name=None, ouput_signal_names_of_subsystem=None, calculate_outputs=True, update_states=False, reset_states=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generate code to call a subsystem</p>
<ul>
<li>subsystem_prototype - the block prototype including the subsystem - type: : dy.GenericSubsystem</li>
<li>
<p>ouput_signals_name
- list of variable names to which the output signals of the subsystem are assigned to</p>
</li>
<li>
<p>ouput_signal_names_of_subsystem - ....</p>
</li>
<li>
<p>calculate_outputs
- generate a call to the output computation API function of the subsystem</p>
</li>
<li>update_states
- generate a call to the state update API function of the subsystem</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embed_subsystem2(language, subsystem_prototype, ouput_signals_name=None, ouput_signal_names_of_subsystem=None, calculate_outputs = True, update_states = False, reset_states=False ):
    &#34;&#34;&#34;  
        generate code to call a subsystem

        - subsystem_prototype - the block prototype including the subsystem - type: : dy.GenericSubsystem
        - ouput_signals_name  - list of variable names to which the output signals of the subsystem are assigned to
        
        - ouput_signal_names_of_subsystem - ....

        - calculate_outputs   - generate a call to the output computation API function of the subsystem
        - update_states       - generate a call to the state update API function of the subsystem
    &#34;&#34;&#34;


    lines = &#39;{ // subsystem &#39; + subsystem_prototype.embedded_subsystem.name + &#39;\n&#39;

    innerLines = &#39;&#39;

    #
    # system_prototype is of type GenericSubsystem. call the code generation routine of the subsystem
    #

    if reset_states:
        innerLines += subsystem_prototype.generate_code_reset(language)


    # generate code for calculating the outputs 
    if calculate_outputs:

        innerLines += subsystem_prototype.generate_code_output_list(language, subsystem_prototype.outputs)

        if len(ouput_signal_names_of_subsystem) != len(ouput_signals_name):
            raise BaseException(&#39;len(ouput_signal_names_of_subsystem) != len(ouput_signals_name)&#39;)

        #
        # REWORK: read out the outputs.* structure
        #

        for i in range( 0, len( ouput_signals_name ) ):  # NOTE: this might mix the output signals!
            innerLines += cgh.asign( ouput_signal_names_of_subsystem[i], ouput_signals_name[i] )

    # generate code for updating the states
    if update_states:
        innerLines += subsystem_prototype.generate_code_update(language)


    lines += cgh.indent(innerLines)
    lines += &#39;}\n&#39;

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.embed_subsystem3"><code class="name flex">
<span>def <span class="ident">embed_subsystem3</span></span>(<span>language, subsystem_prototype, assign_to_signals=None, ouput_signals_of_subsystem=None, calculate_outputs=True, update_states=False, reset_states=False)</span>
</code></dt>
<dd>
<div class="desc"><p>generate code to call a subsystem</p>
<ul>
<li>subsystem_prototype - the block prototype including the subsystem - type: : dy.GenericSubsystem</li>
<li>
<p>assign_to_signals
- list of signals to which the output signals of the subsystem are assigned to</p>
</li>
<li>
<p>ouput_signal_of_subsystem - the output signals of the embedded subsystem</p>
</li>
<li>
<p>calculate_outputs
- generate a call to the output computation API function of the subsystem</p>
</li>
<li>update_states
- generate a call to the state update API function of the subsystem</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def embed_subsystem3(language, subsystem_prototype, assign_to_signals=None, ouput_signals_of_subsystem=None, calculate_outputs = True, update_states = False, reset_states=False ):
    &#34;&#34;&#34;  
        generate code to call a subsystem

        - subsystem_prototype - the block prototype including the subsystem - type: : dy.GenericSubsystem
        - assign_to_signals   - list of signals to which the output signals of the subsystem are assigned to
        
        - ouput_signal_of_subsystem - the output signals of the embedded subsystem

        - calculate_outputs   - generate a call to the output computation API function of the subsystem
        - update_states       - generate a call to the state update API function of the subsystem
    &#34;&#34;&#34;


    lines = &#39;{ // subsystem &#39; + subsystem_prototype.embedded_subsystem.name + &#39;\n&#39;

    innerLines = &#39;&#39;

    #
    # system_prototype is of type GenericSubsystem. call the code generation routine of the subsystem
    #

    if reset_states:
        innerLines += subsystem_prototype.generate_code_reset(language)


    # generate code for calculating the outputs 
    if calculate_outputs:

        # extract the signals names
        assign_to_signals_names = cgh.signal_list_to_name_list(assign_to_signals)
        ouput_signal_names_of_subsystem = cgh.signal_list_to_name_list(ouput_signals_of_subsystem)


        innerLines += subsystem_prototype.generate_code_output_list(language, subsystem_prototype.outputs)

        if len(ouput_signal_names_of_subsystem) != len(assign_to_signals_names):
            raise BaseException(&#39;len(ouput_signal_names_of_subsystem) != len(ouput_signals_name)&#39;)




        #
        # REWORK: read out the outputs.* structure
        #



        for i in range( 0, len( assign_to_signals_names ) ):
            innerLines += cgh.asign( ouput_signal_names_of_subsystem[i], assign_to_signals_names[i] )

    # generate code for updating the states
    if update_states:
        innerLines += subsystem_prototype.generate_code_update(language)


    lines += cgh.indent(innerLines)
    lines += &#39;}\n&#39;

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.setup_output_datatype_inheritance"><code class="name flex">
<span>def <span class="ident">setup_output_datatype_inheritance</span></span>(<span>normal_outputs_of_embedding_block, subsystem_prototype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setup_output_datatype_inheritance( normal_outputs_of_embedding_block, subsystem_prototype ):
    # inherit output datatypes of this block from the embedded subsystem described by subsystem_prototype

    for i in range(0, len(normal_outputs_of_embedding_block) ):

        output_signal_of_embedding_block = normal_outputs_of_embedding_block[i]
        output_signal_of_subsystem = subsystem_prototype.outputs[i]
        output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

    return</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem"><code class="flex name class">
<span>class <span class="ident">GenericSubsystem</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a> = None, manifest=None, inputSignals=None, N_outputs=None, embedded_subsystem=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Include a sub-system by passing a manifest</p>
<ul>
<li>sim - the simulation this block is embedded into</li>
</ul>
<p>parameters required only in case the subsystem is already defined (e.g. loaded from a library):</p>
<ul>
<li>manifest
- the manifest of the subsystem to include (optional, might be handed over by init())</li>
<li>inputSignals
- the inputs to the subsystem </li>
<li>N_outputs
- prepare a number of nOutputs (optional in case a manifest is given)</li>
<li>embedded_subsystem - the system to embed (optional in case a manifest to an already compiled subsystem is given, NOT IMPLEMENTED)</li>
</ul>
<p>Note: the number of outputs must be defined either by N_outputs or by a manifest</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericSubsystem(bi.BlockPrototype):
    &#34;&#34;&#34;
        Include a sub-system by passing a manifest

        - sim - the simulation this block is embedded into

        parameters required only in case the subsystem is already defined (e.g. loaded from a library):

        - manifest           - the manifest of the subsystem to include (optional, might be handed over by init())
        - inputSignals       - the inputs to the subsystem 
        - N_outputs          - prepare a number of nOutputs (optional in case a manifest is given)
        - embedded_subsystem - the system to embed (optional in case a manifest to an already compiled subsystem is given, NOT IMPLEMENTED)

        Note: the number of outputs must be defined either by N_outputs or by a manifest

    &#34;&#34;&#34;
    def __init__(self, sim : System = None, manifest=None, inputSignals=None, N_outputs = None, embedded_subsystem=None ):

        self.manifest = manifest
        self.inputSignals = inputSignals
        self.sim = sim
        self.Noutputs = N_outputs
        self._embedded_subsystem = embedded_subsystem

        if manifest is not None:
            if N_outputs is None:
                self.Noutputs = self.manifest.number_of_default_ouputs
            else:
                raise BaseException(&#34;N_outputs and a manifest specified at the same time&#34;)

        # output signals that were created by sth. ourside of this prototype
        # and that need to be connected to the actual outputs when init() is called.
        self.anonymous_output_signals = None

        # optional (in case this block is in charge of putting the code for the subsystem)
        self.compileResult = None

        # init super class
        bi.BlockPrototype.__init__(self, self.sim, N_outputs = self.Noutputs)

        # Note: the inputSignals are not defined when subsystems are pre-defined in the code
        # but are automatically placed and connected by the compiler during compilation

        # check if it is already possible to init this prototype
        # (in case all requred information is available)
        if inputSignals is not None and manifest is not None:
            self.init()

        # configure datatype inheritance for the outputs signals
        for i in range(0, len( embedded_subsystem.primary_outputs )):

            output_signal_of_embedding_block = self.outputs[i]
            output_signal_of_subsystem = embedded_subsystem.primary_outputs[i]

            output_signal_of_embedding_block.inherit_datatype_from_signal( output_signal_of_subsystem )

    @property
    def embedded_subsystem(self):
        &#34;&#34;&#34;
            Return the system that is embedded (in case it was provided, returns None otherwise)
        &#34;&#34;&#34;

        return self._embedded_subsystem

    def set_anonymous_output_signal_to_connect(self, anonymous_output_signals):
        &#34;&#34;&#34;
            store a list of anonymous signals to connect to the outputs of the subsystems
            after running the post_compile_callback
        &#34;&#34;&#34;
        # List of raw signals 
        self.anonymous_output_signals = anonymous_output_signals

    def compile_callback_all_subsystems_compiled(self):

        embedded_system = self._embedded_subsystem
        #
        # continue init as now all subsystems are compiled and the compile results and the manifest of
        # the system to compile is available.
        #
        self.init(embedded_system.compile_result.manifest, embedded_system.compile_result, embedded_system.compile_result.inputSignals)

    # post_compile_callback (called after the subsystem to embed was compiled)
    def init(self, manifest, compileResult, inputSignals):
        &#34;&#34;&#34;
            This is a second phase initialization of this subsystem block 
            (to be called by compile_callback_all_subsystems_compiled())

            This function shall be called when the subsystem to embed is compiled
            after the instance of &#39;GenericSubsystem&#39; is created. This way, it is possible
            to add blocks embeddeding sub-systems without haveing these subsystems to be
            already compiled.

            Optionally, the system this block belongs to can be set.

            manifest       - the system manifest of the subsystem to embed
            compileResults - the compile results of the subsystem to embed
            inputSignals   - input signals to the subsystem to embed (links comming from an upper-level subsystem)

        &#34;&#34;&#34;        

        #
        #    set the manifest of the subsystem
        #
        if self.manifest is not None:
            raise BaseException(&#34;cannot call this function as the subsystem&#39;s manifest was already defined in the constructor.&#34;)

        self.manifest = manifest

        #
        #    Set the compilation result of the embedded system (if available)
        #
        self.compileResult = compileResult

        #
        #    connect the inputs (coming from the upper-level system)
        #

        if self.inputSignals is not None:
            raise BaseException(&#34;The subsystem&#39;s inputSignals were already specified in the constructor.&#34;)

        self.inputSignals = inputSignals



        def collectDependingSignals(signals, manifestFunctionInputs):
            # collect all depending input signals (that are needed to calculate the output) in a list
            # MOVE TO A FUNCTION. MAYBE MOVE TO MANIFEST.PY
            dependingInputs = []
            for i in range( len(manifestFunctionInputs[&#39;names&#39;]) ):

                dependingInput_name = manifestFunctionInputs[&#39;names&#39;][i]
                dependingInput_type = manifestFunctionInputs[&#39;types&#39;][i]
                dependingInput_cpptype = manifestFunctionInputs[&#39;cpptypes&#39;][i]

                # TODO: CHECK FOR FAILING LOOKUP
                signal = signals[ dependingInput_name ]

                # check datatype
                if not signal.getDatatype().cpp_datatype_string == dependingInput_cpptype:
                    raise BaseException(&#39;datatype does not match the one specified in the manifest. (&#39; + (dependingInput_cpptype) + &#39; is required in the manifest)&#39; )

                # append signal
                dependingInputs.append( signal ) 

            return dependingInputs



        # verify the number of outputs of the embedded system
        number_of_outputs_as_described_by_manifest = self.manifest.number_of_default_ouputs

        if not number_of_outputs_as_described_by_manifest == self.Noutputs:
            BaseException(&#34;missmatch in the number of outputs&#34;)

        # get the output datatypes of the embedded system
        self.outputTypes = self.manifest.io_outputs[&#39;calculate_output&#39;][&#39;types&#39;]  


        if self.compileResult is None:
            # collect all depending input signals (that are needed to calculate the output) in a list
            self.inputsToCalculateOutputs = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;calculate_output&#39;] )

            # collect all inputs required to perform the state update
            self.inputsToUpdateStates = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;state_update&#39;] )

        else:
            # use the available compile results to get the I/O signals
            # in this case, self.inputSignals shall be a list of signals. The order
            # shall match the signal order in self.compileResults.inputSignals

            self.inputsToCalculateOutputs = self.compileResult.simulationInputSignalsToCalculateOutputs
            self.inputsToUpdateStates = self.compileResult.simulationInputSignalsToUpdateStates

            

        # combine all inputs to a list
        self.allInputs = list()

        self.allInputs.extend( self.inputsToCalculateOutputs )
        self.allInputs.extend( self.inputsToUpdateStates )

        #
        # now initialize the propotype
        #

        # define the inputs
        self.update_input_config( self.allInputs )

        # connect the outputs signals
        if self.anonymous_output_signals is not None:

            print(&#34; -- Nesting block: connecting anonymous signals -- &#34;)

            Ns = len(self.outputSignals)

            if not Ns == len(  self.anonymous_output_signals ):
                raise BaseException(&#34; missmatch in the number of output signals&#34;)

            for i in range(0,Ns):
                
                s_ananon = self.anonymous_output_signals[i]
                s_source = self.outputSignals[i]

                print(&#34;connecting the output &#34; + s_ananon.toStr() + &#34; of the embedding block&#34;)
                s_ananon.setequal( s_source )



        # for code generation
        self.instanceVarname = self.getUniqueVarnamePrefix() + &#39;_subsystem_&#39; + self.manifest.API_name


    def config_request_define_output_types(self, inputTypes):

        # the datatypes are fixed in the manifest 
        return self.outputTypes        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):

        # NOTE: This is a simplified veriant so far.. no dependence on the given &#39;outputSignal&#39;
        #       (Every output depends on every signal in self.inputsToCalculateOutputs)

        # TODO: 6.10.19 implement this in a more granular way.
        # also use self.compileResults to get those information

        return self.inputsToCalculateOutputs

    def config_request_define_state_update_input_dependencies(self, outputSignal):
 
        # return a list of input signals that are required to update the states
        return self.inputsToUpdateStates



    def codegen_addToNamespace(self, language):
        lines = &#39;&#39;

        # putting code for subsystems is performed using execution commands

        return lines

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            lines = &#39;// instance of &#39; + self.manifest.API_name + &#39;\n&#39;
            lines += self.manifest.API_name + &#39; &#39; + self.instanceVarname + &#39;;\n&#39;

            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:
            return self.instanceVarname + &#39;.&#39; + self.manifest.getAPIFunctionName(&#39;reset&#39;) +  &#39;();\n&#39;


    def generate_code_init(self, language):
        pass


    def generate_code_destruct(self, language):
        pass


    # helper fn to build code
    def generate_code_call_OutputFunction(self, instanceVarname, manifest, language):
        return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;calculate_output&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.outputs + self.inputsToCalculateOutputs) + &#39;);\n&#39;

    # helper fn to build code
    def generate_code_call_UpdateFunction(self, instanceVarname, manifest, language):
        return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;state_update&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.inputsToUpdateStates) + &#39;);\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = &#39;&#39;
            
            #
            # TODO: 2.5.2020: concept: how to compute only the nescessary signals?
            #








            #
            # REWORK: introduce call to fn(Inputs &amp; inputs, Outputs &amp; outputs)
            # and remove the prev. style
            #

            for s in self.outputs: # for each output of the subsystem reservate a variable
                lines += cgh.define_variable_line( s ) 

                if s not in signals:
                    lines += &#39;// NOTE: unused output signal&#39; + s.name + &#39;\n&#39;
                else:
                    lines += &#39;&#39;                

            lines += self.generate_code_call_OutputFunction(self.instanceVarname, self.manifest, language)

        return lines

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            # input to this call are the signals in self.inputsToUpdateStates
            return self.generate_code_call_UpdateFunction(self.instanceVarname, self.manifest, language)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.embedded_subsystem"><code class="name">var <span class="ident">embedded_subsystem</span></code></dt>
<dd>
<div class="desc"><p>Return the system that is embedded (in case it was provided, returns None otherwise)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def embedded_subsystem(self):
    &#34;&#34;&#34;
        Return the system that is embedded (in case it was provided, returns None otherwise)
    &#34;&#34;&#34;

    return self._embedded_subsystem</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # the datatypes are fixed in the manifest 
    return self.outputTypes        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_call_OutputFunction"><code class="name flex">
<span>def <span class="ident">generate_code_call_OutputFunction</span></span>(<span>self, instanceVarname, manifest, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_call_OutputFunction(self, instanceVarname, manifest, language):
    return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;calculate_output&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.outputs + self.inputsToCalculateOutputs) + &#39;);\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_call_UpdateFunction"><code class="name flex">
<span>def <span class="ident">generate_code_call_UpdateFunction</span></span>(<span>self, instanceVarname, manifest, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_call_UpdateFunction(self, instanceVarname, manifest, language):
    return instanceVarname + &#39;.&#39; + manifest.getAPIFunctionName(&#39;state_update&#39;) +  &#39;(&#39; + cgh.signal_list_to_names_string(self.inputsToUpdateStates) + &#39;);\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        lines = &#39;&#39;
        
        #
        # TODO: 2.5.2020: concept: how to compute only the nescessary signals?
        #








        #
        # REWORK: introduce call to fn(Inputs &amp; inputs, Outputs &amp; outputs)
        # and remove the prev. style
        #

        for s in self.outputs: # for each output of the subsystem reservate a variable
            lines += cgh.define_variable_line( s ) 

            if s not in signals:
                lines += &#39;// NOTE: unused output signal&#39; + s.name + &#39;\n&#39;
            else:
                lines += &#39;&#39;                

        lines += self.generate_code_call_OutputFunction(self.instanceVarname, self.manifest, language)

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:
        return self.instanceVarname + &#39;.&#39; + self.manifest.getAPIFunctionName(&#39;reset&#39;) +  &#39;();\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):
    if language == &#39;c++&#39;:

        # input to this call are the signals in self.inputsToUpdateStates
        return self.generate_code_call_UpdateFunction(self.instanceVarname, self.manifest, language)</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self, manifest, compileResult, inputSignals)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a second phase initialization of this subsystem block
(to be called by compile_callback_all_subsystems_compiled())</p>
<p>This function shall be called when the subsystem to embed is compiled
after the instance of 'GenericSubsystem' is created. This way, it is possible
to add blocks embeddeding sub-systems without haveing these subsystems to be
already compiled.</p>
<p>Optionally, the system this block belongs to can be set.</p>
<p>manifest
- the system manifest of the subsystem to embed
compileResults - the compile results of the subsystem to embed
inputSignals
- input signals to the subsystem to embed (links comming from an upper-level subsystem)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self, manifest, compileResult, inputSignals):
    &#34;&#34;&#34;
        This is a second phase initialization of this subsystem block 
        (to be called by compile_callback_all_subsystems_compiled())

        This function shall be called when the subsystem to embed is compiled
        after the instance of &#39;GenericSubsystem&#39; is created. This way, it is possible
        to add blocks embeddeding sub-systems without haveing these subsystems to be
        already compiled.

        Optionally, the system this block belongs to can be set.

        manifest       - the system manifest of the subsystem to embed
        compileResults - the compile results of the subsystem to embed
        inputSignals   - input signals to the subsystem to embed (links comming from an upper-level subsystem)

    &#34;&#34;&#34;        

    #
    #    set the manifest of the subsystem
    #
    if self.manifest is not None:
        raise BaseException(&#34;cannot call this function as the subsystem&#39;s manifest was already defined in the constructor.&#34;)

    self.manifest = manifest

    #
    #    Set the compilation result of the embedded system (if available)
    #
    self.compileResult = compileResult

    #
    #    connect the inputs (coming from the upper-level system)
    #

    if self.inputSignals is not None:
        raise BaseException(&#34;The subsystem&#39;s inputSignals were already specified in the constructor.&#34;)

    self.inputSignals = inputSignals



    def collectDependingSignals(signals, manifestFunctionInputs):
        # collect all depending input signals (that are needed to calculate the output) in a list
        # MOVE TO A FUNCTION. MAYBE MOVE TO MANIFEST.PY
        dependingInputs = []
        for i in range( len(manifestFunctionInputs[&#39;names&#39;]) ):

            dependingInput_name = manifestFunctionInputs[&#39;names&#39;][i]
            dependingInput_type = manifestFunctionInputs[&#39;types&#39;][i]
            dependingInput_cpptype = manifestFunctionInputs[&#39;cpptypes&#39;][i]

            # TODO: CHECK FOR FAILING LOOKUP
            signal = signals[ dependingInput_name ]

            # check datatype
            if not signal.getDatatype().cpp_datatype_string == dependingInput_cpptype:
                raise BaseException(&#39;datatype does not match the one specified in the manifest. (&#39; + (dependingInput_cpptype) + &#39; is required in the manifest)&#39; )

            # append signal
            dependingInputs.append( signal ) 

        return dependingInputs



    # verify the number of outputs of the embedded system
    number_of_outputs_as_described_by_manifest = self.manifest.number_of_default_ouputs

    if not number_of_outputs_as_described_by_manifest == self.Noutputs:
        BaseException(&#34;missmatch in the number of outputs&#34;)

    # get the output datatypes of the embedded system
    self.outputTypes = self.manifest.io_outputs[&#39;calculate_output&#39;][&#39;types&#39;]  


    if self.compileResult is None:
        # collect all depending input signals (that are needed to calculate the output) in a list
        self.inputsToCalculateOutputs = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;calculate_output&#39;] )

        # collect all inputs required to perform the state update
        self.inputsToUpdateStates = collectDependingSignals( self.inputSignals, self.manifest.io_inputs[&#39;state_update&#39;] )

    else:
        # use the available compile results to get the I/O signals
        # in this case, self.inputSignals shall be a list of signals. The order
        # shall match the signal order in self.compileResults.inputSignals

        self.inputsToCalculateOutputs = self.compileResult.simulationInputSignalsToCalculateOutputs
        self.inputsToUpdateStates = self.compileResult.simulationInputSignalsToUpdateStates

        

    # combine all inputs to a list
    self.allInputs = list()

    self.allInputs.extend( self.inputsToCalculateOutputs )
    self.allInputs.extend( self.inputsToUpdateStates )

    #
    # now initialize the propotype
    #

    # define the inputs
    self.update_input_config( self.allInputs )

    # connect the outputs signals
    if self.anonymous_output_signals is not None:

        print(&#34; -- Nesting block: connecting anonymous signals -- &#34;)

        Ns = len(self.outputSignals)

        if not Ns == len(  self.anonymous_output_signals ):
            raise BaseException(&#34; missmatch in the number of output signals&#34;)

        for i in range(0,Ns):
            
            s_ananon = self.anonymous_output_signals[i]
            s_source = self.outputSignals[i]

            print(&#34;connecting the output &#34; + s_ananon.toStr() + &#34; of the embedding block&#34;)
            s_ananon.setequal( s_source )



    # for code generation
    self.instanceVarname = self.getUniqueVarnamePrefix() + &#39;_subsystem_&#39; + self.manifest.API_name</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.set_anonymous_output_signal_to_connect"><code class="name flex">
<span>def <span class="ident">set_anonymous_output_signal_to_connect</span></span>(<span>self, anonymous_output_signals)</span>
</code></dt>
<dd>
<div class="desc"><p>store a list of anonymous signals to connect to the outputs of the subsystems
after running the post_compile_callback</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_anonymous_output_signal_to_connect(self, anonymous_output_signals):
    &#34;&#34;&#34;
        store a list of anonymous signals to connect to the outputs of the subsystems
        after running the post_compile_callback
    &#34;&#34;&#34;
    # List of raw signals 
    self.anonymous_output_signals = anonymous_output_signals</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem"><code class="flex name class">
<span>class <span class="ident">OutputMapEmbeddingBlockToSubsystem</span></span>
<span>(</span><span>normal_outputs_of_embedding_block, subsystem_prototype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OutputMapEmbeddingBlockToSubsystem():

    def __init__(self, normal_outputs_of_embedding_block, subsystem_prototype):

        self._output_signal_mapping, self._output_signal_index_mapping = self.create_output_mapping_table(normal_outputs_of_embedding_block, subsystem_prototype )


    def create_output_mapping_table(self, normal_outputs_of_embedding_block, subsystem_prototype ):
        # output signal mapping: map each output of SingleSubsystemEmbedder to an output of the subsystem
        output_signal_mapping = {}

        # map output signal of embedding block to output index of the embedded block
        output_signal_index_mapping = {}

        for i in range(0, len(normal_outputs_of_embedding_block) ):
            # fill in mapping table
            output_signal_mapping[ normal_outputs_of_embedding_block[i] ] = subsystem_prototype.outputs[i]
            output_signal_index_mapping[ normal_outputs_of_embedding_block[i] ] = i



        return output_signal_mapping, output_signal_index_mapping


    def map(self, output_signals_of_embedding_block):
        &#34;&#34;&#34;

            given the signals to calculate (variable signals) in the callbacks 

                def generate_code_output_list(self, language, signals : List [ Signal ] ): 

            resolve the mapping to the embedded subsystems output signals

        &#34;&#34;&#34;

        mapped_subsystem_output_signals = []
        for s in output_signals_of_embedding_block:
            mapped_subsystem_output_signals.append( self._output_signal_mapping[s] )

        return mapped_subsystem_output_signals
    


    def map_to_output_index(self, output_signals_of_embedding_block):
        &#34;&#34;&#34;
            return a mapping to indices of the block outputs:

            e.g. [sig0, sig1, sig2, sig4] --&gt; [0, 1, 2, 4]
        &#34;&#34;&#34;

        mapped_subsystem_output_signals = []
        for s in output_signals_of_embedding_block:
            mapped_subsystem_output_signals.append( self._output_signal_index_mapping[s] )

        return mapped_subsystem_output_signals</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.create_output_mapping_table"><code class="name flex">
<span>def <span class="ident">create_output_mapping_table</span></span>(<span>self, normal_outputs_of_embedding_block, subsystem_prototype)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_output_mapping_table(self, normal_outputs_of_embedding_block, subsystem_prototype ):
    # output signal mapping: map each output of SingleSubsystemEmbedder to an output of the subsystem
    output_signal_mapping = {}

    # map output signal of embedding block to output index of the embedded block
    output_signal_index_mapping = {}

    for i in range(0, len(normal_outputs_of_embedding_block) ):
        # fill in mapping table
        output_signal_mapping[ normal_outputs_of_embedding_block[i] ] = subsystem_prototype.outputs[i]
        output_signal_index_mapping[ normal_outputs_of_embedding_block[i] ] = i



    return output_signal_mapping, output_signal_index_mapping</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, output_signals_of_embedding_block)</span>
</code></dt>
<dd>
<div class="desc"><p>given the signals to calculate (variable signals) in the callbacks </p>
<pre><code>def generate_code_output_list(self, language, signals : List [ Signal ] ):
</code></pre>
<p>resolve the mapping to the embedded subsystems output signals</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, output_signals_of_embedding_block):
    &#34;&#34;&#34;

        given the signals to calculate (variable signals) in the callbacks 

            def generate_code_output_list(self, language, signals : List [ Signal ] ): 

        resolve the mapping to the embedded subsystems output signals

    &#34;&#34;&#34;

    mapped_subsystem_output_signals = []
    for s in output_signals_of_embedding_block:
        mapped_subsystem_output_signals.append( self._output_signal_mapping[s] )

    return mapped_subsystem_output_signals</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.map_to_output_index"><code class="name flex">
<span>def <span class="ident">map_to_output_index</span></span>(<span>self, output_signals_of_embedding_block)</span>
</code></dt>
<dd>
<div class="desc"><p>return a mapping to indices of the block outputs:</p>
<p>e.g. [sig0, sig1, sig2, sig4] &ndash;&gt; [0, 1, 2, 4]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_to_output_index(self, output_signals_of_embedding_block):
    &#34;&#34;&#34;
        return a mapping to indices of the block outputs:

        e.g. [sig0, sig1, sig2, sig4] --&gt; [0, 1, 2, 4]
    &#34;&#34;&#34;

    mapped_subsystem_output_signals = []
    for s in output_signals_of_embedding_block:
        mapped_subsystem_output_signals.append( self._output_signal_index_mapping[s] )

    return mapped_subsystem_output_signals</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openrtdynamics2.lang" href="index.html">openrtdynamics2.lang</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.embed_subsystem2" href="#openrtdynamics2.lang.block_prototypes_subsystems.embed_subsystem2">embed_subsystem2</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.embed_subsystem3" href="#openrtdynamics2.lang.block_prototypes_subsystems.embed_subsystem3">embed_subsystem3</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.setup_output_datatype_inheritance" href="#openrtdynamics2.lang.block_prototypes_subsystems.setup_output_datatype_inheritance">setup_output_datatype_inheritance</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem">GenericSubsystem</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.embedded_subsystem" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.embedded_subsystem">embedded_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_call_OutputFunction" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_call_OutputFunction">generate_code_call_OutputFunction</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_call_UpdateFunction" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_call_UpdateFunction">generate_code_call_UpdateFunction</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_reset" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_update" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.generate_code_update">generate_code_update</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.init" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.init">init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.set_anonymous_output_signal_to_connect" href="#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem.set_anonymous_output_signal_to_connect">set_anonymous_output_signal_to_connect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem" href="#openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem">OutputMapEmbeddingBlockToSubsystem</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.create_output_mapping_table" href="#openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.create_output_mapping_table">create_output_mapping_table</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.map" href="#openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.map">map</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.map_to_output_index" href="#openrtdynamics2.lang.block_prototypes_subsystems.OutputMapEmbeddingBlockToSubsystem.map_to_output_index">map_to_output_index</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>