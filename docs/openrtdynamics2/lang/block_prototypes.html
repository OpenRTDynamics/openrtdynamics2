<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>openrtdynamics2.lang.block_prototypes API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openrtdynamics2.lang.block_prototypes</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .diagram_core.system import System
from .diagram_core import datatypes as dt
from .diagram_core.signal_network.signals import Signal
from .diagram_core import code_generation_helper as cgh
from . import block_interface as bi

from .block_prototypes_subsystems import *
from .block_prototypes_single_subsystem import *
from .block_prototypes_switched_subsystems import *

from typing import Dict, List

# TODO: rename to atomic_blocks

&#34;&#34;&#34;
    This file contains the implementations (i.e., functionality for code generation) of elementary blocks.
    The user-interface(s) for each of the blocks is in core_blocks.py
&#34;&#34;&#34;











# # REMOVE THIS
# def embed_subsystem(language, system_prototype, ouput_signals_name=None, calculate_outputs = True, update_states = False ):
#     &#34;&#34;&#34;  
#         generate code to call a subsystem (TODO: this is obsolete remove it!)

#         - system_prototype   - the block prototype including the subsystem - type: : dy.GenericSubsystem
#         - ouput_signals_name - list of variable names to which the output signals of the subsystem are assigned to
#         - calculate_outputs  - generate a call to the output computation API function of the subsystem
#         - update_states      - generate a call to the state update API function of the subsystem
#     &#34;&#34;&#34;


#     lines = &#39;{ // subsystem &#39; + system_prototype.embedded_subsystem.name + &#39;\n&#39;

#     innerLines = &#39;&#39;

#     #
#     # system_prototype is of type GenericSubsystem. call the code generation routine of the subsystem
#     #

#     # generate code for calculating the outputs 
#     if calculate_outputs:

#         innerLines += system_prototype.generate_code_output_list(language, system_prototype.outputs)

#         if len(system_prototype.outputs) != len(ouput_signals_name):
#             raise BaseException(&#39;len(system_prototype.outputs) != len(ouput_signals_name)&#39;)




#         for i in range( 0, len( ouput_signals_name ) ): # NOTE:
#             innerLines += asign( system_prototype.outputs[i].name, ouput_signals_name[i] )

#     # generate code for updating the states
#     if update_states:
#         innerLines += system_prototype.generate_code_update(language)


#     lines += indent(innerLines)
#     lines += &#39;}\n&#39;

#     return lines









class TruggeredSubsystem(SingleSubsystemEmbedder):
    &#34;&#34;&#34;
        Include a triggered sub-system

        Optional:

            prevent_output_computation = True: 
                The subsystems outputs are only computed when triggered. Please note that the outputs
                of the subsystem are uninitialized until the subsystem is triggered for the first time.

    &#34;&#34;&#34;

    def __init__(self, sim : System, control_input : Signal, subsystem_prototype : GenericSubsystem,  prevent_output_computation = False ):
        
        self._control_input = control_input
        self.prevent_output_computation = prevent_output_computation

        SingleSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[control_input], 
                                        subsystem_prototype=subsystem_prototype, 
                                        number_of_control_outputs=0 )


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            
            # generate code to call subsystem output(s)
            code_compute_output = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                assign_to_signals=signals, 
                ouput_signals_of_subsystem=self.outputs_map_from_embedding_block_to_subsystem.map( signals ),
                calculate_outputs = True, update_states = False 
            )

            if self.prevent_output_computation:

                # the subsystems outputs are only computed when triggered
                lines += cgh.generate_if_else(language, 
                    condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
                    action_list=[ code_compute_output ])

                # TODO: Design choice: assign NAN to the output values for self._control_input.name == 0 ?

            else:
                # the subsystems outputs are always computed
                lines += code_compute_output


        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            # generate code to compute the state update of the subsystem
            code_compute_state_update = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                calculate_outputs = False, update_states = True
            )

            # the subsystems update is only performed when triggered
            lines += cgh.generate_if_else(language, 
                condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
                action_list=[ code_compute_state_update ])

        return lines






class LoopUntilSubsystem(SingleSubsystemEmbedder):
    &#34;&#34;&#34;
        Embed a loop sub-system

    &#34;&#34;&#34;

    def __init__(self, sim : System, max_iterations : int, 
                    subsystem_prototype : GenericSubsystem, 
                    until_signal : Signal = None, yield_signal : Signal = None ):
        
        self.max_iter = max_iterations
        self._until_signal = until_signal
        self._yield_signal = yield_signal

        number_of_control_outputs = 0
        if self._until_signal is not None:
            number_of_control_outputs += 1

        if self._yield_signal is not None:
            number_of_control_outputs += 1


        SingleSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[],   # TODO: add N_iter signal here 
                                        subsystem_prototype=subsystem_prototype, 
                                        number_of_control_outputs=number_of_control_outputs )


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            assign_to_signals = []
            ouput_signals_of_subsystem = []

            assign_to_signals.extend(signals)
            ouput_signals_of_subsystem.extend(self.outputs_map_from_embedding_block_to_subsystem.map( signals )) # output signal mapping lookup

            control_output_index = 0

            if self._until_signal is not None:
                # define tmp-var for self._until_signal instead of a block output
                lines += cgh.defineVariables( [self._until_signal] )

                # add list of signals to assign
                assign_to_signals.append( self._until_signal )
                ouput_signals_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index] )
            
                control_output_index += 1


            if self._yield_signal is not None:
                # define tmp-var for self._yield_signal instead of a block output
                lines += cgh.defineVariables( [self._yield_signal] )

                # add list of signals to assign
                assign_to_signals.append( self._yield_signal )
                ouput_signals_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index] )

                control_output_index += 1



            calc_outputs = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                assign_to_signals=assign_to_signals, 
                ouput_signals_of_subsystem=ouput_signals_of_subsystem,
                calculate_outputs = True, update_states = False
            )

            

            update_states = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                calculate_outputs = False, update_states = True
            )

            code = &#39;&#39;
            code +=  calc_outputs 
            code += update_states

            if self._yield_signal is not None:
                code += cgh.generate_loop_break(language, condition=self._yield_signal.name)

            if self._until_signal is not None:

                code_reset_subsystem = embed_subsystem3(
                    language, 
                    subsystem_prototype=self._subsystem_prototype, 
                    calculate_outputs = False, update_states = False,
                    reset_states = True
                )

                code += cgh.generate_loop_break(language, condition=self._until_signal.name, code_before_break=code_reset_subsystem)

            lines += cgh.generate_loop( language, max_iterations=str(self.max_iter), code_to_exec=code  )

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            if self._until_signal is not None:
                pass    
                #lines += self._subsystem_prototype.generate_code_reset(language)


        return lines
























class SwitchSubsystems(MultiSubsystemEmbedder):
    &#34;&#34;&#34;
        A system that embeds multiple subsystems and a control input to switch in-between.
        The outputs of the currently active subsystem are forwarded.
    &#34;&#34;&#34;

    def __init__(self, sim : System, control_input : Signal, subsystem_prototypes : List [GenericSubsystem], reference_outputs : List [Signal] ):
        
        self._control_input = control_input

        MultiSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[control_input], 
                                        subsystem_prototypes=subsystem_prototypes, 
                                        switch_reference_outputs=reference_outputs,
                                        number_of_control_outputs=0 )

    def generate_code_defStates(self, language):
        lines = MultiSubsystemEmbedder.generate_code_defStates(self, language)
        
        return lines

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            
            lines += self.codegen_help_generate_switch( 
                language=language,
                switch_control_signal_name=self._control_input.name,
                switch_ouput_signals=signals,
                additional_outputs=[],
                calculate_outputs = True, update_states = False
            )

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            lines += self.codegen_help_generate_switch(
                language=language, 
                switch_control_signal_name=self._control_input.name,
                calculate_outputs=False, 
                update_states=True
            )

        return lines







class StatemachineSwitchSubsystems(MultiSubsystemEmbedder):
    &#34;&#34;&#34;
        Implement a state machine in which the states are represented by subsystems.
        State transitions are performed in case a special control output of the currently
        active subsystem indicates a transition to the next state.

        self.state_output  - 
    &#34;&#34;&#34;

    def __init__(self, sim : System, subsystem_prototypes : List [GenericSubsystem], reference_outputs : List [Signal] ):
        
        MultiSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[], 
                                        subsystem_prototypes=subsystem_prototypes, 
                                        switch_reference_outputs=reference_outputs,
                                        number_of_control_outputs = 1 )

        # how to add more outputs?
        self.state_output.setDatatype( dt.DataTypeInt32(1) )

        # this output signals must be compted in any way
        # also in case it is not used by other blocks
        sim.add_signal_mandatory_to_compute( self.state_output )


    @property
    def state_output(self):
        return self.control_outputs[0]


    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            lines = self._state_memory + &#39; = 0;\n&#39; # add something

            lines += MultiSubsystemEmbedder.generate_code_reset(self, language)

            return lines


    def generate_code_defStates(self, language):
        lines = MultiSubsystemEmbedder.generate_code_defStates(self, language)

        self._state_memory = self.getUniqueVarnamePrefix() + &#39;state&#39;
        lines += &#39;int &#39; + self._state_memory + &#39; {0};&#39;
        
        return lines


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            lines += self.codegen_help_generate_switch( language=language, 
                                            switch_control_signal_name=  self._state_memory ,
                                            switch_ouput_signals=signals,
                                            additional_outputs=[self.state_output] )

        return lines


    # code_gen helper
    def generate_switch_to_reset_leaving_subsystem( self, language, switch_control_signal_name ):

        lines = &#39;&#39;

        action_list = []
        condition_list = []

        subsystem_counter = 0
        for system_prototype in self._subsystem_prototypes:

            code_reset_states = MultiSubsystemEmbedder.generate_reset( self, language, system_index=subsystem_counter ) 

            action_list.append(  code_reset_states )

            # generate conditions when to execute the respective subsystem 
            condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

            subsystem_counter += 1

        # combine conditions and their repective actions
        lines += cgh.generate_if_else(language, condition_list, action_list)

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            lines += self.codegen_help_generate_switch(
                language=language, 
                switch_control_signal_name=self._state_memory,
                calculate_outputs=False, 
                update_states=True
            )

            # get the signal issued by the currently active subsystem that describes the requests for a stare transition
            state_control_signal_from_subsystems = self.state_output

            # reset current subsystem in case a state transition is requested
            lines_reset_subsystem = self.generate_switch_to_reset_leaving_subsystem(language, self._state_memory )
            lines += cgh.generate_if_else(language, condition_list=[ state_control_signal_from_subsystems.name + &#39; &gt;= 0 &#39; ], action_list=[lines_reset_subsystem])

            # transition to the new state
            lines += self._state_memory + &#39; = (&#39; + state_control_signal_from_subsystems.name + &#39; &gt;= 0 ) ? (&#39;+ state_control_signal_from_subsystems.name + &#39;) : (&#39; + self._state_memory + &#39;);\n&#39;
            
        return lines













#
# Sources
#

class Const(bi.StaticSource_To1):
    def __init__(self, sim : System, constant, datatype ):

        self.constant = constant

        # call super
        bi.StaticSource_To1.__init__(self, sim, datatype)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str( self.constant ) + &#39;;\n&#39;





#
# Multiply by constant
#

class Gain(bi.StaticFn_1To1):
    def __init__(self, sim : System, u : Signal, factor : float ):

        self._factor = factor

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._factor) + &#39; * &#39; + self.inputs[0].name +  &#39;;\n&#39;





#
# Cast to given datatype
#

class ConvertDatatype(bi.StaticFn_1To1):
    def __init__(self, sim : System, u : Signal, target_type : dt.DataType ):

        self._target_type = target_type

        bi.StaticFn_1To1.__init__(self, sim, u)

    def config_request_define_output_types(self, inputTypes):
        return [ self._target_type ]  

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            # TODO: only = is used and the c++ compiler decides how to convert...
            return signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;



#
# Basic operators
#

class Add(bi.StaticFn_NTo1):
    def __init__(self, sim : System, inputSignals : List[Signal], factors : List[float] ):

        # feasibility checks
        if len(inputSignals) != len(factors):
            raise(&#34;len(inp_list) must be equal to len(factors)&#34;)

        self.factors = factors
        bi.StaticFn_NTo1.__init__(self, sim, inputSignals)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            strs = []
            i = 0
            for s in self.inputSignals:
                strs.append(  str(self.factors[i]) + &#39; * &#39; + s.name )
                i = i + 1

            sumline = &#39; + &#39;.join( strs )
            lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

            return lines



class Operator1(bi.StaticFn_NTo1):
    def __init__(self, sim : System, inputSignals : List[Signal], operator : str ):

        self.operator = operator
        bi.StaticFn_NTo1.__init__(self, sim, inputSignals)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            strs = []
            i = 0
            for s in self.inputSignals:
                strs.append(  str(  s.name ) )
                i = i + 1

            sumline = (&#39; &#39; + self.operator + &#39; &#39;).join( strs )
            lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

            return lines












class ComparisionOperator(bi.StaticFn_NTo1):
    def __init__(self, sim : System, left : Signal, right : Signal, operator : str ):

        self.operator = operator

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [left, right])

    def config_request_define_output_types(self, inputTypes):

        # return a proposal for an output type. 
        return [ dt.DataTypeBoolean(1) ]

    # def generate_code_output(self, language, signal : Signal):
    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = signals[0].name + &#39; = &#39; + self.inputSignals[0].name + &#39; &#39; + self.operator + &#39; &#39; + self.inputSignals[1].name + &#39;;\n&#39;
            return lines




class SwitchNto1(bi.StaticFn_NTo1):
    def __init__(self, sim : System, state : Signal, inputs : List [Signal] ):

        self.inputs = inputs
        self.state = state

        inputSignals = [state]
        inputSignals.extend(inputs)

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals )

    def config_request_define_output_types(self, inputTypes):

        # check weather the trigger input is int32
        if inputTypes[0] is not None:
            if dt.DataTypeInt32(1).isEqualTo( inputTypes[0] ) == 0:
                raise BaseException(&#39;state input must be of type Int32&#39;)  

        # determine a guess for the output datatype
        # check if all given datatypes are equal
        autoDatatype = get_unique_datatype_from_io_typespe_from_io_types(self.outputs[0].getDatatype(), inputTypes[1:-1] )

        return [ autoDatatype ]

    #def generate_code_output(self, language, signal : Signal):
    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = &#39;\n// switch &#39; + str(len(self.inputs)) + &#39; inputs --&gt; &#39; + self.state.name + &#39;\n&#39;
            i = 1
            for ip in self.inputs:
                if i == 1:
                    lines += &#39;if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;
                else:
                    lines += &#39;else if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;

                lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + ip.name + &#39;;\n&#39;
                lines += &#39;} &#39;

                i += 1

            lines += &#39;else {\n&#39;
            lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            lines += &#39;}\n&#39;
            
            return lines



class ConditionalOverwrite(bi.StaticFn_NTo1):
    def __init__(self, sim : System, signal : Signal, condition : Signal, new_value ):

        self.new_value = new_value

        if isinstance( self.new_value, Signal ): 
            bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [signal, condition, new_value])
        else:
            bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [signal, condition])

    def config_request_define_output_types(self, inputTypes):

        # just inherit the input type
        if isinstance( self.new_value, Signal ): 
            return [ dt.common_numeric_type( inputTypes ) ]

        else:
            return [ inputTypes[0] ]


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:

            if isinstance( self.new_value, Signal ): 
                action_overwrite = self.outputs[0].name + &#39; = &#39; + self.inputSignals[2].name + &#39;;&#39;

            else:                
                action_overwrite = self.outputs[0].name + &#39; = &#39; + str( self.new_value ) + &#39;;&#39;

            action_keep = self.outputs[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;&#39;

            lines = cgh.generate_if_else( language, condition_list=[ self.inputSignals[1].name ], action_list=[ action_overwrite, action_keep ] )
            return lines




#
# Static functions that map 1 --&gt; 1
#

class StaticFnByName_1To1(bi.StaticFn_1To1):
    def __init__(self, sim : System, u : Signal, functionName : str ):

        self._functionName = functionName

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._functionName) + &#39;(&#39; + self.inputs[0].name +  &#39;);\n&#39;




class Operator0(bi.StaticFn_1To1):
    def __init__(self, sim : System, u : Signal, operator_str : str ):

        self._operator_str = operator_str

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._operator_str) + self.inputs[0].name +  &#39;;\n&#39;






#
# static functinos that map 2 --&gt; 1
#

class StaticFnByName_2To1(bi.StaticFn_NTo1):
    def __init__(self, sim : System, left : Signal, right : Signal, function_name : str ):

        self._function_name = function_name

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [left, right])

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = signals[0].name + &#39; = &#39; + self._function_name + &#39;(&#39; + self.inputSignals[0].name +  &#39;, &#39; + self.inputSignals[1].name + &#39;)&#39; + &#39;;\n&#39;
            return lines








class GenericCppStatic(bi.BlockPrototype):
    def __init__(self, sim : System, input_signals : List[Signal], input_names : List [str], input_types, output_names : List[str], output_types, cpp_source_code : str ):

        Ninputs = len(input_names)

        if not Ninputs == len(input_types):
            raise BaseException(&#39;not Ninputs == len(input_types)&#39;)

        if not Ninputs == len(input_signals):
            raise BaseException(&#39;not Ninputs == len)(input_signals)&#39;)

        if not len(output_names) == len(output_types):
            raise BaseException(&#39;not len(output_names) == len(output_types)&#39;)

        self._input_signals = input_signals
        self._input_names = input_names
        self._input_types = input_types
        self._output_names = output_names
        self._output_types = output_types
        self._cpp_source_code = cpp_source_code

        bi.BlockPrototype.__init__(self, sim, input_signals, len(output_names), output_types  )

        self._static_function_name = &#39;fn_static_&#39; + str(self.id)

    def config_request_define_output_types(self, inputTypes):

        for i in range(0, len(inputTypes)):
            if inputTypes[i] is not None and not inputTypes[i].isEqualTo( self._input_types[i] ):
                raise BaseException(&#39;GenericCppStatic: datatype missmatch for input # &#39; + str(i) )

        # return a proposal for an output type. 
        return self._output_types

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # the output depends on all inputs
        return self.inputs 

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return None  # no states

    def codegen_addToNamespace(self, language):

        if language == &#39;c++&#39;:
            ilines = &#39;&#39;

            info_comment_1 = &#39;// begin of user defined function\n&#39;
            info_comment_2 = &#39;\n// end of user defined function\n&#39;

            ilines += cgh.cpp_define_function_from_types(self._static_function_name, self._input_types, self._input_names, self._output_types, self._output_names, info_comment_1 + self._cpp_source_code + info_comment_2 )

            return ilines

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:

            ilines = &#39;&#39;

            # create tmp output variables
            tmp_output_variable_names = []
            for i in range(0, len(self._output_names)):
                tmp_variable_name = self._static_function_name + &#39;_&#39; + self._output_names[i]
                tmp_output_variable_names.append( tmp_variable_name )
                ilines += self._output_types[i].cpp_define_variable(variable_name=tmp_variable_name) + &#39;;\n&#39;

            # function call
            ilines += cgh.call_function_from_varnames( self._static_function_name, cgh.signal_list_to_name_list(self.inputs), tmp_output_variable_names)

            # copy outputs from tmp variables
            for i in range(0, len(self._output_names)):

                # only copy the needed outputs as indicated by &#39;signals&#39;
                if self.outputs[i] in signals:
                    ilines += self.outputs[i].name + &#39; = &#39; + tmp_output_variable_names[i] + &#39;;\n&#39;

            return &#39;{ // calling the static function &#39; + self._static_function_name + &#39;\n&#39; + cgh.indent(ilines) + &#39;}\n&#39;







#
# Blocks that have an internal memory
#



class Delay(bi.BlockPrototype):
    def __init__(self, sim : System, u : Signal, initial_state = None ):

        self._initial_state = initial_state
        bi.BlockPrototype.__init__(self, sim, [ u ], 1)

    def config_request_define_output_types(self, inputTypes):

        # just inherit the input type 
        output_type = inputTypes[0]

        return [ output_type ]        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # no (direct feedtrough) dependence on any input - only state dependent
        return [  ]

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return self.inputs  # all inputs

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            return self.outputs[0].datatype.cpp_define_variable( self.getUniqueVarnamePrefix() + &#39;_mem&#39; )  + &#39;;\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39;;\n&#39;

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            lines = self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            if self._initial_state is None:
                # get the zero element for the given datatype
                initial_state_str = str(self.outputs[0].datatype.cpp_zero_element)
            else:
                initial_state_str = str(self._initial_state)

            return self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;








class Flipflop(bi.BlockPrototype):
    def __init__(self, sim : System, activate_trigger : Signal, disable_trigger : Signal, initial_state = False, nodelay = False ):

        self._nodelay = nodelay
        self._activate_trigger = activate_trigger
        self._disable_trigger  = disable_trigger
        self._initial_state    = initial_state

        bi.BlockPrototype.__init__(self, sim, [ activate_trigger, disable_trigger ], 1)

    def config_request_define_output_types(self, inputTypes):

        return [ dt.DataTypeBoolean(1) ]        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        if self._nodelay:
            # (direct feedtrough) dependence on all inputs
            return self.inputs
        else:
            # no direct feedthrough
            return []

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return self.inputs  # all inputs

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            return self.outputs[0].datatype.cpp_define_variable( self.getUniqueVarnamePrefix() + &#39;_state&#39; )  + &#39;;\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            
            state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;

            lines = signals[0].name + &#39; = &#39; + state_varname + &#39;;\n&#39;
            if self._nodelay:
                lines += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + signals[0].name + &#39;;\n&#39;
                lines += signals[0].name + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + signals[0].name + &#39;;\n&#39;

            return lines

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;
            lines = state_varname + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + state_varname + &#39;;\n&#39;
            lines += state_varname + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + state_varname + &#39;;\n&#39;
            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            if self._initial_state:
                # get the zero element for the given datatype
                initial_state_str = &#39;true&#39;
            else:
                initial_state_str = &#39;false&#39;

            return self.getUniqueVarnamePrefix() + &#39;_state&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;




#
# memory / array to store / read values
#

class Memory(bi.BlockPrototype):
    def __init__(self, sim : System, datatype, constant_array, write_index : Signal = None, value : Signal = None ):

        self._constant_array = constant_array
        self._length         = len(constant_array)
        self._array_datatype = dt.DataTypeArray( self._length, datatype )

        if write_index is None:
            self._static = True
        elif value is not None:
            self._static = False
        else:
            raise BaseException(&#39;Memory: write_index was defined but no value to write&#39;)

        # call super
        if self._static:
            bi.BlockPrototype.__init__(self, sim, inputSignals = [], N_outputs = 1, output_datatype_list = [self._array_datatype]  )
        else:
            bi.BlockPrototype.__init__(self, sim, inputSignals = [write_index, value], N_outputs = 1, output_datatype_list = [self._array_datatype]  )

        # indicate that the output of this port is passed by reference in c++
        self.outputs[0].set_is_referencing_memory(True)

        self.outputs[0].properties_internal[&#39;memory_length&#39;] = self._length

    # TODO: not sure if this is ever beeing called as the output datatypes are already specified in the constructor
    def config_request_define_output_types(self, inputTypes):
        # define the output type 
        return [ self._array_datatype ]

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # the output depends on nothing
        return []
            
    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states

        if self._static:
            return []  # no states
        else:
            return [self.inputs[0], self.inputs[1]]

    #
    # code gen
    #

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:

            # encode the given data and initialize a C array
            csv_array = &#39;,&#39;.join([str(x) for x in self._constant_array])
            return self._array_datatype.cpp_define_variable(  self.getUniqueVarnamePrefix() + &#39;_array&#39; ) + &#39; {&#39; + csv_array + &#39;};\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            # place a reference
            return cgh.defineVariable( signals[0], make_a_reference=True ) + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_array&#39; + &#39;;\n&#39;

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            if self._static:
                return &#39;&#39;

            code = &#39;&#39; +  self.inputs[0].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

            code += self.getUniqueVarnamePrefix() + &#39;_array[tmp] = &#39; + self.inputs[1].name + &#39;;\n&#39;

            return cgh.brackets(code)

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:
            # TODO
            return &#39;// WARNIG: reset of memory not implemented\n&#39;






class MemoryRead(bi.StaticFn_NTo1):
    def __init__(self, sim : System, memory : Signal, index : Signal ):

        if &#39;memory_length&#39; not in memory.properties_internal:
            raise BaseException(&#39;No property memory_length in input signal. Please create the input signal using memory()&#39;)

        self._length = memory.properties_internal[&#39;memory_length&#39;]

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [memory, index] )

    def config_request_define_output_types(self, inputTypes):
        # returt the datatype of the array elements
        return [ self.inputs[0].getDatatype().datatype_of_elements ]  

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:

            code = &#39;&#39; +  self.inputs[1].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[1].name + &#39;;\n&#39;
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

            code += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;[tmp];\n&#39;
            
            return cgh.brackets(code)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Add"><code class="flex name class">
<span>class <span class="ident">Add</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, inputSignals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>], factors: List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Add(bi.StaticFn_NTo1):
    def __init__(self, sim : System, inputSignals : List[Signal], factors : List[float] ):

        # feasibility checks
        if len(inputSignals) != len(factors):
            raise(&#34;len(inp_list) must be equal to len(factors)&#34;)

        self.factors = factors
        bi.StaticFn_NTo1.__init__(self, sim, inputSignals)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            strs = []
            i = 0
            for s in self.inputSignals:
                strs.append(  str(self.factors[i]) + &#39; * &#39; + s.name )
                i = i + 1

            sumline = &#39; + &#39;.join( strs )
            lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Add.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        strs = []
        i = 0
        for s in self.inputSignals:
            strs.append(  str(self.factors[i]) + &#39; * &#39; + s.name )
            i = i + 1

        sumline = &#39; + &#39;.join( strs )
        lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.ComparisionOperator"><code class="flex name class">
<span>class <span class="ident">ComparisionOperator</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, left: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, right: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, operator: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ComparisionOperator(bi.StaticFn_NTo1):
    def __init__(self, sim : System, left : Signal, right : Signal, operator : str ):

        self.operator = operator

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [left, right])

    def config_request_define_output_types(self, inputTypes):

        # return a proposal for an output type. 
        return [ dt.DataTypeBoolean(1) ]

    # def generate_code_output(self, language, signal : Signal):
    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = signals[0].name + &#39; = &#39; + self.inputSignals[0].name + &#39; &#39; + self.operator + &#39; &#39; + self.inputSignals[1].name + &#39;;\n&#39;
            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.ComparisionOperator.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # return a proposal for an output type. 
    return [ dt.DataTypeBoolean(1) ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.ComparisionOperator.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        lines = signals[0].name + &#39; = &#39; + self.inputSignals[0].name + &#39; &#39; + self.operator + &#39; &#39; + self.inputSignals[1].name + &#39;;\n&#39;
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.ConditionalOverwrite"><code class="flex name class">
<span>class <span class="ident">ConditionalOverwrite</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, signal: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, condition: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, new_value)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConditionalOverwrite(bi.StaticFn_NTo1):
    def __init__(self, sim : System, signal : Signal, condition : Signal, new_value ):

        self.new_value = new_value

        if isinstance( self.new_value, Signal ): 
            bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [signal, condition, new_value])
        else:
            bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [signal, condition])

    def config_request_define_output_types(self, inputTypes):

        # just inherit the input type
        if isinstance( self.new_value, Signal ): 
            return [ dt.common_numeric_type( inputTypes ) ]

        else:
            return [ inputTypes[0] ]


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:

            if isinstance( self.new_value, Signal ): 
                action_overwrite = self.outputs[0].name + &#39; = &#39; + self.inputSignals[2].name + &#39;;&#39;

            else:                
                action_overwrite = self.outputs[0].name + &#39; = &#39; + str( self.new_value ) + &#39;;&#39;

            action_keep = self.outputs[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;&#39;

            lines = cgh.generate_if_else( language, condition_list=[ self.inputSignals[1].name ], action_list=[ action_overwrite, action_keep ] )
            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.ConditionalOverwrite.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # just inherit the input type
    if isinstance( self.new_value, Signal ): 
        return [ dt.common_numeric_type( inputTypes ) ]

    else:
        return [ inputTypes[0] ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.ConditionalOverwrite.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:

        if isinstance( self.new_value, Signal ): 
            action_overwrite = self.outputs[0].name + &#39; = &#39; + self.inputSignals[2].name + &#39;;&#39;

        else:                
            action_overwrite = self.outputs[0].name + &#39; = &#39; + str( self.new_value ) + &#39;;&#39;

        action_keep = self.outputs[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;&#39;

        lines = cgh.generate_if_else( language, condition_list=[ self.inputSignals[1].name ], action_list=[ action_overwrite, action_keep ] )
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Const"><code class="flex name class">
<span>class <span class="ident">Const</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, constant, datatype)</span>
</code></dt>
<dd>
<div class="desc"><p>This defines a static source</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Const(bi.StaticSource_To1):
    def __init__(self, sim : System, constant, datatype ):

        self.constant = constant

        # call super
        bi.StaticSource_To1.__init__(self, sim, datatype)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str( self.constant ) + &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticSource_To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticSource_To1">StaticSource_To1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Const.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + str( self.constant ) + &#39;;\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticSource_To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticSource_To1">StaticSource_To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticSource_To1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.ConvertDatatype"><code class="flex name class">
<span>class <span class="ident">ConvertDatatype</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, target_type: <a title="openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType" href="diagram_core/datatypes/datatypes.html#openrtdynamics2.lang.diagram_core.datatypes.datatypes.DataType">DataType</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConvertDatatype(bi.StaticFn_1To1):
    def __init__(self, sim : System, u : Signal, target_type : dt.DataType ):

        self._target_type = target_type

        bi.StaticFn_1To1.__init__(self, sim, u)

    def config_request_define_output_types(self, inputTypes):
        return [ self._target_type ]  

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            # TODO: only = is used and the c++ compiler decides how to convert...
            return signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_1To1">StaticFn_1To1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.ConvertDatatype.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):
    return [ self._target_type ]  </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.ConvertDatatype.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        # TODO: only = is used and the c++ compiler decides how to convert...
        return signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_1To1">StaticFn_1To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Delay"><code class="flex name class">
<span>class <span class="ident">Delay</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, initial_state=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Delay(bi.BlockPrototype):
    def __init__(self, sim : System, u : Signal, initial_state = None ):

        self._initial_state = initial_state
        bi.BlockPrototype.__init__(self, sim, [ u ], 1)

    def config_request_define_output_types(self, inputTypes):

        # just inherit the input type 
        output_type = inputTypes[0]

        return [ output_type ]        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # no (direct feedtrough) dependence on any input - only state dependent
        return [  ]

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return self.inputs  # all inputs

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            return self.outputs[0].datatype.cpp_define_variable( self.getUniqueVarnamePrefix() + &#39;_mem&#39; )  + &#39;;\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39;;\n&#39;

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            lines = self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            if self._initial_state is None:
                # get the zero element for the given datatype
                initial_state_str = str(self.outputs[0].datatype.cpp_zero_element)
            else:
                initial_state_str = str(self._initial_state)

            return self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Delay.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # just inherit the input type 
    output_type = inputTypes[0]

    return [ output_type ]        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Delay.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39;;\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Delay.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:

        if self._initial_state is None:
            # get the zero element for the given datatype
            initial_state_str = str(self.outputs[0].datatype.cpp_zero_element)
        else:
            initial_state_str = str(self._initial_state)

        return self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Delay.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):
    if language == &#39;c++&#39;:

        lines = self.getUniqueVarnamePrefix() + &#39;_mem&#39; + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Flipflop"><code class="flex name class">
<span>class <span class="ident">Flipflop</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, activate_trigger: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, disable_trigger: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, initial_state=False, nodelay=False)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Flipflop(bi.BlockPrototype):
    def __init__(self, sim : System, activate_trigger : Signal, disable_trigger : Signal, initial_state = False, nodelay = False ):

        self._nodelay = nodelay
        self._activate_trigger = activate_trigger
        self._disable_trigger  = disable_trigger
        self._initial_state    = initial_state

        bi.BlockPrototype.__init__(self, sim, [ activate_trigger, disable_trigger ], 1)

    def config_request_define_output_types(self, inputTypes):

        return [ dt.DataTypeBoolean(1) ]        

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        if self._nodelay:
            # (direct feedtrough) dependence on all inputs
            return self.inputs
        else:
            # no direct feedthrough
            return []

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return self.inputs  # all inputs

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:
            return self.outputs[0].datatype.cpp_define_variable( self.getUniqueVarnamePrefix() + &#39;_state&#39; )  + &#39;;\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            
            state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;

            lines = signals[0].name + &#39; = &#39; + state_varname + &#39;;\n&#39;
            if self._nodelay:
                lines += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + signals[0].name + &#39;;\n&#39;
                lines += signals[0].name + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + signals[0].name + &#39;;\n&#39;

            return lines

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;
            lines = state_varname + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + state_varname + &#39;;\n&#39;
            lines += state_varname + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + state_varname + &#39;;\n&#39;
            return lines

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            if self._initial_state:
                # get the zero element for the given datatype
                initial_state_str = &#39;true&#39;
            else:
                initial_state_str = &#39;false&#39;

            return self.getUniqueVarnamePrefix() + &#39;_state&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Flipflop.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    return [ dt.DataTypeBoolean(1) ]        </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        
        state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;

        lines = signals[0].name + &#39; = &#39; + state_varname + &#39;;\n&#39;
        if self._nodelay:
            lines += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + signals[0].name + &#39;;\n&#39;
            lines += signals[0].name + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + signals[0].name + &#39;;\n&#39;

        return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:

        if self._initial_state:
            # get the zero element for the given datatype
            initial_state_str = &#39;true&#39;
        else:
            initial_state_str = &#39;false&#39;

        return self.getUniqueVarnamePrefix() + &#39;_state&#39; + &#39; = &#39; + initial_state_str + &#39;;\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):
    if language == &#39;c++&#39;:

        state_varname = self.getUniqueVarnamePrefix() + &#39;_state&#39;
        lines = state_varname + &#39; = &#39; + self.inputs[0].name + &#39; ? true : &#39; + state_varname + &#39;;\n&#39;
        lines += state_varname + &#39; = &#39; + self.inputs[1].name + &#39; ? false : &#39; + state_varname + &#39;;\n&#39;
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Gain"><code class="flex name class">
<span>class <span class="ident">Gain</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, factor: float)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Gain(bi.StaticFn_1To1):
    def __init__(self, sim : System, u : Signal, factor : float ):

        self._factor = factor

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._factor) + &#39; * &#39; + self.inputs[0].name +  &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_1To1">StaticFn_1To1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Gain.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + str(self._factor) + &#39; * &#39; + self.inputs[0].name +  &#39;;\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_1To1">StaticFn_1To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.GenericCppStatic"><code class="flex name class">
<span>class <span class="ident">GenericCppStatic</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, input_signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>], input_names: List[str], input_types, output_names: List[str], output_types, cpp_source_code: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GenericCppStatic(bi.BlockPrototype):
    def __init__(self, sim : System, input_signals : List[Signal], input_names : List [str], input_types, output_names : List[str], output_types, cpp_source_code : str ):

        Ninputs = len(input_names)

        if not Ninputs == len(input_types):
            raise BaseException(&#39;not Ninputs == len(input_types)&#39;)

        if not Ninputs == len(input_signals):
            raise BaseException(&#39;not Ninputs == len)(input_signals)&#39;)

        if not len(output_names) == len(output_types):
            raise BaseException(&#39;not len(output_names) == len(output_types)&#39;)

        self._input_signals = input_signals
        self._input_names = input_names
        self._input_types = input_types
        self._output_names = output_names
        self._output_types = output_types
        self._cpp_source_code = cpp_source_code

        bi.BlockPrototype.__init__(self, sim, input_signals, len(output_names), output_types  )

        self._static_function_name = &#39;fn_static_&#39; + str(self.id)

    def config_request_define_output_types(self, inputTypes):

        for i in range(0, len(inputTypes)):
            if inputTypes[i] is not None and not inputTypes[i].isEqualTo( self._input_types[i] ):
                raise BaseException(&#39;GenericCppStatic: datatype missmatch for input # &#39; + str(i) )

        # return a proposal for an output type. 
        return self._output_types

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # the output depends on all inputs
        return self.inputs 

    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states
        return None  # no states

    def codegen_addToNamespace(self, language):

        if language == &#39;c++&#39;:
            ilines = &#39;&#39;

            info_comment_1 = &#39;// begin of user defined function\n&#39;
            info_comment_2 = &#39;\n// end of user defined function\n&#39;

            ilines += cgh.cpp_define_function_from_types(self._static_function_name, self._input_types, self._input_names, self._output_types, self._output_names, info_comment_1 + self._cpp_source_code + info_comment_2 )

            return ilines

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:

            ilines = &#39;&#39;

            # create tmp output variables
            tmp_output_variable_names = []
            for i in range(0, len(self._output_names)):
                tmp_variable_name = self._static_function_name + &#39;_&#39; + self._output_names[i]
                tmp_output_variable_names.append( tmp_variable_name )
                ilines += self._output_types[i].cpp_define_variable(variable_name=tmp_variable_name) + &#39;;\n&#39;

            # function call
            ilines += cgh.call_function_from_varnames( self._static_function_name, cgh.signal_list_to_name_list(self.inputs), tmp_output_variable_names)

            # copy outputs from tmp variables
            for i in range(0, len(self._output_names)):

                # only copy the needed outputs as indicated by &#39;signals&#39;
                if self.outputs[i] in signals:
                    ilines += self.outputs[i].name + &#39; = &#39; + tmp_output_variable_names[i] + &#39;;\n&#39;

            return &#39;{ // calling the static function &#39; + self._static_function_name + &#39;\n&#39; + cgh.indent(ilines) + &#39;}\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.GenericCppStatic.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    for i in range(0, len(inputTypes)):
        if inputTypes[i] is not None and not inputTypes[i].isEqualTo( self._input_types[i] ):
            raise BaseException(&#39;GenericCppStatic: datatype missmatch for input # &#39; + str(i) )

    # return a proposal for an output type. 
    return self._output_types</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.GenericCppStatic.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:

        ilines = &#39;&#39;

        # create tmp output variables
        tmp_output_variable_names = []
        for i in range(0, len(self._output_names)):
            tmp_variable_name = self._static_function_name + &#39;_&#39; + self._output_names[i]
            tmp_output_variable_names.append( tmp_variable_name )
            ilines += self._output_types[i].cpp_define_variable(variable_name=tmp_variable_name) + &#39;;\n&#39;

        # function call
        ilines += cgh.call_function_from_varnames( self._static_function_name, cgh.signal_list_to_name_list(self.inputs), tmp_output_variable_names)

        # copy outputs from tmp variables
        for i in range(0, len(self._output_names)):

            # only copy the needed outputs as indicated by &#39;signals&#39;
            if self.outputs[i] in signals:
                ilines += self.outputs[i].name + &#39; = &#39; + tmp_output_variable_names[i] + &#39;;\n&#39;

        return &#39;{ // calling the static function &#39; + self._static_function_name + &#39;\n&#39; + cgh.indent(ilines) + &#39;}\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem"><code class="flex name class">
<span>class <span class="ident">LoopUntilSubsystem</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, max_iterations: int, subsystem_prototype: <a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem" href="block_prototypes_subsystems.html#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem">GenericSubsystem</a>, until_signal: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a> = None, yield_signal: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Embed a loop sub-system</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoopUntilSubsystem(SingleSubsystemEmbedder):
    &#34;&#34;&#34;
        Embed a loop sub-system

    &#34;&#34;&#34;

    def __init__(self, sim : System, max_iterations : int, 
                    subsystem_prototype : GenericSubsystem, 
                    until_signal : Signal = None, yield_signal : Signal = None ):
        
        self.max_iter = max_iterations
        self._until_signal = until_signal
        self._yield_signal = yield_signal

        number_of_control_outputs = 0
        if self._until_signal is not None:
            number_of_control_outputs += 1

        if self._yield_signal is not None:
            number_of_control_outputs += 1


        SingleSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[],   # TODO: add N_iter signal here 
                                        subsystem_prototype=subsystem_prototype, 
                                        number_of_control_outputs=number_of_control_outputs )


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            assign_to_signals = []
            ouput_signals_of_subsystem = []

            assign_to_signals.extend(signals)
            ouput_signals_of_subsystem.extend(self.outputs_map_from_embedding_block_to_subsystem.map( signals )) # output signal mapping lookup

            control_output_index = 0

            if self._until_signal is not None:
                # define tmp-var for self._until_signal instead of a block output
                lines += cgh.defineVariables( [self._until_signal] )

                # add list of signals to assign
                assign_to_signals.append( self._until_signal )
                ouput_signals_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index] )
            
                control_output_index += 1


            if self._yield_signal is not None:
                # define tmp-var for self._yield_signal instead of a block output
                lines += cgh.defineVariables( [self._yield_signal] )

                # add list of signals to assign
                assign_to_signals.append( self._yield_signal )
                ouput_signals_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index] )

                control_output_index += 1



            calc_outputs = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                assign_to_signals=assign_to_signals, 
                ouput_signals_of_subsystem=ouput_signals_of_subsystem,
                calculate_outputs = True, update_states = False
            )

            

            update_states = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                calculate_outputs = False, update_states = True
            )

            code = &#39;&#39;
            code +=  calc_outputs 
            code += update_states

            if self._yield_signal is not None:
                code += cgh.generate_loop_break(language, condition=self._yield_signal.name)

            if self._until_signal is not None:

                code_reset_subsystem = embed_subsystem3(
                    language, 
                    subsystem_prototype=self._subsystem_prototype, 
                    calculate_outputs = False, update_states = False,
                    reset_states = True
                )

                code += cgh.generate_loop_break(language, condition=self._until_signal.name, code_before_break=code_reset_subsystem)

            lines += cgh.generate_loop( language, max_iterations=str(self.max_iter), code_to_exec=code  )

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            if self._until_signal is not None:
                pass    
                #lines += self._subsystem_prototype.generate_code_reset(language)


        return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder" href="block_prototypes_single_subsystem.html#openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        assign_to_signals = []
        ouput_signals_of_subsystem = []

        assign_to_signals.extend(signals)
        ouput_signals_of_subsystem.extend(self.outputs_map_from_embedding_block_to_subsystem.map( signals )) # output signal mapping lookup

        control_output_index = 0

        if self._until_signal is not None:
            # define tmp-var for self._until_signal instead of a block output
            lines += cgh.defineVariables( [self._until_signal] )

            # add list of signals to assign
            assign_to_signals.append( self._until_signal )
            ouput_signals_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index] )
        
            control_output_index += 1


        if self._yield_signal is not None:
            # define tmp-var for self._yield_signal instead of a block output
            lines += cgh.defineVariables( [self._yield_signal] )

            # add list of signals to assign
            assign_to_signals.append( self._yield_signal )
            ouput_signals_of_subsystem.append( self._control_signals_from_embeded_system[control_output_index] )

            control_output_index += 1



        calc_outputs = embed_subsystem3(
            language, 
            subsystem_prototype=self._subsystem_prototype, 
            assign_to_signals=assign_to_signals, 
            ouput_signals_of_subsystem=ouput_signals_of_subsystem,
            calculate_outputs = True, update_states = False
        )

        

        update_states = embed_subsystem3(
            language, 
            subsystem_prototype=self._subsystem_prototype, 
            calculate_outputs = False, update_states = True
        )

        code = &#39;&#39;
        code +=  calc_outputs 
        code += update_states

        if self._yield_signal is not None:
            code += cgh.generate_loop_break(language, condition=self._yield_signal.name)

        if self._until_signal is not None:

            code_reset_subsystem = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                calculate_outputs = False, update_states = False,
                reset_states = True
            )

            code += cgh.generate_loop_break(language, condition=self._until_signal.name, code_before_break=code_reset_subsystem)

        lines += cgh.generate_loop( language, max_iterations=str(self.max_iter), code_to_exec=code  )

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        if self._until_signal is not None:
            pass    
            #lines += self._subsystem_prototype.generate_code_reset(language)


    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder" href="block_prototypes_single_subsystem.html#openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Memory"><code class="flex name class">
<span>class <span class="ident">Memory</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, datatype, constant_array, write_index: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a> = None, value: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a> = None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Memory(bi.BlockPrototype):
    def __init__(self, sim : System, datatype, constant_array, write_index : Signal = None, value : Signal = None ):

        self._constant_array = constant_array
        self._length         = len(constant_array)
        self._array_datatype = dt.DataTypeArray( self._length, datatype )

        if write_index is None:
            self._static = True
        elif value is not None:
            self._static = False
        else:
            raise BaseException(&#39;Memory: write_index was defined but no value to write&#39;)

        # call super
        if self._static:
            bi.BlockPrototype.__init__(self, sim, inputSignals = [], N_outputs = 1, output_datatype_list = [self._array_datatype]  )
        else:
            bi.BlockPrototype.__init__(self, sim, inputSignals = [write_index, value], N_outputs = 1, output_datatype_list = [self._array_datatype]  )

        # indicate that the output of this port is passed by reference in c++
        self.outputs[0].set_is_referencing_memory(True)

        self.outputs[0].properties_internal[&#39;memory_length&#39;] = self._length

    # TODO: not sure if this is ever beeing called as the output datatypes are already specified in the constructor
    def config_request_define_output_types(self, inputTypes):
        # define the output type 
        return [ self._array_datatype ]

    def config_request_define_feedforward_input_dependencies(self, outputSignal):
        # return a list of input signals on which the given output signal depends on

        # the output depends on nothing
        return []
            
    def config_request_define_state_update_input_dependencies(self, outputSignal):
        # return a list of input signals that are required to update the states

        if self._static:
            return []  # no states
        else:
            return [self.inputs[0], self.inputs[1]]

    #
    # code gen
    #

    def generate_code_defStates(self, language):
        if language == &#39;c++&#39;:

            # encode the given data and initialize a C array
            csv_array = &#39;,&#39;.join([str(x) for x in self._constant_array])
            return self._array_datatype.cpp_define_variable(  self.getUniqueVarnamePrefix() + &#39;_array&#39; ) + &#39; {&#39; + csv_array + &#39;};\n&#39;

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            # place a reference
            return cgh.defineVariable( signals[0], make_a_reference=True ) + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_array&#39; + &#39;;\n&#39;

    def generate_code_update(self, language):
        if language == &#39;c++&#39;:

            if self._static:
                return &#39;&#39;

            code = &#39;&#39; +  self.inputs[0].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

            code += self.getUniqueVarnamePrefix() + &#39;_array[tmp] = &#39; + self.inputs[1].name + &#39;;\n&#39;

            return cgh.brackets(code)

    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:
            # TODO
            return &#39;// WARNIG: reset of memory not implemented\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Memory.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):
    # define the output type 
    return [ self._array_datatype ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Memory.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        # place a reference
        return cgh.defineVariable( signals[0], make_a_reference=True ) + &#39; = &#39; + self.getUniqueVarnamePrefix() + &#39;_array&#39; + &#39;;\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Memory.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:
        # TODO
        return &#39;// WARNIG: reset of memory not implemented\n&#39;</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Memory.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):
    if language == &#39;c++&#39;:

        if self._static:
            return &#39;&#39;

        code = &#39;&#39; +  self.inputs[0].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
        code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
        code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

        code += self.getUniqueVarnamePrefix() + &#39;_array[tmp] = &#39; + self.inputs[1].name + &#39;;\n&#39;

        return cgh.brackets(code)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.MemoryRead"><code class="flex name class">
<span>class <span class="ident">MemoryRead</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, memory: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, index: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MemoryRead(bi.StaticFn_NTo1):
    def __init__(self, sim : System, memory : Signal, index : Signal ):

        if &#39;memory_length&#39; not in memory.properties_internal:
            raise BaseException(&#39;No property memory_length in input signal. Please create the input signal using memory()&#39;)

        self._length = memory.properties_internal[&#39;memory_length&#39;]

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [memory, index] )

    def config_request_define_output_types(self, inputTypes):
        # returt the datatype of the array elements
        return [ self.inputs[0].getDatatype().datatype_of_elements ]  

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:

            code = &#39;&#39; +  self.inputs[1].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[1].name + &#39;;\n&#39;
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
            code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

            code += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;[tmp];\n&#39;
            
            return cgh.brackets(code)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.MemoryRead.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):
    # returt the datatype of the array elements
    return [ self.inputs[0].getDatatype().datatype_of_elements ]  </code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.MemoryRead.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:

        code = &#39;&#39; +  self.inputs[1].datatype.cpp_define_variable(variable_name=&#39;tmp&#39;) + &#39; = &#39; + self.inputs[1].name + &#39;;\n&#39;
        code += cgh.generate_if_else(language, condition_list= [&#39;tmp &lt; 0&#39;], action_list=[&#39;tmp = 0;&#39;])
        code += cgh.generate_if_else(language, condition_list= [&#39;tmp &gt;= &#39; + str(self._length) ], action_list=[ &#39;tmp = &#39; + str(self._length-1) + &#39;;&#39; ])

        code += signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;[tmp];\n&#39;
        
        return cgh.brackets(code)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Operator0"><code class="flex name class">
<span>class <span class="ident">Operator0</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, operator_str: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Operator0(bi.StaticFn_1To1):
    def __init__(self, sim : System, u : Signal, operator_str : str ):

        self._operator_str = operator_str

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._operator_str) + self.inputs[0].name +  &#39;;\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_1To1">StaticFn_1To1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Operator0.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + str(self._operator_str) + self.inputs[0].name +  &#39;;\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_1To1">StaticFn_1To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.Operator1"><code class="flex name class">
<span>class <span class="ident">Operator1</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, inputSignals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>], operator: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Operator1(bi.StaticFn_NTo1):
    def __init__(self, sim : System, inputSignals : List[Signal], operator : str ):

        self.operator = operator
        bi.StaticFn_NTo1.__init__(self, sim, inputSignals)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            strs = []
            i = 0
            for s in self.inputSignals:
                strs.append(  str(  s.name ) )
                i = i + 1

            sumline = (&#39; &#39; + self.operator + &#39; &#39;).join( strs )
            lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.Operator1.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        strs = []
        i = 0
        for s in self.inputSignals:
            strs.append(  str(  s.name ) )
            i = i + 1

        sumline = (&#39; &#39; + self.operator + &#39; &#39;).join( strs )
        lines = signals[0].name + &#39; = &#39; + sumline + &#39;;\n&#39;

        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems"><code class="flex name class">
<span>class <span class="ident">StatemachineSwitchSubsystems</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, subsystem_prototypes: List[<a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem" href="block_prototypes_subsystems.html#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem">GenericSubsystem</a>], reference_outputs: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>Implement a state machine in which the states are represented by subsystems.
State transitions are performed in case a special control output of the currently
active subsystem indicates a transition to the next state.</p>
<p>self.state_output
-</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatemachineSwitchSubsystems(MultiSubsystemEmbedder):
    &#34;&#34;&#34;
        Implement a state machine in which the states are represented by subsystems.
        State transitions are performed in case a special control output of the currently
        active subsystem indicates a transition to the next state.

        self.state_output  - 
    &#34;&#34;&#34;

    def __init__(self, sim : System, subsystem_prototypes : List [GenericSubsystem], reference_outputs : List [Signal] ):
        
        MultiSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[], 
                                        subsystem_prototypes=subsystem_prototypes, 
                                        switch_reference_outputs=reference_outputs,
                                        number_of_control_outputs = 1 )

        # how to add more outputs?
        self.state_output.setDatatype( dt.DataTypeInt32(1) )

        # this output signals must be compted in any way
        # also in case it is not used by other blocks
        sim.add_signal_mandatory_to_compute( self.state_output )


    @property
    def state_output(self):
        return self.control_outputs[0]


    def generate_code_reset(self, language):
        if language == &#39;c++&#39;:

            lines = self._state_memory + &#39; = 0;\n&#39; # add something

            lines += MultiSubsystemEmbedder.generate_code_reset(self, language)

            return lines


    def generate_code_defStates(self, language):
        lines = MultiSubsystemEmbedder.generate_code_defStates(self, language)

        self._state_memory = self.getUniqueVarnamePrefix() + &#39;state&#39;
        lines += &#39;int &#39; + self._state_memory + &#39; {0};&#39;
        
        return lines


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            lines += self.codegen_help_generate_switch( language=language, 
                                            switch_control_signal_name=  self._state_memory ,
                                            switch_ouput_signals=signals,
                                            additional_outputs=[self.state_output] )

        return lines


    # code_gen helper
    def generate_switch_to_reset_leaving_subsystem( self, language, switch_control_signal_name ):

        lines = &#39;&#39;

        action_list = []
        condition_list = []

        subsystem_counter = 0
        for system_prototype in self._subsystem_prototypes:

            code_reset_states = MultiSubsystemEmbedder.generate_reset( self, language, system_index=subsystem_counter ) 

            action_list.append(  code_reset_states )

            # generate conditions when to execute the respective subsystem 
            condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

            subsystem_counter += 1

        # combine conditions and their repective actions
        lines += cgh.generate_if_else(language, condition_list, action_list)

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            lines += self.codegen_help_generate_switch(
                language=language, 
                switch_control_signal_name=self._state_memory,
                calculate_outputs=False, 
                update_states=True
            )

            # get the signal issued by the currently active subsystem that describes the requests for a stare transition
            state_control_signal_from_subsystems = self.state_output

            # reset current subsystem in case a state transition is requested
            lines_reset_subsystem = self.generate_switch_to_reset_leaving_subsystem(language, self._state_memory )
            lines += cgh.generate_if_else(language, condition_list=[ state_control_signal_from_subsystems.name + &#39; &gt;= 0 &#39; ], action_list=[lines_reset_subsystem])

            # transition to the new state
            lines += self._state_memory + &#39; = (&#39; + state_control_signal_from_subsystems.name + &#39; &gt;= 0 ) ? (&#39;+ state_control_signal_from_subsystems.name + &#39;) : (&#39; + self._state_memory + &#39;);\n&#39;
            
        return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder" href="block_prototypes_switched_subsystems.html#openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.state_output"><code class="name">var <span class="ident">state_output</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state_output(self):
    return self.control_outputs[0]</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        lines += self.codegen_help_generate_switch( language=language, 
                                        switch_control_signal_name=  self._state_memory ,
                                        switch_ouput_signals=signals,
                                        additional_outputs=[self.state_output] )

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_reset"><code class="name flex">
<span>def <span class="ident">generate_code_reset</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_reset(self, language):
    if language == &#39;c++&#39;:

        lines = self._state_memory + &#39; = 0;\n&#39; # add something

        lines += MultiSubsystemEmbedder.generate_code_reset(self, language)

        return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        lines += self.codegen_help_generate_switch(
            language=language, 
            switch_control_signal_name=self._state_memory,
            calculate_outputs=False, 
            update_states=True
        )

        # get the signal issued by the currently active subsystem that describes the requests for a stare transition
        state_control_signal_from_subsystems = self.state_output

        # reset current subsystem in case a state transition is requested
        lines_reset_subsystem = self.generate_switch_to_reset_leaving_subsystem(language, self._state_memory )
        lines += cgh.generate_if_else(language, condition_list=[ state_control_signal_from_subsystems.name + &#39; &gt;= 0 &#39; ], action_list=[lines_reset_subsystem])

        # transition to the new state
        lines += self._state_memory + &#39; = (&#39; + state_control_signal_from_subsystems.name + &#39; &gt;= 0 ) ? (&#39;+ state_control_signal_from_subsystems.name + &#39;) : (&#39; + self._state_memory + &#39;);\n&#39;
        
    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_switch_to_reset_leaving_subsystem"><code class="name flex">
<span>def <span class="ident">generate_switch_to_reset_leaving_subsystem</span></span>(<span>self, language, switch_control_signal_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_switch_to_reset_leaving_subsystem( self, language, switch_control_signal_name ):

    lines = &#39;&#39;

    action_list = []
    condition_list = []

    subsystem_counter = 0
    for system_prototype in self._subsystem_prototypes:

        code_reset_states = MultiSubsystemEmbedder.generate_reset( self, language, system_index=subsystem_counter ) 

        action_list.append(  code_reset_states )

        # generate conditions when to execute the respective subsystem 
        condition_list.append( cgh.generate_compare_equality_to_constant( language, switch_control_signal_name , subsystem_counter ) )

        subsystem_counter += 1

    # combine conditions and their repective actions
    lines += cgh.generate_if_else(language, condition_list, action_list)

    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder" href="block_prototypes_switched_subsystems.html#openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.codegen_help_generate_switch" href="block_prototypes_switched_subsystems.html#openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.codegen_help_generate_switch">codegen_help_generate_switch</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_reset" href="block_prototypes_switched_subsystems.html#openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_reset">generate_reset</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.StaticFnByName_1To1"><code class="flex name class">
<span>class <span class="ident">StaticFnByName_1To1</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, u: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, functionName: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StaticFnByName_1To1(bi.StaticFn_1To1):
    def __init__(self, sim : System, u : Signal, functionName : str ):

        self._functionName = functionName

        bi.StaticFn_1To1.__init__(self, sim, u)

    def generate_code_output_list(self, language, signals : List [ Signal ] ):
        if language == &#39;c++&#39;:
            return signals[0].name + &#39; = &#39; + str(self._functionName) + &#39;(&#39; + self.inputs[0].name +  &#39;);\n&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_1To1">StaticFn_1To1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.StaticFnByName_1To1.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):
    if language == &#39;c++&#39;:
        return signals[0].name + &#39; = &#39; + str(self._functionName) + &#39;(&#39; + self.inputs[0].name +  &#39;);\n&#39;</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_1To1">StaticFn_1To1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_1To1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.StaticFnByName_2To1"><code class="flex name class">
<span>class <span class="ident">StaticFnByName_2To1</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, left: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, right: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, function_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StaticFnByName_2To1(bi.StaticFn_NTo1):
    def __init__(self, sim : System, left : Signal, right : Signal, function_name : str ):

        self._function_name = function_name

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals = [left, right])

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = signals[0].name + &#39; = &#39; + self._function_name + &#39;(&#39; + self.inputSignals[0].name +  &#39;, &#39; + self.inputSignals[1].name + &#39;)&#39; + &#39;;\n&#39;
            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.StaticFnByName_2To1.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        lines = signals[0].name + &#39; = &#39; + self._function_name + &#39;(&#39; + self.inputSignals[0].name +  &#39;, &#39; + self.inputSignals[1].name + &#39;)&#39; + &#39;;\n&#39;
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.SwitchNto1"><code class="flex name class">
<span>class <span class="ident">SwitchNto1</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, state: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, inputs: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>This is a base class to be deviated from each block type.
It contains logic to handle the input/ output types and
the parameters.</p>
<p>Herein, all technical stuff shall be hidden from the user and
the one, how, implements new blocks.</p>
<p>sim
- the system the block shall belong to
inputSignals
- a list of input signals
N_outputs
- prepare a number of nOutputs (optional in case output_datatype_list is given)
output_datatype_list
- a list of datetypes for each output (optional)</p>
<p>Note: the number of outputs must be defined</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwitchNto1(bi.StaticFn_NTo1):
    def __init__(self, sim : System, state : Signal, inputs : List [Signal] ):

        self.inputs = inputs
        self.state = state

        inputSignals = [state]
        inputSignals.extend(inputs)

        bi.StaticFn_NTo1.__init__(self, sim, inputSignals )

    def config_request_define_output_types(self, inputTypes):

        # check weather the trigger input is int32
        if inputTypes[0] is not None:
            if dt.DataTypeInt32(1).isEqualTo( inputTypes[0] ) == 0:
                raise BaseException(&#39;state input must be of type Int32&#39;)  

        # determine a guess for the output datatype
        # check if all given datatypes are equal
        autoDatatype = get_unique_datatype_from_io_typespe_from_io_types(self.outputs[0].getDatatype(), inputTypes[1:-1] )

        return [ autoDatatype ]

    #def generate_code_output(self, language, signal : Signal):
    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        if language == &#39;c++&#39;:
            lines = &#39;\n// switch &#39; + str(len(self.inputs)) + &#39; inputs --&gt; &#39; + self.state.name + &#39;\n&#39;
            i = 1
            for ip in self.inputs:
                if i == 1:
                    lines += &#39;if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;
                else:
                    lines += &#39;else if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;

                lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + ip.name + &#39;;\n&#39;
                lines += &#39;} &#39;

                i += 1

            lines += &#39;else {\n&#39;
            lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
            lines += &#39;}\n&#39;
            
            return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.SwitchNto1.config_request_define_output_types"><code class="name flex">
<span>def <span class="ident">config_request_define_output_types</span></span>(<span>self, inputTypes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_request_define_output_types(self, inputTypes):

    # check weather the trigger input is int32
    if inputTypes[0] is not None:
        if dt.DataTypeInt32(1).isEqualTo( inputTypes[0] ) == 0:
            raise BaseException(&#39;state input must be of type Int32&#39;)  

    # determine a guess for the output datatype
    # check if all given datatypes are equal
    autoDatatype = get_unique_datatype_from_io_typespe_from_io_types(self.outputs[0].getDatatype(), inputTypes[1:-1] )

    return [ autoDatatype ]</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.SwitchNto1.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    if language == &#39;c++&#39;:
        lines = &#39;\n// switch &#39; + str(len(self.inputs)) + &#39; inputs --&gt; &#39; + self.state.name + &#39;\n&#39;
        i = 1
        for ip in self.inputs:
            if i == 1:
                lines += &#39;if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;
            else:
                lines += &#39;else if (&#39; + self.state.name + &#39; == &#39; + str(i) + &#39;) {\n&#39;

            lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + ip.name + &#39;;\n&#39;
            lines += &#39;} &#39;

            i += 1

        lines += &#39;else {\n&#39;
        lines += &#39;  &#39; + signals[0].name + &#39; = &#39; + self.inputs[0].name + &#39;;\n&#39;
        lines += &#39;}\n&#39;
        
        return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1" href="block_interface.html#openrtdynamics2.lang.block_interface.StaticFn_NTo1">StaticFn_NTo1</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_interface.StaticFn_NTo1.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.SwitchSubsystems"><code class="flex name class">
<span>class <span class="ident">SwitchSubsystems</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, control_input: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, subsystem_prototypes: List[<a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem" href="block_prototypes_subsystems.html#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem">GenericSubsystem</a>], reference_outputs: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>A system that embeds multiple subsystems and a control input to switch in-between.
The outputs of the currently active subsystem are forwarded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SwitchSubsystems(MultiSubsystemEmbedder):
    &#34;&#34;&#34;
        A system that embeds multiple subsystems and a control input to switch in-between.
        The outputs of the currently active subsystem are forwarded.
    &#34;&#34;&#34;

    def __init__(self, sim : System, control_input : Signal, subsystem_prototypes : List [GenericSubsystem], reference_outputs : List [Signal] ):
        
        self._control_input = control_input

        MultiSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[control_input], 
                                        subsystem_prototypes=subsystem_prototypes, 
                                        switch_reference_outputs=reference_outputs,
                                        number_of_control_outputs=0 )

    def generate_code_defStates(self, language):
        lines = MultiSubsystemEmbedder.generate_code_defStates(self, language)
        
        return lines

    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            
            lines += self.codegen_help_generate_switch( 
                language=language,
                switch_control_signal_name=self._control_input.name,
                switch_ouput_signals=signals,
                additional_outputs=[],
                calculate_outputs = True, update_states = False
            )

        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            lines += self.codegen_help_generate_switch(
                language=language, 
                switch_control_signal_name=self._control_input.name,
                calculate_outputs=False, 
                update_states=True
            )

        return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder" href="block_prototypes_switched_subsystems.html#openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.SwitchSubsystems.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:
        
        lines += self.codegen_help_generate_switch( 
            language=language,
            switch_control_signal_name=self._control_input.name,
            switch_ouput_signals=signals,
            additional_outputs=[],
            calculate_outputs = True, update_states = False
        )

    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.SwitchSubsystems.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        lines += self.codegen_help_generate_switch(
            language=language, 
            switch_control_signal_name=self._control_input.name,
            calculate_outputs=False, 
            update_states=True
        )

    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder" href="block_prototypes_switched_subsystems.html#openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder">MultiSubsystemEmbedder</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.codegen_help_generate_switch" href="block_prototypes_switched_subsystems.html#openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.codegen_help_generate_switch">codegen_help_generate_switch</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_reset" href="block_prototypes_switched_subsystems.html#openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.generate_reset">generate_reset</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_switched_subsystems.MultiSubsystemEmbedder.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.TruggeredSubsystem"><code class="flex name class">
<span>class <span class="ident">TruggeredSubsystem</span></span>
<span>(</span><span>sim: <a title="openrtdynamics2.lang.diagram_core.system.System" href="diagram_core/system.html#openrtdynamics2.lang.diagram_core.system.System">System</a>, control_input: <a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>, subsystem_prototype: <a title="openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem" href="block_prototypes_subsystems.html#openrtdynamics2.lang.block_prototypes_subsystems.GenericSubsystem">GenericSubsystem</a>, prevent_output_computation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Include a triggered sub-system</p>
<h2 id="optional">Optional</h2>
<p>prevent_output_computation = True:
The subsystems outputs are only computed when triggered. Please note that the outputs
of the subsystem are uninitialized until the subsystem is triggered for the first time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TruggeredSubsystem(SingleSubsystemEmbedder):
    &#34;&#34;&#34;
        Include a triggered sub-system

        Optional:

            prevent_output_computation = True: 
                The subsystems outputs are only computed when triggered. Please note that the outputs
                of the subsystem are uninitialized until the subsystem is triggered for the first time.

    &#34;&#34;&#34;

    def __init__(self, sim : System, control_input : Signal, subsystem_prototype : GenericSubsystem,  prevent_output_computation = False ):
        
        self._control_input = control_input
        self.prevent_output_computation = prevent_output_computation

        SingleSubsystemEmbedder.__init__(self, sim, 
                                        control_inputs=[control_input], 
                                        subsystem_prototype=subsystem_prototype, 
                                        number_of_control_outputs=0 )


    def generate_code_output_list(self, language, signals : List [ Signal ] ):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:
            
            # generate code to call subsystem output(s)
            code_compute_output = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                assign_to_signals=signals, 
                ouput_signals_of_subsystem=self.outputs_map_from_embedding_block_to_subsystem.map( signals ),
                calculate_outputs = True, update_states = False 
            )

            if self.prevent_output_computation:

                # the subsystems outputs are only computed when triggered
                lines += cgh.generate_if_else(language, 
                    condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
                    action_list=[ code_compute_output ])

                # TODO: Design choice: assign NAN to the output values for self._control_input.name == 0 ?

            else:
                # the subsystems outputs are always computed
                lines += code_compute_output


        return lines

    def generate_code_update(self, language):

        lines = &#39;&#39;
        if language == &#39;c++&#39;:

            # generate code to compute the state update of the subsystem
            code_compute_state_update = embed_subsystem3(
                language, 
                subsystem_prototype=self._subsystem_prototype, 
                calculate_outputs = False, update_states = True
            )

            # the subsystems update is only performed when triggered
            lines += cgh.generate_if_else(language, 
                condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
                action_list=[ code_compute_state_update ])

        return lines</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder" href="block_prototypes_single_subsystem.html#openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></li>
<li><a title="openrtdynamics2.lang.block_interface.BlockPrototype" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype">BlockPrototype</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openrtdynamics2.lang.block_prototypes.TruggeredSubsystem.generate_code_output_list"><code class="name flex">
<span>def <span class="ident">generate_code_output_list</span></span>(<span>self, language, signals: List[<a title="openrtdynamics2.lang.diagram_core.signal_network.signals.Signal" href="diagram_core/signal_network/signals.html#openrtdynamics2.lang.diagram_core.signal_network.signals.Signal">Signal</a>])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_output_list(self, language, signals : List [ Signal ] ):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:
        
        # generate code to call subsystem output(s)
        code_compute_output = embed_subsystem3(
            language, 
            subsystem_prototype=self._subsystem_prototype, 
            assign_to_signals=signals, 
            ouput_signals_of_subsystem=self.outputs_map_from_embedding_block_to_subsystem.map( signals ),
            calculate_outputs = True, update_states = False 
        )

        if self.prevent_output_computation:

            # the subsystems outputs are only computed when triggered
            lines += cgh.generate_if_else(language, 
                condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
                action_list=[ code_compute_output ])

            # TODO: Design choice: assign NAN to the output values for self._control_input.name == 0 ?

        else:
            # the subsystems outputs are always computed
            lines += code_compute_output


    return lines</code></pre>
</details>
</dd>
<dt id="openrtdynamics2.lang.block_prototypes.TruggeredSubsystem.generate_code_update"><code class="name flex">
<span>def <span class="ident">generate_code_update</span></span>(<span>self, language)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_code_update(self, language):

    lines = &#39;&#39;
    if language == &#39;c++&#39;:

        # generate code to compute the state update of the subsystem
        code_compute_state_update = embed_subsystem3(
            language, 
            subsystem_prototype=self._subsystem_prototype, 
            calculate_outputs = False, update_states = True
        )

        # the subsystems update is only performed when triggered
        lines += cgh.generate_if_else(language, 
            condition_list=[ cgh.generate_compare_equality_to_constant( language, self._control_input.name, 1 ) ], 
            action_list=[ code_compute_state_update ])

    return lines</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder" href="block_prototypes_single_subsystem.html#openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder">SingleSubsystemEmbedder</a></b></code>:
<ul class="hlist">
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.codegen_addToNamespace" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.codegen_addToNamespace">codegen_addToNamespace</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.compile_callback_all_datatypes_defined" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_datatypes_defined">compile_callback_all_datatypes_defined</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.compile_callback_all_subsystems_compiled" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.compile_callback_all_subsystems_compiled">compile_callback_all_subsystems_compiled</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.config_request_define_feedforward_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_feedforward_input_dependencies">config_request_define_feedforward_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.config_request_define_state_update_input_dependencies" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.config_request_define_state_update_input_dependencies">config_request_define_state_update_input_dependencies</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.generate_code_defStates" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_defStates">generate_code_defStates</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.generate_code_destruct" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_destruct">generate_code_destruct</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.generate_code_init" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_init">generate_code_init</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.generate_code_setOutputReference" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.generate_code_setOutputReference">generate_code_setOutputReference</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes_single_subsystem.SingleSubsystemEmbedder.update_input_config" href="block_interface.html#openrtdynamics2.lang.block_interface.BlockPrototype.update_input_config">update_input_config</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openrtdynamics2.lang" href="index.html">openrtdynamics2.lang</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.Add" href="#openrtdynamics2.lang.block_prototypes.Add">Add</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.Add.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.Add.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.ComparisionOperator" href="#openrtdynamics2.lang.block_prototypes.ComparisionOperator">ComparisionOperator</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.ComparisionOperator.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.ComparisionOperator.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.ComparisionOperator.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.ComparisionOperator.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.ConditionalOverwrite" href="#openrtdynamics2.lang.block_prototypes.ConditionalOverwrite">ConditionalOverwrite</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.ConditionalOverwrite.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.ConditionalOverwrite.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.ConditionalOverwrite.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.ConditionalOverwrite.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.Const" href="#openrtdynamics2.lang.block_prototypes.Const">Const</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.Const.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.Const.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.ConvertDatatype" href="#openrtdynamics2.lang.block_prototypes.ConvertDatatype">ConvertDatatype</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.ConvertDatatype.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.ConvertDatatype.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.ConvertDatatype.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.ConvertDatatype.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.Delay" href="#openrtdynamics2.lang.block_prototypes.Delay">Delay</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.Delay.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.Delay.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Delay.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.Delay.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Delay.generate_code_reset" href="#openrtdynamics2.lang.block_prototypes.Delay.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Delay.generate_code_update" href="#openrtdynamics2.lang.block_prototypes.Delay.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.Flipflop" href="#openrtdynamics2.lang.block_prototypes.Flipflop">Flipflop</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.Flipflop.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.Flipflop.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_reset" href="#openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_update" href="#openrtdynamics2.lang.block_prototypes.Flipflop.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.Gain" href="#openrtdynamics2.lang.block_prototypes.Gain">Gain</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.Gain.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.Gain.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.GenericCppStatic" href="#openrtdynamics2.lang.block_prototypes.GenericCppStatic">GenericCppStatic</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.GenericCppStatic.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.GenericCppStatic.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.GenericCppStatic.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.GenericCppStatic.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem" href="#openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem">LoopUntilSubsystem</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem.generate_code_update" href="#openrtdynamics2.lang.block_prototypes.LoopUntilSubsystem.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.Memory" href="#openrtdynamics2.lang.block_prototypes.Memory">Memory</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.Memory.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.Memory.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Memory.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.Memory.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Memory.generate_code_reset" href="#openrtdynamics2.lang.block_prototypes.Memory.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.Memory.generate_code_update" href="#openrtdynamics2.lang.block_prototypes.Memory.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.MemoryRead" href="#openrtdynamics2.lang.block_prototypes.MemoryRead">MemoryRead</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.MemoryRead.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.MemoryRead.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.MemoryRead.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.MemoryRead.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.Operator0" href="#openrtdynamics2.lang.block_prototypes.Operator0">Operator0</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.Operator0.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.Operator0.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.Operator1" href="#openrtdynamics2.lang.block_prototypes.Operator1">Operator1</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.Operator1.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.Operator1.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems" href="#openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems">StatemachineSwitchSubsystems</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_reset" href="#openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_reset">generate_code_reset</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_update" href="#openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_code_update">generate_code_update</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_switch_to_reset_leaving_subsystem" href="#openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.generate_switch_to_reset_leaving_subsystem">generate_switch_to_reset_leaving_subsystem</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.state_output" href="#openrtdynamics2.lang.block_prototypes.StatemachineSwitchSubsystems.state_output">state_output</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.StaticFnByName_1To1" href="#openrtdynamics2.lang.block_prototypes.StaticFnByName_1To1">StaticFnByName_1To1</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.StaticFnByName_1To1.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.StaticFnByName_1To1.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.StaticFnByName_2To1" href="#openrtdynamics2.lang.block_prototypes.StaticFnByName_2To1">StaticFnByName_2To1</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.StaticFnByName_2To1.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.StaticFnByName_2To1.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.SwitchNto1" href="#openrtdynamics2.lang.block_prototypes.SwitchNto1">SwitchNto1</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.SwitchNto1.config_request_define_output_types" href="#openrtdynamics2.lang.block_prototypes.SwitchNto1.config_request_define_output_types">config_request_define_output_types</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.SwitchNto1.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.SwitchNto1.generate_code_output_list">generate_code_output_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.SwitchSubsystems" href="#openrtdynamics2.lang.block_prototypes.SwitchSubsystems">SwitchSubsystems</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.SwitchSubsystems.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.SwitchSubsystems.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.SwitchSubsystems.generate_code_update" href="#openrtdynamics2.lang.block_prototypes.SwitchSubsystems.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="openrtdynamics2.lang.block_prototypes.TruggeredSubsystem" href="#openrtdynamics2.lang.block_prototypes.TruggeredSubsystem">TruggeredSubsystem</a></code></h4>
<ul class="">
<li><code><a title="openrtdynamics2.lang.block_prototypes.TruggeredSubsystem.generate_code_output_list" href="#openrtdynamics2.lang.block_prototypes.TruggeredSubsystem.generate_code_output_list">generate_code_output_list</a></code></li>
<li><code><a title="openrtdynamics2.lang.block_prototypes.TruggeredSubsystem.generate_code_update" href="#openrtdynamics2.lang.block_prototypes.TruggeredSubsystem.generate_code_update">generate_code_update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>